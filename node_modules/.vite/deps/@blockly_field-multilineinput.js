import {
  require_dart_compressed,
  require_javascript_compressed,
  require_lua_compressed,
  require_php_compressed
} from "./chunk-EUSV3ZBU.js";
import {
  require_python_compressed
} from "./chunk-EKICIPQK.js";
import {
  require_blockly_compressed
} from "./chunk-37NJYYKB.js";
import {
  __commonJS
} from "./chunk-PLDDJCW6.js";

// node_modules/@blockly/field-multilineinput/dist/index.js
var require_dist = __commonJS({
  "node_modules/@blockly/field-multilineinput/dist/index.js"(exports, module) {
    !(function(t, e) {
      if ("object" == typeof exports && "object" == typeof module) module.exports = e(require_blockly_compressed(), require_javascript_compressed(), require_dart_compressed(), require_lua_compressed(), require_php_compressed(), require_python_compressed());
      else if ("function" == typeof define && define.amd) define(["blockly/core", "blockly/javascript", "blockly/dart", "blockly/lua", "blockly/php", "blockly/python"], e);
      else {
        var i = "object" == typeof exports ? e(require_blockly_compressed(), require_javascript_compressed(), require_dart_compressed(), require_lua_compressed(), require_php_compressed(), require_python_compressed()) : e(t.Blockly, t["Blockly.JavaScript"], t["Blockly.Dart"], t["Blockly.Lua"], t["Blockly.PHP"], t["Blockly.Python"]);
        for (var l in i) ("object" == typeof exports ? exports : t)[l] = i[l];
      }
    })(exports, (t, e, i, l, o, s) => (() => {
      "use strict";
      var r = { 127: (t2) => {
        t2.exports = e;
      }, 157: (t2) => {
        t2.exports = l;
      }, 370: (e2) => {
        e2.exports = t;
      }, 379: (t2) => {
        t2.exports = i;
      }, 537: (t2) => {
        t2.exports = o;
      }, 557: (t2) => {
        t2.exports = s;
      } }, n = {};
      function a(t2) {
        var e2 = n[t2];
        if (void 0 !== e2) return e2.exports;
        var i2 = n[t2] = { exports: {} };
        return r[t2](i2, i2.exports, a), i2.exports;
      }
      a.d = (t2, e2) => {
        for (var i2 in e2) a.o(e2, i2) && !a.o(t2, i2) && Object.defineProperty(t2, i2, { enumerable: true, get: e2[i2] });
      }, a.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), a.r = (t2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      };
      var u = {};
      a.r(u), a.d(u, { FieldMultilineInput: () => f, installAllBlocks: () => R, registerFieldMultilineInput: () => y, textMultiline: () => d });
      var d = {};
      a.r(d), a.d(d, { BLOCK_NAME: () => g, blockDefinition: () => k, installBlock: () => v, toDart: () => I, toJavascript: () => m, toLua: () => x, toPhp: () => D, toPython: () => b });
      var c = a(370), h = a(127), p = a(379), _ = a(157), T = a(537), E = a(557);
      class f extends c.FieldTextInput {
        constructor(t2, e2, i2) {
          super(c.Field.SKIP_SETUP), this.textGroup = null, this.maxLines_ = 1 / 0, this.isOverflowedY_ = false, t2 !== c.Field.SKIP_SETUP && (i2 && this.configure_(i2), this.setValue(t2), e2 && this.setValidator(e2));
        }
        configure_(t2) {
          super.configure_(t2), t2.maxLines && this.setMaxLines(t2.maxLines);
        }
        toXml(t2) {
          return t2.textContent = this.getValue().replace(/\n/g, "&#10;"), t2;
        }
        fromXml(t2) {
          this.setValue(t2.textContent.replace(/&#10;/g, "\n"));
        }
        saveState() {
          const t2 = this.saveLegacyState(f);
          return null !== t2 ? t2 : this.getValue();
        }
        loadState(t2) {
          this.loadLegacyState(c.Field, t2) || this.setValue(t2);
        }
        initView() {
          this.createBorderRect_(), this.textGroup = c.utils.dom.createSvgElement(c.utils.Svg.G, { class: "blocklyEditableField" }, this.fieldGroup_);
        }
        getDisplayText_() {
          const t2 = this.getSourceBlock();
          if (!t2) throw new Error("The field has not yet been attached to its input. Call appendField to attach it.");
          let e2 = this.getText();
          if (!e2) return c.Field.NBSP;
          const i2 = e2.split("\n");
          e2 = "";
          const l2 = this.isOverflowedY_ ? this.maxLines_ : i2.length;
          for (let t3 = 0; t3 < l2; t3++) {
            let o2 = i2[t3];
            o2.length > this.maxDisplayLength ? o2 = o2.substring(0, this.maxDisplayLength - 4) + "..." : this.isOverflowedY_ && t3 === l2 - 1 && (o2 = o2.substring(0, o2.length - 3) + "..."), o2 = o2.replace(/\s/g, c.Field.NBSP), e2 += o2, t3 !== l2 - 1 && (e2 += "\n");
          }
          return t2.RTL && (e2 += "‏"), e2;
        }
        doValueUpdate_(t2) {
          super.doValueUpdate_(t2), null !== this.value_ && (this.isOverflowedY_ = this.value_.split("\n").length > this.maxLines_);
        }
        render_() {
          const t2 = this.getSourceBlock();
          if (!t2) throw new Error("The field has not yet been attached to its input. Call appendField to attach it.");
          let e2;
          const i2 = this.textGroup;
          for (; e2 = i2.firstChild; ) i2.removeChild(e2);
          const l2 = this.getConstants();
          if (!l2) throw Error("Constants not found");
          const o2 = this.getDisplayText_().split("\n");
          let s2 = 0;
          for (let t3 = 0; t3 < o2.length; t3++) {
            const e3 = l2.FIELD_TEXT_HEIGHT + l2.FIELD_BORDER_RECT_Y_PADDING;
            c.utils.dom.createSvgElement(c.utils.Svg.TEXT, { class: "blocklyText blocklyMultilineText", x: l2.FIELD_BORDER_RECT_X_PADDING, y: s2 + l2.FIELD_BORDER_RECT_Y_PADDING, dy: l2.FIELD_TEXT_BASELINE }, i2).appendChild(document.createTextNode(o2[t3])), s2 += e3;
          }
          if (this.isBeingEdited_) {
            const t3 = this.htmlInput_;
            this.isOverflowedY_ ? c.utils.dom.addClass(t3, "blocklyHtmlTextAreaInputOverflowedY") : c.utils.dom.removeClass(t3, "blocklyHtmlTextAreaInputOverflowedY");
          }
          if (this.updateSize_(), this.isBeingEdited_) {
            t2.RTL ? setTimeout(this.resizeEditor_.bind(this), 0) : this.resizeEditor_();
            const e3 = this.htmlInput_;
            this.isTextValid_ ? (c.utils.dom.removeClass(e3, "blocklyInvalidInput"), c.utils.aria.setState(e3, c.utils.aria.State.INVALID, false)) : (c.utils.dom.addClass(e3, "blocklyInvalidInput"), c.utils.aria.setState(e3, c.utils.aria.State.INVALID, true));
          }
        }
        updateSize_() {
          const t2 = this.getConstants();
          if (!t2) throw Error("Constants not found");
          const e2 = this.textGroup.childNodes, i2 = t2.FIELD_TEXT_FONTSIZE, l2 = t2.FIELD_TEXT_FONTWEIGHT, o2 = t2.FIELD_TEXT_FONTFAMILY;
          let s2 = 0, r2 = 0;
          for (let n2 = 0; n2 < e2.length; n2++) {
            const a2 = e2[n2], u2 = c.utils.dom.getFastTextWidth(a2, i2, l2, o2);
            u2 > s2 && (s2 = u2), r2 += t2.FIELD_TEXT_HEIGHT + (n2 > 0 ? t2.FIELD_BORDER_RECT_Y_PADDING : 0);
          }
          if (this.isBeingEdited_) {
            const t3 = String(this.value_).split("\n"), e3 = c.utils.dom.createSvgElement(c.utils.Svg.TEXT, { class: "blocklyText blocklyMultilineText" });
            for (let r4 = 0; r4 < t3.length; r4++) {
              t3[r4].length > this.maxDisplayLength && (t3[r4] = t3[r4].substring(0, this.maxDisplayLength)), e3.textContent = t3[r4];
              const n2 = c.utils.dom.getFastTextWidth(e3, i2, l2, o2);
              n2 > s2 && (s2 = n2);
            }
            const r3 = this.htmlInput_;
            s2 += r3.offsetWidth - r3.clientWidth;
          }
          this.borderRect_ && (r2 += 2 * t2.FIELD_BORDER_RECT_Y_PADDING, s2 += 2 * t2.FIELD_BORDER_RECT_X_PADDING + 1, this.borderRect_.setAttribute("width", `${s2}`), this.borderRect_.setAttribute("height", `${r2}`)), this.size_.width = s2, this.size_.height = r2, this.positionBorderRect_();
        }
        showEditor_(t2, e2) {
          super.showEditor_(t2, e2), this.forceRerender();
        }
        widgetCreate_() {
          const t2 = c.WidgetDiv.getDiv(), e2 = this.workspace_.getScale(), i2 = this.getConstants();
          if (!i2) throw Error("Constants not found");
          const l2 = document.createElement("textarea");
          l2.className = "blocklyHtmlInput blocklyHtmlTextAreaInput", l2.setAttribute("spellcheck", String(this.spellcheck_));
          const o2 = i2.FIELD_TEXT_FONTSIZE * e2 + "pt";
          t2.style.fontSize = o2, l2.style.fontSize = o2;
          const s2 = c.FieldTextInput.BORDERRADIUS * e2 + "px";
          l2.style.borderRadius = s2;
          const r2 = i2.FIELD_BORDER_RECT_X_PADDING * e2, n2 = i2.FIELD_BORDER_RECT_Y_PADDING * e2 / 2;
          l2.style.padding = n2 + "px " + r2 + "px " + n2 + "px " + r2 + "px";
          const a2 = i2.FIELD_TEXT_HEIGHT + i2.FIELD_BORDER_RECT_Y_PADDING;
          return l2.style.lineHeight = a2 * e2 + "px", t2.appendChild(l2), l2.value = l2.defaultValue = this.getEditorText_(this.value_), l2.setAttribute("data-untyped-default-value", String(this.value_)), l2.setAttribute("data-old-value", ""), c.utils.userAgent.GECKO ? setTimeout(this.resizeEditor_.bind(this), 0) : this.resizeEditor_(), this.bindInputEvents_(l2), l2;
        }
        setMaxLines(t2) {
          "number" == typeof t2 && t2 > 0 && t2 !== this.maxLines_ && (this.maxLines_ = t2, this.forceRerender());
        }
        getMaxLines() {
          return this.maxLines_;
        }
        onHtmlInputKeyDown_(t2) {
          "Enter" !== t2.key && super.onHtmlInputKeyDown_(t2);
        }
        static fromJson(t2) {
          return new this(c.utils.parsing.replaceMessageReferences(t2.text), void 0, t2);
        }
      }
      function y() {
        c.fieldRegistry.register("field_multilinetext", f);
      }
      c.Css.register("\n.blocklyHtmlTextAreaInput {\n  font-family: monospace;\n  resize: none;\n  overflow: hidden;\n  height: 100%;\n  text-align: left;\n}\n\n.blocklyHtmlTextAreaInputOverflowedY {\n  overflow-y: scroll;\n}\n");
      const g = "text_multiline", A = { type: g, message0: "%1 %2", args0: [{ type: "field_image", src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAARCAYAAADpPU2iAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAdhgAAHYYBXaITgQAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMS42/U4J6AAAAP1JREFUOE+Vks0KQUEYhjmRIja4ABtZ2dm5A3t3Ia6AUm7CylYuQRaUhZSlLZJiQbFAyRnPN33y01HOW08z8873zpwzM4F3GWOCruvGIE4/rLaV+Nq1hVGMBqzhqlxgCys4wJA65xnogMHsQ5lujnYHTejBBCK2mE4abjCgMGhNxHgDFWjDSG07kdfVa2pZMf4ZyMAdWmpZMfYOsLiDMYMjlMB+K613QISRhTnITnsYg5yUd0DETmEoMlkFOeIT/A58iyK5E18BuTBfgYXfwNJv4P9/oEBerLylOnRhygmGdPpTTBZAPkde61lbQe4moWUvYUZYLfUNftIY4zwA5X2Z9AYnQrEAAAAASUVORK5CYII=", width: 12, height: 17, alt: "¶" }, { type: "field_multilinetext", name: "TEXT", text: "" }], output: "String", style: "text_blocks", helpUrl: "%{BKY_TEXT_TEXT_HELPURL}", tooltip: "%{BKY_TEXT_TEXT_TOOLTIP}", extensions: ["parent_tooltip_when_inline"] };
      function m(t2, e2) {
        const i2 = e2.multiline_quote_(t2.getFieldValue("TEXT")), l2 = -1 !== i2.indexOf("+") ? h.Order.ADDITION : h.Order.ATOMIC;
        return [i2, l2];
      }
      function I(t2, e2) {
        const i2 = e2.multiline_quote_(t2.getFieldValue("TEXT")), l2 = -1 !== i2.indexOf("+") ? p.Order.ADDITIVE : p.Order.ATOMIC;
        return [i2, l2];
      }
      function x(t2, e2) {
        const i2 = e2.multiline_quote_(t2.getFieldValue("TEXT")), l2 = -1 !== i2.indexOf("..") ? _.Order.CONCATENATION : _.Order.ATOMIC;
        return [i2, l2];
      }
      function D(t2, e2) {
        const i2 = e2.multiline_quote_(t2.getFieldValue("TEXT")), l2 = -1 !== i2.indexOf(".") ? T.Order.STRING_CONCAT : T.Order.ATOMIC;
        return [i2, l2];
      }
      function b(t2, e2) {
        const i2 = e2.multiline_quote_(t2.getFieldValue("TEXT")), l2 = -1 !== i2.indexOf("+") ? E.Order.ADDITIVE : E.Order.ATOMIC;
        return [i2, l2];
      }
      const O = c.common.createBlockDefinitionsFromJsonArray([A]), k = O[g];
      function v(t2 = {}) {
        y(), c.common.defineBlocks(O), t2.javascript && (t2.javascript.forBlock[g] = m), t2.dart && (t2.dart.forBlock[g] = I), t2.lua && (t2.lua.forBlock[g] = x), t2.php && (t2.php.forBlock[g] = D), t2.python && (t2.python.forBlock[g] = b);
      }
      const R = v;
      return u;
    })());
  }
});
export default require_dist();
/*! Bundled license information:

@blockly/field-multilineinput/dist/index.js:
  (*! For license information please see index.js.LICENSE.txt *)
*/
//# sourceMappingURL=@blockly_field-multilineinput.js.map
