import {
  require_blockly_compressed
} from "./chunk-37NJYYKB.js";
import {
  __commonJS
} from "./chunk-PLDDJCW6.js";

// node_modules/@blockly/field-grid-dropdown/dist/index.js
var require_dist = __commonJS({
  "node_modules/@blockly/field-grid-dropdown/dist/index.js"(exports, module) {
    !(function(e, t) {
      if ("object" == typeof exports && "object" == typeof module) module.exports = t(require_blockly_compressed());
      else if ("function" == typeof define && define.amd) define(["blockly/core"], t);
      else {
        var o = "object" == typeof exports ? t(require_blockly_compressed()) : t(e.Blockly);
        for (var i in o) ("object" == typeof exports ? exports : e)[i] = o[i];
      }
    })(exports, (e) => (() => {
      "use strict";
      var t = { 370: (t2) => {
        t2.exports = e;
      } }, o = {};
      function i(e2) {
        var s2 = o[e2];
        if (void 0 !== s2) return s2.exports;
        var r2 = o[e2] = { exports: {} };
        return t[e2](r2, r2.exports, i), r2.exports;
      }
      i.d = (e2, t2) => {
        for (var o2 in t2) i.o(t2, o2) && !i.o(e2, o2) && Object.defineProperty(e2, o2, { enumerable: true, get: t2[o2] });
      }, i.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), i.r = (e2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      };
      var s = {};
      i.r(s), i.d(s, { FieldGridDropdown: () => d });
      var r = i(370);
      class n {
        constructor(e2, t2, o2, i2) {
          this.value = o2, this.selected = false, this.selectionCallback = i2, this.element = document.createElement("button"), this.element.id = r.utils.idGenerator.getNextUniqueId(), this.element.className = "blocklyFieldGridItem", this.clickHandler = r.browserEvents.conditionalBind(this.element, "click", this, this.onClick, true), e2.appendChild(this.element);
          const s2 = "string" == typeof t2 ? document.createTextNode(t2) : t2;
          this.element.appendChild(s2), r.utils.aria.setRole(this.element, r.utils.aria.Role.GRIDCELL);
        }
        dispose() {
          this.selectionCallback = null, this.element.remove(), this.clickHandler && (r.browserEvents.unbind(this.clickHandler), this.clickHandler = null);
        }
        getId() {
          return this.element.id;
        }
        getValue() {
          return this.value;
        }
        isSelected() {
          return this.selected;
        }
        setSelected(e2) {
          this.selected = e2, r.utils.aria.setState(this.element, r.utils.aria.State.SELECTED, this.selected), this.element.classList.toggle("blocklyFieldGridItemSelected", this.selected), this.isSelected() && this.focus();
        }
        onClick() {
          var e2;
          this.setSelected(true), null === (e2 = this.selectionCallback) || void 0 === e2 || e2.call(this, this);
        }
        focus() {
          this.element.focus({ preventScroll: true });
          const e2 = this.element.offsetParent;
          if (!e2) return;
          const t2 = this.element.offsetTop, o2 = e2.scrollTop, i2 = this.getInterItemSpacing();
          t2 < o2 ? e2.scrollTo(0, t2 - i2) : t2 + this.element.offsetHeight > o2 + e2.clientHeight && e2.scrollBy(0, t2 + this.element.clientHeight - (o2 + e2.clientHeight) + i2);
        }
        getInterItemSpacing() {
          const e2 = this.element.closest(".blocklyFieldGrid");
          if (!e2) return 0;
          const t2 = [...e2.querySelectorAll(".blocklyFieldGridItem")];
          if (!t2.length) return 0;
          const o2 = t2[0].offsetTop, i2 = t2[0].offsetHeight;
          for (const e3 of t2) if (e3.offsetTop !== o2) return e3.offsetTop - i2 - o2;
          return 0;
        }
      }
      class l {
        constructor(e2, t2, o2, i2, s2) {
          if (this.columns = o2, this.rtl = i2, this.itemIndices = /* @__PURE__ */ new Map(), this.items = new Array(), this.keyDownHandler = null, this.pointerMoveHandler = null, this.selectionCallback = s2, this.root = document.createElement("div"), this.root.className = "blocklyFieldGrid", this.root.tabIndex = 0, r.utils.aria.setRole(this.root, r.utils.aria.Role.GRID), e2.appendChild(this.root), this.populateItems(t2), this.keyDownHandler = r.browserEvents.conditionalBind(this.root, "keydown", this, this.onKeyDown), this.pointerMoveHandler = r.browserEvents.conditionalBind(this.root, "pointermove", this, this.onPointerMove, true), !(o2 >= 1)) throw new Error(`Number of columns must be >= 1; got ${o2}`);
          this.columns = o2, this.root.style.setProperty("--grid-columns", `${this.columns}`);
        }
        populateItems(e2) {
          let t2 = document.createElement("div");
          for (const [o2, i2] of e2.entries()) {
            if (i2 === r.FieldDropdown.SEPARATOR) continue;
            o2 % this.columns === 0 && (t2 = document.createElement("div"), t2.className = "blocklyFieldGridRow", r.utils.aria.setRole(t2, r.utils.aria.Role.ROW), this.root.appendChild(t2));
            const [e3, s2] = i2, l2 = (() => {
              if ((t3 = e3) && "object" == typeof t3 && "src" in t3 && "string" == typeof t3.src && "alt" in t3 && "string" == typeof t3.alt && "width" in t3 && "number" == typeof t3.width && "height" in t3 && "number" == typeof t3.height) {
                const t4 = new Image(e3.width, e3.height);
                return t4.src = e3.src, t4.alt = e3.alt || "", t4;
              }
              var t3;
              return e3;
            })(), d2 = new n(t2, l2, s2, (e4) => {
              var t3;
              this.setSelectedValue(e4.getValue()), null === (t3 = this.selectionCallback) || void 0 === t3 || t3.call(this, e4);
            });
            this.itemIndices.set(d2.getId(), this.itemIndices.size), this.items.push(d2);
          }
        }
        dispose() {
          this.selectionCallback = void 0;
          for (const e2 of this.items) e2.dispose();
          this.itemIndices.clear(), this.items.length = 0, this.keyDownHandler && (r.browserEvents.unbind(this.keyDownHandler), this.keyDownHandler = null), this.pointerMoveHandler && (r.browserEvents.unbind(this.pointerMoveHandler), this.pointerMoveHandler = null), this.root.remove();
        }
        onKeyDown(e2) {
          if (!(!this.items.length || e2.shiftKey || e2.ctrlKey || e2.metaKey || e2.altKey)) {
            switch (e2.key) {
              case "ArrowUp":
                this.moveFocus(-1 * this.columns, true);
                break;
              case "ArrowDown":
                this.moveFocus(this.columns, true);
                break;
              case "ArrowLeft":
                this.moveFocus(-1 * (this.rtl ? -1 : 1), true);
                break;
              case "ArrowRight":
                this.moveFocus(1 * (this.rtl ? -1 : 1), true);
                break;
              case "PageUp":
              case "Home":
                this.moveFocus(0, false);
                break;
              case "PageDown":
              case "End":
                this.moveFocus(this.items.length - 1, false);
                break;
              case "Enter":
              case "Space":
                return void e2.stopPropagation();
              default:
                return;
            }
            e2.preventDefault(), e2.stopPropagation();
          }
        }
        onPointerMove(e2) {
          if (!e2.movementX && !e2.movementY || !(e2.target instanceof Element)) return;
          const t2 = e2.target.closest(".blocklyFieldGridItem");
          if (!t2) return;
          const o2 = t2.id, i2 = this.itemIndices.get(o2);
          void 0 !== i2 && this.moveFocus(i2, false);
        }
        setSelectedValue(e2) {
          for (const [t2, o2] of this.items.entries()) {
            const i2 = o2.getValue() === e2;
            o2.setSelected(i2), i2 && this.moveFocus(t2, false);
          }
        }
        moveFocus(e2, t2) {
          let o2 = e2;
          if (t2) {
            const e3 = this.getFocusedItem();
            if (!e3) return;
            o2 += this.indexOfItem(e3);
          }
          const i2 = this.itemAtIndex(o2);
          i2 && (i2.focus(), r.utils.aria.setState(this.root, r.utils.aria.State.ACTIVEDESCENDANT, i2.getId()));
        }
        indexOfItem(e2) {
          var t2;
          return null !== (t2 = this.itemIndices.get(e2.getId())) && void 0 !== t2 ? t2 : -1;
        }
        itemAtIndex(e2) {
          return this.items[e2];
        }
        getFocusedItem() {
          var e2;
          const t2 = null !== (e2 = this.root.querySelector(".blocklyFieldGridItem:focus")) && void 0 !== e2 ? e2 : this.root.querySelector(".blocklyFieldGridItem");
          if (!t2 || !t2.id) return;
          const o2 = this.itemIndices.get(t2.id);
          return void 0 !== o2 ? this.itemAtIndex(o2) : void 0;
        }
      }
      class d extends r.FieldDropdown {
        constructor(e2, t2, o2) {
          super(e2, t2, o2), this.columns = 3, (null == o2 ? void 0 : o2.columns) && this.setColumns(parseInt(`${o2.columns}`)), o2 && o2.primaryColour && (this.primaryColour = o2.primaryColour), o2 && o2.borderColour && (this.borderColour = o2.borderColour);
        }
        static fromJson(e2) {
          if (!e2.options) throw new Error("options are required for the dropdown field. The options property must be assigned an array of [humanReadableValue, languageNeutralValue] tuples.");
          return new this(e2.options, void 0, e2);
        }
        setColumns(e2) {
          var t2;
          !isNaN(e2) && e2 >= 1 && (this.columns = e2, r.DropDownDiv.getOwner() === this && r.DropDownDiv.isVisible() && (null === (t2 = this.grid) || void 0 === t2 || t2.dispose(), this.showEditor_()));
        }
        showEditor_(e2) {
          var t2;
          r.DropDownDiv.clearContent();
          const o2 = !!(null === (t2 = this.getSourceBlock()) || void 0 === t2 ? void 0 : t2.workspace.RTL);
          this.grid = new l(r.DropDownDiv.getContentDiv(), this.getOptions(false), this.columns, o2, (e3) => {
            r.DropDownDiv.hideIfOwner(this), this.setValue(e3.getValue());
          }), r.DropDownDiv.getContentDiv().classList.add("blocklyFieldGridContainer");
          const i2 = this.getColours();
          i2 && i2.border && r.DropDownDiv.setColour(i2.primary, i2.border), r.DropDownDiv.showPositionedByField(this, this.dropdownDispose_.bind(this));
          const s2 = this.getValue();
          s2 && this.grid.setSelectedValue(s2);
        }
        doValueUpdate_(e2) {
          var t2;
          super.doValueUpdate_(e2), null === (t2 = this.grid) || void 0 === t2 || t2.setSelectedValue(e2);
        }
        getColours() {
          var e2, t2;
          if (this.primaryColour && this.borderColour) return { primary: this.primaryColour, border: this.borderColour };
          const o2 = this.getSourceBlock();
          if (!(o2 instanceof r.BlockSvg)) return;
          const i2 = o2.isShadow() ? o2.getParent() : o2;
          return i2 ? { primary: null !== (e2 = this.primaryColour) && void 0 !== e2 ? e2 : i2.getColour(), border: null !== (t2 = this.borderColour) && void 0 !== t2 ? t2 : i2.getColourTertiary() } : void 0;
        }
      }
      return r.fieldRegistry.register("field_grid_dropdown", d), r.Css.register("\n   .blocklyFieldGridContainer {\n     padding: 7px;\n     overflow: auto;\n   }\n   \n  .blocklyFieldGrid {\n    display: grid;\n    grid-gap: 7px;\n    grid-template-columns: repeat(var(--grid-columns), min-content);\n  }\n\n .blocklyFieldGrid .blocklyFieldGridItem {\n   border: 1px solid rgba(1, 1, 1, 0.5);\n   border-radius: 4px;\n   color: white;\n   min-width: auto;\n   background: none;\n   white-space: nowrap;\n   cursor: pointer;\n   padding: 6px 15px;\n }\n \n .blocklyFieldGrid .blocklyFieldGridRow {\n   display: contents;\n }\n \n .blocklyFieldGrid .blocklyFieldGridItem.blocklyFieldGridItemSelected {\n   background-color: rgba(1, 1, 1, 0.25);\n }\n\n .blocklyFieldGrid .blocklyFieldGridItem:focus {\n   box-shadow: 0 0 0 4px hsla(0, 0%, 100%, .2);\n   outline: none;\n }\n "), s;
    })());
  }
});
export default require_dist();
/*! Bundled license information:

@blockly/field-grid-dropdown/dist/index.js:
  (*! For license information please see index.js.LICENSE.txt *)
*/
//# sourceMappingURL=@blockly_field-grid-dropdown.js.map
