{
  "version": 3,
  "sources": ["webpack://@blockly/toolbox-search/webpack/universalModuleDefinition", "webpack://@blockly/toolbox-search/external%20umd%20%7B%22root%22:%22Blockly%22,%22commonjs%22:%22blockly/core%22,%22commonjs2%22:%22blockly/core%22,%22amd%22:%22blockly/core%22%7D", "webpack://@blockly/toolbox-search/webpack/bootstrap", "webpack://@blockly/toolbox-search/src/block_searcher.ts", "webpack://@blockly/toolbox-search/src/toolbox_search.ts"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__370__) => {\nreturn ", "module.exports = __WEBPACK_EXTERNAL_MODULE__370__;", "// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * A class that provides methods for indexing and searching blocks.\n */\nexport class BlockSearcher {\n  private trigramsToBlocks = new Map<\n    string,\n    Set<Blockly.utils.toolbox.BlockInfo>\n  >();\n\n  /**\n   * Populates the cached map of trigrams to the blocks they correspond to.\n   *\n   * This method must be called before blockTypesMatching(). Behind the\n   * scenes, it creates a workspace, loads the specified block types on it,\n   * indexes their types and human-readable text, and cleans up after\n   * itself.\n   *\n   * @param blockInfos A list of blocks to index.\n   */\n  indexBlocks(blockInfos: Blockly.utils.toolbox.BlockInfo[]) {\n    const blockCreationWorkspace = new Blockly.Workspace();\n    blockInfos.forEach((blockInfo) => {\n      const type = blockInfo.type;\n      if (!type || type === '') return;\n      const block = blockCreationWorkspace.newBlock(type);\n      this.indexBlockText(type.replaceAll('_', ' '), blockInfo);\n      block.inputList.forEach((input) => {\n        input.fieldRow.forEach((field) => {\n          this.indexDropdownOption(field, blockInfo);\n          this.indexBlockText(field.getText(), blockInfo);\n        });\n      });\n    });\n  }\n\n  /**\n   * Check if the field is a dropdown, and index every text in the option\n   *\n   * @param field We need to check the type of field\n   * @param block The block to associate the trigrams with.\n   */\n  private indexDropdownOption(\n    field: Blockly.Field,\n    block: Blockly.utils.toolbox.BlockInfo,\n  ) {\n    if (field instanceof Blockly.FieldDropdown) {\n      field.getOptions(true).forEach((option) => {\n        if (typeof option[0] === 'string') {\n          this.indexBlockText(option[0], block);\n        } else if ('alt' in option[0]) {\n          this.indexBlockText(option[0].alt, block);\n        }\n      });\n    }\n  }\n\n  /**\n   * Filters the available blocks based on the current query string.\n   *\n   * @param query The text to use to match blocks against.\n   * @returns A list of blocks matching the query.\n   */\n  blockTypesMatching(query: string): Blockly.utils.toolbox.BlockInfo[] {\n    return [\n      ...this.generateTrigrams(query)\n        .map((trigram) => {\n          return (\n            this.trigramsToBlocks.get(trigram) ??\n            new Set<Blockly.utils.toolbox.BlockInfo>()\n          );\n        })\n        .reduce((matches, current) => {\n          return this.getIntersection(matches, current);\n        })\n        .values(),\n    ];\n  }\n\n  /**\n   * Generates trigrams for the given text and associates them with the given\n   * block.\n   *\n   * @param text The text to generate trigrams of.\n   * @param block The block to associate the trigrams with.\n   */\n  private indexBlockText(text: string, block: Blockly.utils.toolbox.BlockInfo) {\n    this.generateTrigrams(text).forEach((trigram) => {\n      const blockSet =\n        this.trigramsToBlocks.get(trigram) ??\n        new Set<Blockly.utils.toolbox.BlockInfo>();\n      blockSet.add(block);\n      this.trigramsToBlocks.set(trigram, blockSet);\n    });\n  }\n\n  /**\n   * Generates a list of trigrams for a given string.\n   *\n   * @param input The string to generate trigrams of.\n   * @returns A list of trigrams of the given string.\n   */\n  private generateTrigrams(input: string): string[] {\n    const normalizedInput = input.toLowerCase();\n    if (!normalizedInput) return [];\n    if (normalizedInput.length <= 3) return [normalizedInput];\n\n    const trigrams: string[] = [];\n    for (let start = 0; start < normalizedInput.length - 3; start++) {\n      trigrams.push(normalizedInput.substring(start, start + 3));\n    }\n\n    return trigrams;\n  }\n\n  /**\n   * Returns the intersection of two sets.\n   *\n   * @param a The first set.\n   * @param b The second set.\n   * @returns The intersection of the two sets.\n   */\n  private getIntersection(\n    a: Set<Blockly.utils.toolbox.BlockInfo>,\n    b: Set<Blockly.utils.toolbox.BlockInfo>,\n  ): Set<Blockly.utils.toolbox.BlockInfo> {\n    return new Set([...a].filter((value) => b.has(value)));\n  }\n}\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * A toolbox category that provides a search field and displays matching blocks\n * in its flyout.\n */\nimport * as Blockly from 'blockly/core';\nimport {BlockSearcher} from './block_searcher';\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * A toolbox category that provides a search field and displays matching blocks\n * in its flyout.\n */\nexport class ToolboxSearchCategory extends Blockly.ToolboxCategory {\n  private static readonly START_SEARCH_SHORTCUT = 'startSearch';\n  static readonly SEARCH_CATEGORY_KIND = 'search';\n  private readonly SEARCH_INPUT_ID = 'toolbox-search-input';\n  private searchField?: HTMLInputElement;\n  private blockSearcher = new BlockSearcher();\n\n  /**\n   * Initializes a ToolboxSearchCategory.\n   *\n   * @param categoryDef The information needed to create a category in the\n   *     toolbox.\n   * @param parentToolbox The parent toolbox for the category.\n   * @param opt_parent The parent category or null if the category does not have\n   *     a parent.\n   */\n  constructor(\n    categoryDef: Blockly.utils.toolbox.CategoryInfo,\n    parentToolbox: Blockly.IToolbox,\n    opt_parent?: Blockly.ICollapsibleToolboxItem,\n  ) {\n    super(categoryDef, parentToolbox, opt_parent);\n    this.initBlockSearcher();\n    this.registerShortcut();\n  }\n\n  /**\n   * Initializes the search field toolbox category.\n   *\n   * @returns The <div> that will be displayed in the toolbox.\n   */\n  protected override createDom_(): HTMLDivElement {\n    const dom = super.createDom_();\n    this.searchField = document.createElement('input');\n    this.searchField.id = this.SEARCH_INPUT_ID;\n    this.searchField.type = 'search';\n    this.searchField.placeholder = 'Search';\n    this.workspace_.RTL\n      ? (this.searchField.style.marginRight = '8px')\n      : (this.searchField.style.marginLeft = '8px');\n    this.searchField.addEventListener('keyup', (event) => {\n      if (event.key === 'Escape') {\n        this.parentToolbox_.clearSelection();\n        return;\n      }\n\n      this.matchBlocks();\n    });\n    this.rowContents_?.replaceChildren(this.searchField);\n    return dom;\n  }\n\n  /** The ID of the toolbox item must match the ID of the focusable node. */\n  override getId(): string {\n    return this.SEARCH_INPUT_ID;\n  }\n\n  /**\n   * Returns the numerical position of this category in its parent toolbox.\n   *\n   * @returns The zero-based index of this category in its parent toolbox, or -1\n   *    if it cannot be determined, e.g. if this is a nested category.\n   */\n  private getPosition() {\n    const categories = this.workspace_.options.languageTree?.contents || [];\n    for (let i = 0; i < categories.length; i++) {\n      if (categories[i].kind === ToolboxSearchCategory.SEARCH_CATEGORY_KIND) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Registers a shortcut for displaying the toolbox search category.\n   */\n  private registerShortcut() {\n    const shortcut = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.B,\n      [Blockly.utils.KeyCodes.CTRL],\n    );\n    Blockly.ShortcutRegistry.registry.register({\n      name: ToolboxSearchCategory.START_SEARCH_SHORTCUT,\n      callback: () => {\n        const position = this.getPosition();\n        if (position < 0) return false;\n        Blockly.getFocusManager().focusNode(this);\n        return true;\n      },\n      keyCodes: [shortcut],\n    });\n  }\n\n  /**\n   * Returns a list of block types that are present in the toolbox definition.\n   *\n   * @param schema A toolbox item definition.\n   * @param allBlocks The set of all available blocks that have been encountered\n   *     so far.\n   */\n  private getAvailableBlocks(\n    schema: Blockly.utils.toolbox.ToolboxItemInfo,\n    allBlocks: Set<Blockly.utils.toolbox.BlockInfo>,\n  ) {\n    if ('contents' in schema) {\n      schema.contents.forEach((contents) => {\n        this.getAvailableBlocks(contents, allBlocks);\n      });\n    } else if (schema.kind.toLowerCase() === 'block') {\n      if ('type' in schema && schema.type) {\n        allBlocks.add(schema);\n      }\n    }\n  }\n\n  /**\n   * Builds the BlockSearcher index based on the available blocks.\n   */\n  private initBlockSearcher() {\n    const availableBlocks = new Set<Blockly.utils.toolbox.BlockInfo>();\n    this.workspace_.options.languageTree?.contents?.forEach((item) =>\n      this.getAvailableBlocks(item, availableBlocks),\n    );\n    this.blockSearcher.indexBlocks([...availableBlocks]);\n  }\n\n  /** See IFocusableNode.getFocusableElement. */\n  override getFocusableElement(): HTMLElement | SVGElement {\n    if (!this.searchField) {\n      throw Error('This field currently has no representative DOM element.');\n    }\n    return this.searchField;\n  }\n\n  /** See IFocusableNode.onNodeFocus. */\n  override onNodeFocus(): void {\n    this.matchBlocks();\n  }\n\n  /** See IFocusableNode.onNodeBlur. */\n  override onNodeBlur(): void {\n    if (!this.searchField) return;\n    this.searchField.value = '';\n  }\n\n  /**\n   * Filters the available blocks based on the current query string.\n   */\n  private matchBlocks() {\n    const query = this.searchField?.value || '';\n\n    this.flyoutItems_ = query\n      ? this.blockSearcher.blockTypesMatching(query)\n      : [];\n\n    if (!this.flyoutItems_.length) {\n      this.flyoutItems_.push({\n        kind: 'label',\n        text:\n          query.length < 3\n            ? 'Type to search for blocks'\n            : 'No matching blocks found',\n      });\n    }\n    this.parentToolbox_.refreshSelection();\n  }\n\n  /**\n   * Disposes of this category.\n   */\n  override dispose() {\n    super.dispose();\n    Blockly.ShortcutRegistry.registry.unregister(\n      ToolboxSearchCategory.START_SEARCH_SHORTCUT,\n    );\n  }\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.TOOLBOX_ITEM,\n  ToolboxSearchCategory.SEARCH_CATEGORY_KIND,\n  ToolboxSearchCategory,\n);\n"],
  "mappings": "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",
  "names": ["root", "factory", "exports", "module", "require", "define", "amd", "a", "i", "this", "__WEBPACK_EXTERNAL_MODULE__370__", "__webpack_module_cache__", "__webpack_require__", "moduleId", "cachedModule", "__webpack_modules__", "BlockSearcher", "trigramsToBlocks", "Map", "blockInfos", "blockCreationWorkspace", "forEach", "blockInfo", "type", "block", "newBlock", "indexBlockText", "replaceAll", "inputList", "input", "fieldRow", "field", "indexDropdownOption", "getText", "getOptions", "option", "alt", "query", "generateTrigrams", "map", "trigram", "t", "get", "Set", "reduce", "matches", "current", "getIntersection", "values", "text", "blockSet", "r", "add", "set", "normalizedInput", "toLowerCase", "length", "trigrams", "start", "push", "substring", "b", "filter", "value", "has", "ToolboxSearchCategory", "categoryDef", "parentToolbox", "opt_parent", "super", "SEARCH_INPUT_ID", "blockSearcher", "initBlockSearcher", "registerShortcut", "createDom_", "dom", "searchField", "document", "createElement", "id", "placeholder", "workspace_", "RTL", "style", "marginRight", "marginLeft", "addEventListener", "event", "key", "matchBlocks", "parentToolbox_", "clearSelection", "e", "rowContents_", "replaceChildren", "getId", "getPosition", "categories", "options", "languageTree", "contents", "kind", "SEARCH_CATEGORY_KIND", "shortcut", "registry", "createSerializedKey", "KeyCodes", "B", "CTRL", "register", "name", "START_SEARCH_SHORTCUT", "callback", "focusNode", "keyCodes", "schema", "allBlocks", "getAvailableBlocks", "availableBlocks", "item", "indexBlocks", "getFocusableElement", "Error", "onNodeFocus", "onNodeBlur", "flyoutItems_", "blockTypesMatching", "refreshSelection", "dispose", "unregister", "Type", "TOOLBOX_ITEM"]
}
