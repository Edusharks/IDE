{
  "version": 3,
  "sources": ["webpack://@blockly/field-dependent-dropdown/webpack/universalModuleDefinition", "webpack://@blockly/field-dependent-dropdown/external%20umd%20%7B%22root%22:%22Blockly%22,%22commonjs%22:%22blockly/core%22,%22commonjs2%22:%22blockly/core%22,%22amd%22:%22blockly/core%22%7D", "webpack://@blockly/field-dependent-dropdown/webpack/bootstrap", "webpack://@blockly/field-dependent-dropdown/webpack/runtime/define%20property%20getters", "webpack://@blockly/field-dependent-dropdown/webpack/runtime/hasOwnProperty%20shorthand", "webpack://@blockly/field-dependent-dropdown/webpack/runtime/make%20namespace%20object", "webpack://@blockly/field-dependent-dropdown/src/dependent_dropdown_options_change.ts", "webpack://@blockly/field-dependent-dropdown/src/field_dependent_dropdown.ts"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__370__) => {\nreturn ", "module.exports = __WEBPACK_EXTERNAL_MODULE__370__;", "// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n", "// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};", "__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))", "// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview An event representing when a dependent dropdown field changes\n * state.\n */\n\nimport * as Blockly from 'blockly/core';\nimport type {FieldDependentDropdown} from './field_dependent_dropdown';\n\n/**\n * A deep equality comparison between the two provided arrays recursively\n * comparing any child elements that are also arrays.\n *\n * @param a The first array to compare.\n * @param b The second array to compare.\n * @returns Whether the arrays are deeply equivalent.\n */\nfunction arraysAreEquivalent<T>(a: T[], b: T[]): boolean {\n  return (\n    a.length === b.length &&\n    a.every((aElement, index) => {\n      const bElement = b[index];\n      if (Array.isArray(aElement) && Array.isArray(bElement)) {\n        return arraysAreEquivalent(aElement, bElement);\n      }\n      return aElement === bElement;\n    })\n  );\n}\n\n/** The structure of a serialized DependentDropdownOptionsChange. */\nexport interface DependentDropdownOptionsChangeJson\n  extends Blockly.Events.BlockBaseJson {\n  name: string;\n  newValue: string;\n  oldValue: string;\n  oldOptions: Blockly.MenuOption[];\n  newOptions: Blockly.MenuOption[];\n}\n\n/**\n * A change event representing a simultaneous change to a dropdown field's\n * options and value. The old value must be one of the old options, and the new\n * value must be one of the new options. Unlike a normal value change event,\n * it's possible for this event to change the value to something that wasn't\n * previously one of the valid options--in either direction--by also changing\n * the options at the same time.\n */\nexport class DependentDropdownOptionsChange extends Blockly.Events.BlockBase {\n  /** The name to register with Blockly for the type of event. */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static readonly EVENT_TYPE: string = 'dropdown_options_change';\n\n  /** The name of the change event type for registering with Blockly. */\n  readonly type = DependentDropdownOptionsChange.EVENT_TYPE;\n\n  /** The name of the field that changed. */\n  name?: string;\n\n  /** The original value of the field. */\n  oldValue?: string;\n\n  /** The new value of the field. */\n  newValue?: string;\n\n  /** The original available options for the dropdown field. */\n  oldOptions?: Blockly.MenuOption[];\n\n  /** The new available options for the dropdown field. */\n  newOptions?: Blockly.MenuOption[];\n\n  /**\n   * Construct a new DependentDropdownOptionsChange.\n   *\n   * @param block The changed block. Undefined for a blank event.\n   * @param name Name of the field affected.\n   * @param oldValue Previous value of field.\n   * @param newValue New value of field.\n   * @param oldOptions Previous options for the dropdown.\n   * @param newOptions New options for the dropdown.\n   */\n  constructor(\n    block?: Blockly.Block,\n    name?: string,\n    oldValue?: string,\n    newValue?: string,\n    oldOptions?: Blockly.MenuOption[],\n    newOptions?: Blockly.MenuOption[],\n  ) {\n    super(block);\n\n    if (\n      !block ||\n      !name ||\n      !oldValue ||\n      !newValue ||\n      !oldOptions ||\n      !newOptions\n    ) {\n      // Blank event to be populated by fromJson.\n      return;\n    }\n\n    this.name = name;\n    this.oldValue = oldValue;\n    this.newValue = newValue;\n    this.oldOptions = oldOptions;\n    this.newOptions = newOptions;\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): DependentDropdownOptionsChangeJson {\n    const json = super.toJson() as DependentDropdownOptionsChangeJson;\n    if (\n      !this.name ||\n      !this.oldValue ||\n      !this.newValue ||\n      !this.oldOptions ||\n      !this.newOptions\n    ) {\n      throw new Error(\n        'The changed element is undefined. Either pass all needed ' +\n          'parameters to the constructor, or call fromJson.',\n      );\n    }\n    json['name'] = this.name;\n    json['oldValue'] = this.oldValue;\n    json['newValue'] = this.newValue;\n    json['oldOptions'] = this.oldOptions;\n    json['newOptions'] = this.newOptions;\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   *\n   * @param json JSON representation.\n   * @param workspace\n   * @param event\n   * @returns The deserialized event.\n   */\n  static fromJson(\n    json: DependentDropdownOptionsChangeJson,\n    workspace: Blockly.Workspace,\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n    event?: any,\n  ): DependentDropdownOptionsChange {\n    const newEvent = super.fromJson(\n      json,\n      workspace,\n      event,\n    ) as DependentDropdownOptionsChange;\n    newEvent.name = json['name'];\n    newEvent.oldValue = json['oldValue'];\n    newEvent.newValue = json['newValue'];\n    newEvent.oldOptions = json['oldOptions'];\n    newEvent.newOptions = json['newOptions'];\n    return newEvent;\n  }\n\n  /**\n   * Does this event leave all state as it was before?\n   *\n   * @returns False if something changed.\n   */\n  isNull(): boolean {\n    const valuesAreEqual = this.oldValue === this.newValue;\n    const optionsAreEquivalent =\n      this.oldOptions === this.newOptions ||\n      (Array.isArray(this.oldOptions) &&\n        Array.isArray(this.newOptions) &&\n        arraysAreEquivalent(this.oldOptions, this.newOptions));\n    return valuesAreEqual && optionsAreEquivalent;\n  }\n\n  /**\n   * Run a change event.\n   *\n   * @param forward True if run forward, false if run backward (undo).\n   */\n  run(forward: boolean): void {\n    if (\n      !this.blockId ||\n      !this.name ||\n      !this.oldValue ||\n      !this.newValue ||\n      !this.oldOptions ||\n      !this.newOptions\n    ) {\n      console.warn(\"Can't run uninitialized event.\");\n      return;\n    }\n    const workspace = this.getEventWorkspace_();\n    const block = workspace.getBlockById(this.blockId);\n    if (!block) {\n      console.warn(\"Can't change non-existent block: \" + this.blockId);\n      return;\n    }\n\n    const dropdown = block.getField(this.name) as FieldDependentDropdown;\n    if (!dropdown) {\n      console.warn(\"Can't change non-existent dropdown field: \" + this.name);\n      return;\n    }\n\n    const value = forward ? this.newValue : this.oldValue;\n    const options = forward ? this.newOptions : this.oldOptions;\n\n    // Record the options on the dropdown for the option generator to access.\n    dropdown.dependencyData.derivedOptions = options;\n\n    // Re-run the option generator to update the options on the dropdown.\n    dropdown.getOptions(false);\n\n    // Set the value to one of the now-available options.\n    dropdown.setValue(value);\n  }\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  DependentDropdownOptionsChange.EVENT_TYPE,\n  DependentDropdownOptionsChange,\n);\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A Blockly dropdown menu field where the options can change\n * depending on the value of another field.\n */\n\nimport * as Blockly from 'blockly/core';\nimport {DependentDropdownOptionsChange} from './dependent_dropdown_options_change';\n\n/** The type of the mapping from parent value to child options. */\nexport interface ChildOptionMapping {\n  [key: string]: Blockly.MenuOption[];\n}\n\n// This type isn't exported from Blockly so we have to derive it from the API.\ntype FieldConfig = Exclude<\n  ConstructorParameters<typeof Blockly.Field>[2],\n  undefined\n>;\n\n/** fromJson config for a dependent dropdown field. */\nexport interface FieldDependentDropdownFromJsonConfig extends FieldConfig {\n  parentName: string;\n  optionMapping: ChildOptionMapping;\n  defaultOptions?: Blockly.MenuOption[];\n}\n\n/**\n * A structure for managing data needed by the menu generator of a\n * FieldDependentDropdown.\n */\ninterface DependencyData {\n  /**\n   * A reference to the parent field of an associated dependent dropdown. Absent\n   * until the parent field is initialized. This field's value determines the\n   * available options of the child field.\n   */\n  parentField?: Blockly.Field<string>;\n\n  /**\n   * The child field's currently available menu options based on the current\n   * value of the parent field. Absent until the parent field is initialized.\n   */\n  derivedOptions?: Blockly.MenuOption[];\n}\n\n/**\n * A dropdown field that automatically updates its own options based on a\n * mapping from a parent field's value. The parent field must be attached to the\n * block before this child field.\n *\n * When this field is attached to a block, it will find the parent field and\n * attach a validator to the parent field that intercepts changes to its value\n * to update the options on this field. If the new validator is later removed\\\n * or replaced, then this dependent field will no longer function.\n */\nexport class FieldDependentDropdown extends Blockly.FieldDropdown {\n  /**\n   * Contains data used by this dropdown field's menu generator.\n   *\n   * The menu generator cannot refer directly to this FieldDependentDropdown\n   * instance, because it must be created before calling the super constructor\n   * when the \"this\" reference is not yet valid. This helper structure is used\n   * instead.\n   *\n   * This is public so that the DependentDropdownOptionsChangeJson event can\n   * update it while undoing/redoing.\n   */\n  dependencyData: DependencyData;\n\n  /** The name of the field that determines this field's options. */\n  private parentName: string;\n\n  /**\n   * The mapping from the parent field's value to this field's intended\n   * available options. The keys are strings representing the parent's possible\n   * values, and the values are the corresponding options to use in this child\n   * field.\n   */\n  private optionMapping: ChildOptionMapping;\n\n  /**\n   * An optional fallback set of options to use if the parent field's value does\n   * not match any of the keys in optionMapping.\n   */\n  private defaultOptions?: Blockly.MenuOption[];\n\n  /**\n   * Constructs a new FieldDependentDropdown.\n   *\n   * @param parentName The name of the parent field whose value determines this\n   *    field's available options.\n   * @param optionMapping A mapping from the possible values of the parent field\n   *    to the corresponding available options of this child field. The keys are\n   *    the possible values of the parent field, and the values are the\n   *    corresponding arrays of options for this child field.\n   * @param defaultOptions An optional fallback set of options to use if the\n   *    parent field's value does not match any of the keys in optionMapping.\n   * @param validator An optional function that is called to validate changes to\n   *    this field's value.\n   * @param config An optional map of general options used to configure the\n   *    field, such as a tooltip.\n   */\n  constructor(\n    parentName: string,\n    optionMapping: ChildOptionMapping,\n    defaultOptions?: Blockly.MenuOption[],\n    validator?: Blockly.FieldValidator,\n    config?: FieldConfig,\n  ) {\n    // A menu generator needs to be passed to the super constructor, but it\n    // needs to be able to reference data that hasn't been populated yet. We're\n    // not allowed to refer to \"this\" in this constructor before calling\n    // \"super\", so let's make separate structure to hold data relevant to the\n    // menu generator and populate that later.\n    const dependencyData: DependencyData = {};\n\n    // A menu option generator function for this child field that reads the\n    // derived options in the dependency data if available.\n    const menuGenerator: Blockly.MenuGeneratorFunction = () => {\n      // If derivedOptions has been initialized, use that.\n      if (dependencyData.derivedOptions) {\n        return dependencyData.derivedOptions;\n      }\n\n      // Fall back on the options corresponding to the parent field's current\n      // value (which is fine when initializing but may be out of date when\n      // making changes since the parent field's validator function triggers\n      // this function before the parent field's value is updated).\n\n      // If the parent field exists, and its value is a key in the provided\n      // option mapping, use the corresponding options.\n      if (dependencyData.parentField) {\n        const value = dependencyData.parentField.getValue();\n        if (value) {\n          const options = optionMapping[value];\n          if (options) {\n            return options;\n          }\n        }\n      }\n\n      if (defaultOptions) {\n        return defaultOptions;\n      }\n\n      // Fall back on basic default options.\n      return [['', '']];\n    };\n\n    super(menuGenerator, validator, config);\n    this.parentName = parentName;\n    this.optionMapping = optionMapping;\n    this.defaultOptions = defaultOptions;\n    this.dependencyData = dependencyData;\n  }\n\n  /**\n   * Constructs a FieldDependentDropdown from a JSON arg object.\n   *\n   * @param options A JSON object providing \"parentName\" and \"optionMapping\".\n   * @returns The new field instance.\n   */\n  static fromJson(\n    options: FieldDependentDropdownFromJsonConfig,\n  ): FieldDependentDropdown {\n    return new FieldDependentDropdown(\n      options['parentName'],\n      options['optionMapping'],\n      options['defaultOptions'],\n      undefined,\n      options,\n    );\n  }\n\n  /**\n   * Attach this field to a block.\n   *\n   * @param block The block containing this field.\n   */\n  setSourceBlock(block: Blockly.Block) {\n    super.setSourceBlock(block);\n\n    const parentField: Blockly.Field<string> | null = block.getField(\n      this.parentName,\n    );\n\n    if (!parentField) {\n      throw new Error(\n        'Could not find a parent field with the name ' +\n          this.parentName +\n          ' for the dependent dropdown.',\n      );\n    }\n\n    this.dependencyData.parentField = parentField;\n\n    const oldValidator = parentField.getValidator();\n\n    // A validator function for the parent field that has the side effect of\n    // updating the options of this child dropdown field based on the new value\n    // of the parent field whenever it changes. The validator function is a good\n    // place to do this because it is called immediately while deserializing\n    // workspaces before the following fields are deserialized, so when the\n    // child value is deserialized the appropriate options will already be\n    // available. If the parent already had a validator function, it will be\n    // composed with this one and the new value returned from it will be the\n    // basis for determining the new available options.\n    parentField.setValidator((newValue) => {\n      if (oldValidator) {\n        const validatedValue = oldValidator(newValue);\n        // If a validator returns null, that means the new value is invalid and\n        // the change should be canceled.\n        if (validatedValue === null) {\n          return null;\n        }\n        // If a validator returns undefined, that means no change. Otherwise,\n        // use the returned value as the new value.\n        if (validatedValue !== undefined) {\n          newValue = validatedValue;\n        }\n      }\n      this.updateOptionsBasedOnNewValue(newValue);\n      return newValue;\n    });\n    this.updateOptionsBasedOnNewValue(parentField.getValue() ?? undefined);\n  }\n\n  /**\n   * Updates the options of this child dropdown field based on the new value of\n   * the parent field.\n   *\n   * @param newValue The newly assigned value.\n   */\n  private updateOptionsBasedOnNewValue(newValue: string | undefined): void {\n    if (newValue == undefined) {\n      return;\n    }\n\n    const block = this.getSourceBlock();\n    if (!block) {\n      throw new Error(\n        'Could not validate a field that is not attached to a block: ' +\n          this.name,\n      );\n    }\n\n    const oldChildValue = this.getValue();\n    const oldChildOptions = this.getOptions(false);\n    let newChildOptions = this.optionMapping[newValue];\n    if (!newChildOptions) {\n      if (this.defaultOptions) {\n        newChildOptions = this.defaultOptions;\n      } else {\n        console.warn(\n          'Could not find child options for the parent value: ' + newValue,\n        );\n        return;\n      }\n    }\n\n    // If the child field's value is still available in the new options, keep\n    // it, otherwise change the field's value to the first available option.\n    const newOptionsIncludeOldValue =\n      newChildOptions.find((option) => option[1] == oldChildValue) != undefined;\n    const newChildValue = newOptionsIncludeOldValue\n      ? oldChildValue\n      : newChildOptions[0][1];\n\n    // Record the options so that the option generator can access them.\n    this.dependencyData.derivedOptions = newChildOptions;\n\n    // Re-run the option generator to update the options on the dropdown.\n    this.getOptions(false);\n\n    // Update this child field's value without broadcasting the normal change\n    // event. The normal value change event can't be properly undone, because\n    // the old value may not be one of the currently valid options, so a custom\n    // change event will be broadcast instead that handles swapping the options\n    // and the value at the same time.\n    Blockly.Events.disable();\n    this.setValue(newChildValue);\n    Blockly.Events.enable();\n\n    if (Blockly.Events.getRecordUndo()) {\n      if (!Blockly.Events.getGroup()) {\n        // Start a change group before the change event. The change event for\n        // the parent field value will be created after this function returns\n        // and will be part of the same group.\n        Blockly.Events.setGroup(true);\n        // Clear the change group later, after all related events have been\n        // broadcast, but before the user performs any more actions.\n        setTimeout(() => Blockly.Events.setGroup(false));\n      }\n\n      // Record that the child field's options and value have changed.\n      Blockly.Events.fire(\n        new DependentDropdownOptionsChange(\n          block,\n          this.name,\n          oldChildValue ?? undefined,\n          newChildValue ?? undefined,\n          oldChildOptions,\n          newChildOptions,\n        ),\n      );\n    }\n  }\n}\n\nBlockly.fieldRegistry.register(\n  'field_dependent_dropdown',\n  FieldDependentDropdown,\n);\n"],
  "mappings": "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",
  "names": ["root", "factory", "exports", "module", "require", "define", "amd", "a", "i", "this", "__WEBPACK_EXTERNAL_MODULE__370__", "__webpack_module_cache__", "__webpack_require__", "moduleId", "cachedModule", "__webpack_modules__", "d", "definition", "key", "o", "Object", "defineProperty", "enumerable", "get", "obj", "prop", "prototype", "hasOwnProperty", "call", "r", "Symbol", "toStringTag", "value", "arraysAreEquivalent", "b", "length", "every", "aElement", "index", "bElement", "Array", "isArray", "DependentDropdownOptionsChange", "BlockBase", "block", "name", "oldValue", "newValue", "oldOptions", "newOptions", "super", "type", "EVENT_TYPE", "toJson", "json", "Error", "workspace", "event", "newEvent", "fromJson", "isNull", "valuesAreEqual", "optionsAreEquivalent", "forward", "blockId", "console", "warn", "getEventWorkspace_", "getBlockById", "dropdown", "getField", "options", "dependencyData", "derivedOptions", "getOptions", "setValue", "register", "Type", "EVENT", "FieldDependentDropdown", "parentName", "optionMapping", "defaultOptions", "validator", "config", "parentField", "getValue", "setSourceBlock", "oldValidator", "getValidator", "setValidator", "validatedValue", "updateOptionsBasedOnNewValue", "t", "undefined", "getSourceBlock", "oldChildValue", "oldChildOptions", "newChildOptions", "newChildValue", "find", "option", "disable", "enable", "getRecordUndo", "getGroup", "setGroup", "setTimeout", "fire"]
}
