import {
  require_blockly_compressed
} from "./chunk-37NJYYKB.js";
import {
  __commonJS
} from "./chunk-PLDDJCW6.js";

// node_modules/@blockly/field-angle/dist/index.js
var require_dist = __commonJS({
  "node_modules/@blockly/field-angle/dist/index.js"(exports, module) {
    !(function(t, i) {
      if ("object" == typeof exports && "object" == typeof module) module.exports = i(require_blockly_compressed());
      else if ("function" == typeof define && define.amd) define(["blockly/core"], i);
      else {
        var e = "object" == typeof exports ? i(require_blockly_compressed()) : i(t.Blockly);
        for (var s in e) ("object" == typeof exports ? exports : t)[s] = e[s];
      }
    })(exports, (t) => (() => {
      "use strict";
      var i = { 370: (i2) => {
        i2.exports = t;
      } }, e = {};
      function s(t2) {
        var o2 = e[t2];
        if (void 0 !== o2) return o2.exports;
        var n2 = e[t2] = { exports: {} };
        return i[t2](n2, n2.exports, s), n2.exports;
      }
      s.d = (t2, i2) => {
        for (var e2 in i2) s.o(i2, e2) && !s.o(t2, e2) && Object.defineProperty(t2, e2, { enumerable: true, get: i2[e2] });
      }, s.o = (t2, i2) => Object.prototype.hasOwnProperty.call(t2, i2), s.r = (t2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      };
      var o = {};
      s.r(o), s.d(o, { FieldAngle: () => r, Mode: () => n, registerFieldAngle: () => a });
      var n, l = s(370);
      class r extends l.FieldNumber {
        constructor(t2, i2, e2) {
          super(l.Field.SKIP_SETUP), this.clockwise = false, this.offset = 0, this.displayMin = 0, this.displayMax = 360, this.minorTick = 15, this.majorTick = 45, this.symbol = "Â°", this.boundEvents = [], this.line = null, this.gauge = null, this.symbolElement = null, t2 !== l.Field.SKIP_SETUP && (e2 ? (this.configure_(e2), void 0 !== e2.min && null !== e2.min || this.setMin(r.DEFAULT_MIN), void 0 !== e2.max && null !== e2.max || this.setMax(r.DEFAULT_MAX), void 0 !== e2.precision && null !== e2.precision || this.setPrecision(r.DEFAULT_PRECISION)) : (this.setMin(r.DEFAULT_MIN), this.setMax(r.DEFAULT_MAX), this.setPrecision(r.DEFAULT_PRECISION)), this.setValue(t2), i2 && this.setValidator(i2));
        }
        configure_(t2) {
          switch (super.configure_(t2), t2.mode) {
            case n.COMPASS:
              this.clockwise = true, this.offset = 90;
              break;
            case n.PROTRACTOR:
              this.clockwise = false, this.offset = 0;
          }
          if (void 0 !== t2.clockwise && (this.clockwise = t2.clockwise), void 0 !== t2.offset && (this.offset = t2.offset), void 0 !== t2.displayMin && (this.displayMin = t2.displayMin), void 0 !== t2.displayMax && (this.displayMax = t2.displayMax), void 0 !== t2.minorTick && (this.minorTick = t2.minorTick), void 0 !== t2.majorTick && (this.majorTick = t2.majorTick), void 0 !== t2.symbol && (this.symbol = t2.symbol), this.displayMin >= this.displayMax) throw Error("Display min must be larger than display max");
          if (this.minorTick < 0 || this.majorTick < 0) throw Error("Ticks cannot be negative");
        }
        initView() {
          super.initView(), this.symbol && (this.symbolElement = l.utils.dom.createSvgElement(l.utils.Svg.TSPAN, {}), this.symbolElement.appendChild(document.createTextNode(this.symbol)), this.getTextElement().appendChild(this.symbolElement));
        }
        render_() {
          super.render_(), this.updateGraph();
        }
        showEditor_(t2) {
          const i2 = l.utils.userAgent.MOBILE || l.utils.userAgent.ANDROID || l.utils.userAgent.IPAD;
          super.showEditor_(t2, i2, false);
          const e2 = this.dropdownCreate();
          l.DropDownDiv.getContentDiv().appendChild(e2);
          const s2 = this.getSourceBlock();
          s2 instanceof l.BlockSvg && l.DropDownDiv.setColour(s2.style.colourPrimary, s2.style.colourTertiary), l.DropDownDiv.showPositionedByField(this, this.dropdownDispose.bind(this)), this.updateGraph();
        }
        dropdownCreate() {
          const t2 = l.utils.dom.createSvgElement(l.utils.Svg.SVG, { xmlns: l.utils.dom.SVG_NS, "xmlns:html": l.utils.dom.HTML_NS, "xmlns:xlink": l.utils.dom.XLINK_NS, version: "1.1", height: 2 * r.HALF + "px", width: 2 * r.HALF + "px" });
          t2.style.touchAction = "none";
          const i2 = l.utils.dom.createSvgElement(l.utils.Svg.CIRCLE, { cx: r.HALF, cy: r.HALF, r: r.RADIUS, class: "blocklyAngleCircle" }, t2);
          this.gauge = l.utils.dom.createSvgElement(l.utils.Svg.PATH, { class: "blocklyAngleGauge" }, t2), this.line = l.utils.dom.createSvgElement(l.utils.Svg.LINE, { x1: r.HALF, y1: r.HALF, class: "blocklyAngleLine" }, t2);
          const e2 = l.utils.math.toDegrees(this.fieldAngleToRadians(this.min_)), s2 = l.utils.math.toDegrees(this.fieldAngleToRadians(this.max_)), o2 = (i3, o3) => {
            let n3 = Math.ceil(e2 / i3) * i3, a3 = Math.floor(s2 / i3) * i3;
            this.clockwise ? n3 < a3 && (n3 += 360) : n3 > a3 && (a3 += 360), a3 === n3 && (a3 += 360), n3 > a3 && ([n3, a3] = [a3, n3]);
            for (let e3 = n3; e3 <= a3; e3 += i3) l.utils.dom.createSvgElement(l.utils.Svg.LINE, { x1: r.HALF + r.RADIUS, y1: r.HALF, x2: r.HALF + r.RADIUS - o3, y2: r.HALF, class: "blocklyAngleMarks", transform: "rotate(" + -e3 + "," + r.HALF + "," + r.HALF + ")" }, t2);
          }, n2 = this.displayMax - this.displayMin, a2 = 360 / n2 * this.minorTick;
          a2 && o2(a2, 5);
          const h = 360 / n2 * this.majorTick;
          return h && o2(h, 10), this.boundEvents.push(l.browserEvents.conditionalBind(t2, "click", this, this.hide)), this.boundEvents.push(l.browserEvents.conditionalBind(i2, "pointerdown", this, this.onMouseMove_, true)), this.boundEvents.push(l.browserEvents.conditionalBind(i2, "pointermove", this, this.onMouseMove_, true)), t2;
        }
        dropdownDispose() {
          for (const t2 of this.boundEvents) l.browserEvents.unbind(t2);
          this.boundEvents.length = 0, this.gauge = null, this.line = null;
        }
        hide() {
          l.DropDownDiv.hideIfOwner(this), l.WidgetDiv.hide();
        }
        onMouseMove_(t2) {
          var i2, e2;
          const s2 = null === (e2 = null === (i2 = this.gauge) || void 0 === i2 ? void 0 : i2.ownerSVGElement) || void 0 === e2 ? void 0 : e2.getBoundingClientRect();
          if (!s2) return;
          const o2 = t2.clientX - s2.left - r.HALF, n2 = t2.clientY - s2.top - r.HALF;
          let l2 = Math.atan2(-n2, o2);
          isNaN(l2) || (l2 = this.radiansToFieldAngle(l2), this.displayMouseOrKeyboardValue(l2));
        }
        radiansToFieldAngle(t2) {
          return t2 /= 2 * Math.PI, t2 -= this.offset / 360, this.clockwise && (t2 *= -1), (t2 %= 1) < 0 && (t2 += 1), (t2 *= this.displayMax - this.displayMin) + this.displayMin;
        }
        fieldAngleToRadians(t2) {
          return t2 -= this.displayMin, t2 /= this.displayMax - this.displayMin, this.clockwise && (t2 *= -1), t2 += this.offset / 360, (t2 %= 1) > 0.5 && (t2 -= 1), t2 < -0.5 && (t2 += 1), t2 * (2 * Math.PI);
        }
        displayMouseOrKeyboardValue(t2) {
          const i2 = this.doClassValidation_(t2);
          if (null !== i2 && i2 !== this.value_) {
            const t3 = this.value_;
            this.setEditorValue_(i2, false), this.sourceBlock_ && l.Events.isEnabled() && this.value_ !== t3 && l.Events.fire(new (l.Events.get(l.Events.BLOCK_FIELD_INTERMEDIATE_CHANGE))(this.sourceBlock_, this.name || null, t3, this.value_));
          }
        }
        updateGraph() {
          if (!this.gauge || !this.line) return;
          let t2 = Number(this.getText());
          if (isNaN(t2)) return;
          t2 = this.fieldAngleToRadians(t2);
          let i2 = `M ${r.HALF},${r.HALF}`, e2 = r.HALF, s2 = r.HALF;
          if (!isNaN(t2)) {
            const o2 = l.utils.math.toRadians(this.offset), n2 = Math.cos(o2) * r.RADIUS, a2 = Math.sin(o2) * -r.RADIUS;
            e2 += Math.cos(t2) * r.RADIUS, s2 -= Math.sin(t2) * r.RADIUS;
            const h = Number(this.clockwise);
            let d = Math.abs(Math.floor((t2 - o2) / Math.PI) % 2);
            h && (d = 1 - d), i2 += ` l ${n2},${a2} A ${r.RADIUS},${r.RADIUS} 0 ${d} ${h} ${e2},${s2} z`;
          }
          this.gauge.setAttribute("d", i2), this.line.setAttribute("x2", `${e2}`), this.line.setAttribute("y2", `${s2}`);
        }
        onHtmlInputKeyDown_(t2) {
          super.onHtmlInputKeyDown_(t2);
          const i2 = this.getSourceBlock();
          if (!i2) throw new Error("The field has not yet been attached to its input. Call appendField to attach it.");
          let e2 = 0;
          switch (t2.key) {
            case "ArrowLeft":
              e2 = i2.RTL ? 1 : -1;
              break;
            case "ArrowRight":
              e2 = i2.RTL ? -1 : 1;
              break;
            case "ArrowDown":
              e2 = -1;
              break;
            case "ArrowUp":
              e2 = 1;
          }
          if (e2) {
            const i3 = this.getValue();
            this.displayMouseOrKeyboardValue(i3 + e2 * this.precision_), t2.preventDefault(), t2.stopPropagation();
          }
        }
        doClassValidation_(t2) {
          if (null === t2) return null;
          let i2 = Number(t2);
          if (isNaN(i2) || !isFinite(i2)) return null;
          i2 = this.wrapValue(i2), this.precision_ && (i2 = Math.round(i2 / this.precision_) * this.precision_), i2 = Number(i2.toFixed(10));
          const e2 = this.displayMax - this.displayMin, s2 = this.max_ - this.min_;
          if (i2 < this.min_) {
            const t3 = this.min_ - i2;
            i2 = t3 < e2 - t3 - s2 ? this.min_ : this.max_;
          }
          if (i2 > this.max_) {
            const t3 = i2 - this.max_;
            i2 = e2 - t3 - s2 < t3 ? this.min_ : this.max_;
          }
          return i2;
        }
        wrapValue(t2) {
          const i2 = this.displayMax - this.displayMin;
          for (t2 %= i2; t2 < this.displayMin; ) t2 += i2;
          for (; t2 >= this.displayMax; ) t2 -= i2;
          return t2;
        }
        static fromJson(t2) {
          return new this(t2.value, void 0, t2);
        }
      }
      function a() {
        l.fieldRegistry.register("field_angle", r);
      }
      return r.HALF = 50, r.RADIUS = r.HALF - 1, r.DEFAULT_PRECISION = 15, r.DEFAULT_MIN = 0, r.DEFAULT_MAX = 360, r.prototype.DEFAULT_VALUE = 0, l.Css.register("\n.blocklyAngleCircle {\n  stroke: #444;\n  stroke-width: 1;\n  fill: #ddd;\n  fill-opacity: 0.8;\n}\n\n.blocklyAngleMarks {\n  stroke: #444;\n  stroke-width: 1;\n}\n\n.blocklyAngleGauge {\n  fill: #f88;\n  fill-opacity: 0.8;\n  pointer-events: none;\n}\n\n.blocklyAngleLine {\n  stroke: #f00;\n  stroke-width: 2;\n  stroke-linecap: round;\n  pointer-events: none;\n}\n"), (function(t2) {
        t2.COMPASS = "compass", t2.PROTRACTOR = "protractor";
      })(n || (n = {})), o;
    })());
  }
});
export default require_dist();
/*! Bundled license information:

@blockly/field-angle/dist/index.js:
  (*! For license information please see index.js.LICENSE.txt *)
*/
//# sourceMappingURL=@blockly_field-angle.js.map
