// src/renderer/blockly/object-detection-generators.js
'use strict';

micropythonGenerator.forBlock['object_detection_enable'] = function(block) {
    return '# UI: Object detection enabled/disabled in browser.\n';
};

micropythonGenerator.forBlock['object_detection_is_object_detected'] = function(block) {
    const objectClass = block.getFieldValue('OBJECT_CLASS');
    // Ensure the main AI data processor is defined
    micropythonGenerator.functionNames_['process_face_landmark_data'] = micropythonGenerator.functionNames_['process_face_landmark_data'] || '';

    const code = `any(obj.get('label') == '${objectClass}' for obj in ai_data.get('objects', []))`;
    return [code, micropythonGenerator.ORDER_FUNCTION_CALL];
};

micropythonGenerator.forBlock['object_detection_for_each'] = function(block) {
    const objectClass = block.getFieldValue('OBJECT_CLASS');
    const statements_do = micropythonGenerator.statementToCode(block, 'DO') || micropythonGenerator.INDENT + 'pass';
    // Define a variable name for the loop that is unlikely to conflict
    const loopVar = micropythonGenerator.nameDB_.getDistinctName('detected_object', Blockly.Names.NameType.VARIABLE);
    
    // Ensure the main AI data processor is defined
    micropythonGenerator.functionNames_['process_face_landmark_data'] = micropythonGenerator.functionNames_['process_face_landmark_data'] || '';

    const code = `
for ${loopVar} in ai_data.get('objects', []):
    if ${loopVar}.get('label') == '${objectClass}':
${statements_do}
`;
    return code;
};

micropythonGenerator.forBlock['object_detection_get_property'] = function(block) {
    const property = block.getFieldValue('PROPERTY');
    // This block assumes it is inside a loop generated by 'object_detection_for_each'.
    // We need to find the variable name from the parent loop block.
    let loopVar = 'current_object'; // Default fallback name
    let parentBlock = block.getParent();
    while (parentBlock) {
        if (parentBlock.type === 'object_detection_for_each') {
            // This is a bit of a hack, as we can't easily get the var name from the generator context.
            // We rely on the fact that the generator for the parent block will define a known variable.
            // For robustness, we'll use a predictable name.
            const generator = micropythonGenerator.forBlock[parentBlock.type];
            // Re-generating the parent's code to find the var name is too complex.
            // So we will rely on the generator for 'object_detection_for_each' using a consistent variable name.
            // Let's find a variable defined within the scope.
            const variableName = micropythonGenerator.nameDB_.getDistinctName('detected_object', Blockly.Names.NameType.VARIABLE);
            loopVar = variableName; // This is imperfect but the best we can do here.
            break;
        }
        parentBlock = parentBlock.getParent();
    }
    
    // The most robust way is to just assume the variable name. The generator for the loop MUST use this name.
    const code = `detected_object.get('${property}', 0)`;
    return [code, micropythonGenerator.ORDER_MEMBER];
};