{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/toolbox-search/webpack/universalModuleDefinition","webpack://@blockly/toolbox-search/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/toolbox-search/webpack/bootstrap","webpack://@blockly/toolbox-search/./src/block_searcher.ts","webpack://@blockly/toolbox-search/./src/toolbox_search.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__370__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__370__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * A class that provides methods for indexing and searching blocks.\n */\nexport class BlockSearcher {\n  private trigramsToBlocks = new Map<\n    string,\n    Set<Blockly.utils.toolbox.BlockInfo>\n  >();\n\n  /**\n   * Populates the cached map of trigrams to the blocks they correspond to.\n   *\n   * This method must be called before blockTypesMatching(). Behind the\n   * scenes, it creates a workspace, loads the specified block types on it,\n   * indexes their types and human-readable text, and cleans up after\n   * itself.\n   *\n   * @param blockInfos A list of blocks to index.\n   */\n  indexBlocks(blockInfos: Blockly.utils.toolbox.BlockInfo[]) {\n    const blockCreationWorkspace = new Blockly.Workspace();\n    blockInfos.forEach((blockInfo) => {\n      const type = blockInfo.type;\n      if (!type || type === '') return;\n      const block = blockCreationWorkspace.newBlock(type);\n      this.indexBlockText(type.replaceAll('_', ' '), blockInfo);\n      block.inputList.forEach((input) => {\n        input.fieldRow.forEach((field) => {\n          this.indexDropdownOption(field, blockInfo);\n          this.indexBlockText(field.getText(), blockInfo);\n        });\n      });\n    });\n  }\n\n  /**\n   * Check if the field is a dropdown, and index every text in the option\n   *\n   * @param field We need to check the type of field\n   * @param block The block to associate the trigrams with.\n   */\n  private indexDropdownOption(\n    field: Blockly.Field,\n    block: Blockly.utils.toolbox.BlockInfo,\n  ) {\n    if (field instanceof Blockly.FieldDropdown) {\n      field.getOptions(true).forEach((option) => {\n        if (typeof option[0] === 'string') {\n          this.indexBlockText(option[0], block);\n        } else if ('alt' in option[0]) {\n          this.indexBlockText(option[0].alt, block);\n        }\n      });\n    }\n  }\n\n  /**\n   * Filters the available blocks based on the current query string.\n   *\n   * @param query The text to use to match blocks against.\n   * @returns A list of blocks matching the query.\n   */\n  blockTypesMatching(query: string): Blockly.utils.toolbox.BlockInfo[] {\n    return [\n      ...this.generateTrigrams(query)\n        .map((trigram) => {\n          return (\n            this.trigramsToBlocks.get(trigram) ??\n            new Set<Blockly.utils.toolbox.BlockInfo>()\n          );\n        })\n        .reduce((matches, current) => {\n          return this.getIntersection(matches, current);\n        })\n        .values(),\n    ];\n  }\n\n  /**\n   * Generates trigrams for the given text and associates them with the given\n   * block.\n   *\n   * @param text The text to generate trigrams of.\n   * @param block The block to associate the trigrams with.\n   */\n  private indexBlockText(text: string, block: Blockly.utils.toolbox.BlockInfo) {\n    this.generateTrigrams(text).forEach((trigram) => {\n      const blockSet =\n        this.trigramsToBlocks.get(trigram) ??\n        new Set<Blockly.utils.toolbox.BlockInfo>();\n      blockSet.add(block);\n      this.trigramsToBlocks.set(trigram, blockSet);\n    });\n  }\n\n  /**\n   * Generates a list of trigrams for a given string.\n   *\n   * @param input The string to generate trigrams of.\n   * @returns A list of trigrams of the given string.\n   */\n  private generateTrigrams(input: string): string[] {\n    const normalizedInput = input.toLowerCase();\n    if (!normalizedInput) return [];\n    if (normalizedInput.length <= 3) return [normalizedInput];\n\n    const trigrams: string[] = [];\n    for (let start = 0; start < normalizedInput.length - 3; start++) {\n      trigrams.push(normalizedInput.substring(start, start + 3));\n    }\n\n    return trigrams;\n  }\n\n  /**\n   * Returns the intersection of two sets.\n   *\n   * @param a The first set.\n   * @param b The second set.\n   * @returns The intersection of the two sets.\n   */\n  private getIntersection(\n    a: Set<Blockly.utils.toolbox.BlockInfo>,\n    b: Set<Blockly.utils.toolbox.BlockInfo>,\n  ): Set<Blockly.utils.toolbox.BlockInfo> {\n    return new Set([...a].filter((value) => b.has(value)));\n  }\n}\n","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * A toolbox category that provides a search field and displays matching blocks\n * in its flyout.\n */\nimport * as Blockly from 'blockly/core';\nimport {BlockSearcher} from './block_searcher';\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * A toolbox category that provides a search field and displays matching blocks\n * in its flyout.\n */\nexport class ToolboxSearchCategory extends Blockly.ToolboxCategory {\n  private static readonly START_SEARCH_SHORTCUT = 'startSearch';\n  static readonly SEARCH_CATEGORY_KIND = 'search';\n  private readonly SEARCH_INPUT_ID = 'toolbox-search-input';\n  private searchField?: HTMLInputElement;\n  private blockSearcher = new BlockSearcher();\n\n  /**\n   * Initializes a ToolboxSearchCategory.\n   *\n   * @param categoryDef The information needed to create a category in the\n   *     toolbox.\n   * @param parentToolbox The parent toolbox for the category.\n   * @param opt_parent The parent category or null if the category does not have\n   *     a parent.\n   */\n  constructor(\n    categoryDef: Blockly.utils.toolbox.CategoryInfo,\n    parentToolbox: Blockly.IToolbox,\n    opt_parent?: Blockly.ICollapsibleToolboxItem,\n  ) {\n    super(categoryDef, parentToolbox, opt_parent);\n    this.initBlockSearcher();\n    this.registerShortcut();\n  }\n\n  /**\n   * Initializes the search field toolbox category.\n   *\n   * @returns The <div> that will be displayed in the toolbox.\n   */\n  protected override createDom_(): HTMLDivElement {\n    const dom = super.createDom_();\n    this.searchField = document.createElement('input');\n    this.searchField.id = this.SEARCH_INPUT_ID;\n    this.searchField.type = 'search';\n    this.searchField.placeholder = 'Search';\n    this.workspace_.RTL\n      ? (this.searchField.style.marginRight = '8px')\n      : (this.searchField.style.marginLeft = '8px');\n    this.searchField.addEventListener('keyup', (event) => {\n      if (event.key === 'Escape') {\n        this.parentToolbox_.clearSelection();\n        return;\n      }\n\n      this.matchBlocks();\n    });\n    this.rowContents_?.replaceChildren(this.searchField);\n    return dom;\n  }\n\n  /** The ID of the toolbox item must match the ID of the focusable node. */\n  override getId(): string {\n    return this.SEARCH_INPUT_ID;\n  }\n\n  /**\n   * Returns the numerical position of this category in its parent toolbox.\n   *\n   * @returns The zero-based index of this category in its parent toolbox, or -1\n   *    if it cannot be determined, e.g. if this is a nested category.\n   */\n  private getPosition() {\n    const categories = this.workspace_.options.languageTree?.contents || [];\n    for (let i = 0; i < categories.length; i++) {\n      if (categories[i].kind === ToolboxSearchCategory.SEARCH_CATEGORY_KIND) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Registers a shortcut for displaying the toolbox search category.\n   */\n  private registerShortcut() {\n    const shortcut = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.B,\n      [Blockly.utils.KeyCodes.CTRL],\n    );\n    Blockly.ShortcutRegistry.registry.register({\n      name: ToolboxSearchCategory.START_SEARCH_SHORTCUT,\n      callback: () => {\n        const position = this.getPosition();\n        if (position < 0) return false;\n        Blockly.getFocusManager().focusNode(this);\n        return true;\n      },\n      keyCodes: [shortcut],\n    });\n  }\n\n  /**\n   * Returns a list of block types that are present in the toolbox definition.\n   *\n   * @param schema A toolbox item definition.\n   * @param allBlocks The set of all available blocks that have been encountered\n   *     so far.\n   */\n  private getAvailableBlocks(\n    schema: Blockly.utils.toolbox.ToolboxItemInfo,\n    allBlocks: Set<Blockly.utils.toolbox.BlockInfo>,\n  ) {\n    if ('contents' in schema) {\n      schema.contents.forEach((contents) => {\n        this.getAvailableBlocks(contents, allBlocks);\n      });\n    } else if (schema.kind.toLowerCase() === 'block') {\n      if ('type' in schema && schema.type) {\n        allBlocks.add(schema);\n      }\n    }\n  }\n\n  /**\n   * Builds the BlockSearcher index based on the available blocks.\n   */\n  private initBlockSearcher() {\n    const availableBlocks = new Set<Blockly.utils.toolbox.BlockInfo>();\n    this.workspace_.options.languageTree?.contents?.forEach((item) =>\n      this.getAvailableBlocks(item, availableBlocks),\n    );\n    this.blockSearcher.indexBlocks([...availableBlocks]);\n  }\n\n  /** See IFocusableNode.getFocusableElement. */\n  override getFocusableElement(): HTMLElement | SVGElement {\n    if (!this.searchField) {\n      throw Error('This field currently has no representative DOM element.');\n    }\n    return this.searchField;\n  }\n\n  /** See IFocusableNode.onNodeFocus. */\n  override onNodeFocus(): void {\n    this.matchBlocks();\n  }\n\n  /** See IFocusableNode.onNodeBlur. */\n  override onNodeBlur(): void {\n    if (!this.searchField) return;\n    this.searchField.value = '';\n  }\n\n  /**\n   * Filters the available blocks based on the current query string.\n   */\n  private matchBlocks() {\n    const query = this.searchField?.value || '';\n\n    this.flyoutItems_ = query\n      ? this.blockSearcher.blockTypesMatching(query)\n      : [];\n\n    if (!this.flyoutItems_.length) {\n      this.flyoutItems_.push({\n        kind: 'label',\n        text:\n          query.length < 3\n            ? 'Type to search for blocks'\n            : 'No matching blocks found',\n      });\n    }\n    this.parentToolbox_.refreshSelection();\n  }\n\n  /**\n   * Disposes of this category.\n   */\n  override dispose() {\n    super.dispose();\n    Blockly.ShortcutRegistry.registry.unregister(\n      ToolboxSearchCategory.START_SEARCH_SHORTCUT,\n    );\n  }\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.TOOLBOX_ITEM,\n  ToolboxSearchCategory.SEARCH_CATEGORY_KIND,\n  ToolboxSearchCategory,\n);\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__370__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","BlockSearcher","trigramsToBlocks","Map","indexBlocks","blockInfos","blockCreationWorkspace","forEach","blockInfo","type","block","newBlock","indexBlockText","replaceAll","inputList","input","fieldRow","field","indexDropdownOption","getText","getOptions","option","alt","blockTypesMatching","query","generateTrigrams","map","trigram","get","Set","reduce","matches","current","getIntersection","values","text","blockSet","add","set","normalizedInput","toLowerCase","length","trigrams","start","push","substring","b","filter","value","has","ToolboxSearchCategory","constructor","categoryDef","parentToolbox","opt_parent","super","SEARCH_INPUT_ID","blockSearcher","initBlockSearcher","registerShortcut","createDom_","dom","searchField","document","createElement","id","placeholder","workspace_","RTL","style","marginRight","marginLeft","addEventListener","event","key","matchBlocks","parentToolbox_","clearSelection","rowContents_","replaceChildren","getId","getPosition","categories","options","languageTree","contents","kind","SEARCH_CATEGORY_KIND","shortcut","registry","createSerializedKey","KeyCodes","B","CTRL","register","name","START_SEARCH_SHORTCUT","callback","focusNode","keyCodes","getAvailableBlocks","schema","allBlocks","availableBlocks","item","getFocusableElement","Error","onNodeFocus","onNodeBlur","flyoutItems_","refreshSelection","dispose","unregister","Type","TOOLBOX_ITEM"],"sourceRoot":""}