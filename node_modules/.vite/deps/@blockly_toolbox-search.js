import {
  require_blockly_compressed
} from "./chunk-37NJYYKB.js";
import {
  __commonJS
} from "./chunk-PLDDJCW6.js";

// node_modules/@blockly/toolbox-search/dist/index.js
var require_dist = __commonJS({
  "node_modules/@blockly/toolbox-search/dist/index.js"(exports, module) {
    !(function(e, t) {
      if ("object" == typeof exports && "object" == typeof module) module.exports = t(require_blockly_compressed());
      else if ("function" == typeof define && define.amd) define(["blockly/core"], t);
      else {
        var r = "object" == typeof exports ? t(require_blockly_compressed()) : t(e.Blockly);
        for (var s in r) ("object" == typeof exports ? exports : e)[s] = r[s];
      }
    })(exports, (e) => (() => {
      "use strict";
      var t = { 370: (t2) => {
        t2.exports = e;
      } }, r = {}, s = (function e2(s2) {
        var o2 = r[s2];
        if (void 0 !== o2) return o2.exports;
        var i2 = r[s2] = { exports: {} };
        return t[s2](i2, i2.exports, e2), i2.exports;
      })(370);
      class o {
        constructor() {
          this.trigramsToBlocks = /* @__PURE__ */ new Map();
        }
        indexBlocks(e2) {
          const t2 = new s.Workspace();
          e2.forEach((e3) => {
            const r2 = e3.type;
            if (!r2 || "" === r2) return;
            const s2 = t2.newBlock(r2);
            this.indexBlockText(r2.replaceAll("_", " "), e3), s2.inputList.forEach((t3) => {
              t3.fieldRow.forEach((t4) => {
                this.indexDropdownOption(t4, e3), this.indexBlockText(t4.getText(), e3);
              });
            });
          });
        }
        indexDropdownOption(e2, t2) {
          e2 instanceof s.FieldDropdown && e2.getOptions(true).forEach((e3) => {
            "string" == typeof e3[0] ? this.indexBlockText(e3[0], t2) : "alt" in e3[0] && this.indexBlockText(e3[0].alt, t2);
          });
        }
        blockTypesMatching(e2) {
          return [...this.generateTrigrams(e2).map((e3) => {
            var t2;
            return null !== (t2 = this.trigramsToBlocks.get(e3)) && void 0 !== t2 ? t2 : /* @__PURE__ */ new Set();
          }).reduce((e3, t2) => this.getIntersection(e3, t2)).values()];
        }
        indexBlockText(e2, t2) {
          this.generateTrigrams(e2).forEach((e3) => {
            var r2;
            const s2 = null !== (r2 = this.trigramsToBlocks.get(e3)) && void 0 !== r2 ? r2 : /* @__PURE__ */ new Set();
            s2.add(t2), this.trigramsToBlocks.set(e3, s2);
          });
        }
        generateTrigrams(e2) {
          const t2 = e2.toLowerCase();
          if (!t2) return [];
          if (t2.length <= 3) return [t2];
          const r2 = [];
          for (let e3 = 0; e3 < t2.length - 3; e3++) r2.push(t2.substring(e3, e3 + 3));
          return r2;
        }
        getIntersection(e2, t2) {
          return new Set([...e2].filter((e3) => t2.has(e3)));
        }
      }
      class i extends s.ToolboxCategory {
        constructor(e2, t2, r2) {
          super(e2, t2, r2), this.SEARCH_INPUT_ID = "toolbox-search-input", this.blockSearcher = new o(), this.initBlockSearcher(), this.registerShortcut();
        }
        createDom_() {
          var e2;
          const t2 = super.createDom_();
          return this.searchField = document.createElement("input"), this.searchField.id = this.SEARCH_INPUT_ID, this.searchField.type = "search", this.searchField.placeholder = "Search", this.workspace_.RTL ? this.searchField.style.marginRight = "8px" : this.searchField.style.marginLeft = "8px", this.searchField.addEventListener("keyup", (e3) => {
            "Escape" !== e3.key ? this.matchBlocks() : this.parentToolbox_.clearSelection();
          }), null === (e2 = this.rowContents_) || void 0 === e2 || e2.replaceChildren(this.searchField), t2;
        }
        getId() {
          return this.SEARCH_INPUT_ID;
        }
        getPosition() {
          var e2;
          const t2 = (null === (e2 = this.workspace_.options.languageTree) || void 0 === e2 ? void 0 : e2.contents) || [];
          for (let e3 = 0; e3 < t2.length; e3++) if (t2[e3].kind === i.SEARCH_CATEGORY_KIND) return e3;
          return -1;
        }
        registerShortcut() {
          const e2 = s.ShortcutRegistry.registry.createSerializedKey(s.utils.KeyCodes.B, [s.utils.KeyCodes.CTRL]);
          s.ShortcutRegistry.registry.register({ name: i.START_SEARCH_SHORTCUT, callback: () => !(this.getPosition() < 0 || (s.getFocusManager().focusNode(this), 0)), keyCodes: [e2] });
        }
        getAvailableBlocks(e2, t2) {
          "contents" in e2 ? e2.contents.forEach((e3) => {
            this.getAvailableBlocks(e3, t2);
          }) : "block" === e2.kind.toLowerCase() && "type" in e2 && e2.type && t2.add(e2);
        }
        initBlockSearcher() {
          var e2, t2;
          const r2 = /* @__PURE__ */ new Set();
          null === (t2 = null === (e2 = this.workspace_.options.languageTree) || void 0 === e2 ? void 0 : e2.contents) || void 0 === t2 || t2.forEach((e3) => this.getAvailableBlocks(e3, r2)), this.blockSearcher.indexBlocks([...r2]);
        }
        getFocusableElement() {
          if (!this.searchField) throw Error("This field currently has no representative DOM element.");
          return this.searchField;
        }
        onNodeFocus() {
          this.matchBlocks();
        }
        onNodeBlur() {
          this.searchField && (this.searchField.value = "");
        }
        matchBlocks() {
          var e2;
          const t2 = (null === (e2 = this.searchField) || void 0 === e2 ? void 0 : e2.value) || "";
          this.flyoutItems_ = t2 ? this.blockSearcher.blockTypesMatching(t2) : [], this.flyoutItems_.length || this.flyoutItems_.push({ kind: "label", text: t2.length < 3 ? "Type to search for blocks" : "No matching blocks found" }), this.parentToolbox_.refreshSelection();
        }
        dispose() {
          super.dispose(), s.ShortcutRegistry.registry.unregister(i.START_SEARCH_SHORTCUT);
        }
      }
      return i.START_SEARCH_SHORTCUT = "startSearch", i.SEARCH_CATEGORY_KIND = "search", s.registry.register(s.registry.Type.TOOLBOX_ITEM, i.SEARCH_CATEGORY_KIND, i), {};
    })());
  }
});
export default require_dist();
/*! Bundled license information:

@blockly/toolbox-search/dist/index.js:
  (*! For license information please see index.js.LICENSE.txt *)
*/
//# sourceMappingURL=@blockly_toolbox-search.js.map
