import {
  require_blockly_compressed
} from "./chunk-37NJYYKB.js";
import {
  __commonJS
} from "./chunk-PLDDJCW6.js";

// node_modules/@blockly/zoom-to-fit/dist/index.js
var require_dist = __commonJS({
  "node_modules/@blockly/zoom-to-fit/dist/index.js"(exports, module) {
    !(function(t, i) {
      if ("object" == typeof exports && "object" == typeof module) module.exports = i(require_blockly_compressed());
      else if ("function" == typeof define && define.amd) define(["blockly/core"], i);
      else {
        var o = "object" == typeof exports ? i(require_blockly_compressed()) : i(t.Blockly);
        for (var e in o) ("object" == typeof exports ? exports : t)[e] = o[e];
      }
    })(exports, (t) => (() => {
      "use strict";
      var i = { 370: (i2) => {
        i2.exports = t;
      } }, o = {};
      function e(t2) {
        var s2 = o[t2];
        if (void 0 !== s2) return s2.exports;
        var r2 = o[t2] = { exports: {} };
        return i[t2](r2, r2.exports, e), r2.exports;
      }
      e.n = (t2) => {
        var i2 = t2 && t2.__esModule ? () => t2.default : () => t2;
        return e.d(i2, { a: i2 }), i2;
      }, e.d = (t2, i2) => {
        for (var o2 in i2) e.o(i2, o2) && !e.o(t2, o2) && Object.defineProperty(t2, o2, { enumerable: true, get: i2[o2] });
      }, e.o = (t2, i2) => Object.prototype.hasOwnProperty.call(t2, i2), e.r = (t2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      };
      var s = {};
      e.r(s), e.d(s, { ZoomToFitControl: () => n });
      var r = e(370);
      class n {
        constructor(t2) {
          this.workspace = t2, this.id = "zoomToFit", this.svgGroup = null, this.left = 0, this.top = 0, this.width = 32, this.height = 32, this.marginVertical = 20, this.marginHorizontal = 20, this.initialized = false, this.onZoomToFitWrapper = null;
        }
        init() {
          this.workspace.getComponentManager().addComponent({ component: this, weight: 2, capabilities: [r.ComponentManager.Capability.POSITIONABLE] }), this.createDom(), this.initialized = true, this.workspace.resize();
        }
        dispose() {
          this.svgGroup && r.utils.dom.removeNode(this.svgGroup), this.onZoomToFitWrapper && (r.browserEvents.unbind(this.onZoomToFitWrapper), this.onZoomToFitWrapper = null);
        }
        createDom() {
          this.svgGroup = r.utils.dom.createSvgElement(r.utils.Svg.IMAGE, { height: `${this.height}px`, width: `${this.width}px`, class: "zoomToFit" }), this.svgGroup.setAttributeNS(r.utils.dom.XLINK_NS, "xlink:href", l), r.utils.dom.insertAfter(this.svgGroup, this.workspace.getBubbleCanvas()), this.onZoomToFitWrapper = r.browserEvents.conditionalBind(this.svgGroup, "pointerdown", null, this.onClick.bind(this));
        }
        onClick(t2) {
          this.workspace.zoomToFit();
          const i2 = new (r.Events.get(r.Events.CLICK))(null, this.workspace.id, "zoom_reset_control");
          r.Events.fire(i2), t2.stopPropagation(), t2.preventDefault();
        }
        getBoundingRectangle() {
          return new r.utils.Rect(this.top, this.top + this.height, this.left, this.left + this.width);
        }
        position(t2, i2) {
          var o2;
          if (!this.initialized) return;
          const e2 = this.workspace.scrollbar && this.workspace.scrollbar.canScrollHorizontally(), s2 = this.workspace.scrollbar && this.workspace.scrollbar.canScrollVertically();
          t2.toolboxMetrics.position === r.TOOLBOX_AT_LEFT || this.workspace.horizontalLayout && !this.workspace.RTL ? (this.left = t2.absoluteMetrics.left + t2.viewMetrics.width - this.width - this.marginHorizontal, e2 && !this.workspace.RTL && (this.left -= r.Scrollbar.scrollbarThickness)) : (this.left = this.marginHorizontal, e2 && this.workspace.RTL && (this.left += r.Scrollbar.scrollbarThickness));
          const n2 = t2.toolboxMetrics.position !== r.TOOLBOX_AT_BOTTOM;
          n2 ? (this.top = t2.absoluteMetrics.top + t2.viewMetrics.height - this.height - this.marginVertical, s2 && (this.top -= r.Scrollbar.scrollbarThickness)) : this.top = t2.absoluteMetrics.top + this.marginVertical;
          let l2 = this.getBoundingRectangle();
          for (let t3, o3 = 0; t3 = i2[o3]; o3++) l2.intersects(t3) && (this.top = n2 ? t3.top - this.height - this.marginVertical : t3.bottom + this.marginVertical, l2 = this.getBoundingRectangle(), o3 = -1);
          null === (o2 = this.svgGroup) || void 0 === o2 || o2.setAttribute("transform", `translate(${this.left}, ${this.top})`);
        }
      }
      const l = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDI0IDI0IiB3aWR0aD0iMjRweCIgZmlsbD0iIzU0NkU3QSI+PHBhdGggZD0iTTAgMGgyNHYyNEgwVjB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTUgNi40Mkw4LjA5IDkuNSA5LjUgOC4wOSA2LjQxIDVIOVYzSDN2Nmgyem0xMC0zLjQxdjJoMi41N0wxNC41IDguMDlsMS40MSAxLjQxTDE5IDYuNDFWOWgyVjMuMDF6bTQgMTQuNTdsLTMuMDktMy4wOC0xLjQxIDEuNDFMMTcuNTkgMTlIMTV2Mmg2di02aC0yek04LjA5IDE0LjVMNSAxNy41OVYxNUgzdjZoNnYtMkg2LjQybDMuMDgtMy4wOXoiLz48L3N2Zz4=";
      return r.Css.register("\n.zoomToFit {\n  opacity: 0.4;\n}\n.zoomToFit:hover {\n  opacity: 0.6;\n}\n.zoomToFit:active {\n  opacity: 0.8;\n}\n"), s;
    })());
  }
});
export default require_dist();
/*! Bundled license information:

@blockly/zoom-to-fit/dist/index.js:
  (*! For license information please see index.js.LICENSE.txt *)
*/
//# sourceMappingURL=@blockly_zoom-to-fit.js.map
