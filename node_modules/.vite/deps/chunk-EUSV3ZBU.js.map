{
  "version": 3,
  "sources": ["../../blockly/generators/javascript/lists.ts", "../../blockly/generators/javascript/logic.ts", "../../blockly/generators/javascript/loops.ts", "../../blockly/generators/javascript/math.ts", "../../blockly/generators/javascript/procedures.ts", "../../blockly/generators/javascript/text.ts", "../../blockly/generators/javascript/variables.ts", "../../blockly/generators/javascript/javascript_generator.ts", "../../blockly/generators/javascript/variables_dynamic.ts", "../../blockly/generators/javascript.ts", "../../blockly/generators/dart/lists.ts", "../../blockly/generators/dart/logic.ts", "../../blockly/generators/dart/loops.ts", "../../blockly/generators/dart/math.ts", "../../blockly/generators/dart/procedures.ts", "../../blockly/generators/dart/text.ts", "../../blockly/generators/dart/variables.ts", "../../blockly/generators/dart/dart_generator.ts", "../../blockly/generators/dart/variables_dynamic.ts", "../../blockly/generators/dart.ts", "../../blockly/generators/lua/lists.ts", "../../blockly/generators/lua/logic.ts", "../../blockly/generators/lua/loops.ts", "../../blockly/generators/lua/math.ts", "../../blockly/generators/lua/procedures.ts", "../../blockly/generators/lua/text.ts", "../../blockly/generators/lua/variables.ts", "../../blockly/generators/lua/lua_generator.ts", "../../blockly/generators/lua/variables_dynamic.ts", "../../blockly/generators/lua.ts", "../../blockly/generators/php/lists.ts", "../../blockly/generators/php/logic.ts", "../../blockly/generators/php/loops.ts", "../../blockly/generators/php/math.ts", "../../blockly/generators/php/procedures.ts", "../../blockly/generators/php/text.ts", "../../blockly/generators/php/variables.ts", "../../blockly/generators/php/php_generator.ts", "../../blockly/generators/php/variables_dynamic.ts", "../../blockly/generators/php.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating JavaScript for list blocks.\n */\n\n// Former goog.module ID: Blockly.JavaScript.lists\n\nimport type {CreateWithBlock} from '../../blocks/lists.js';\nimport type {Block} from '../../core/block.js';\nimport {NameType} from '../../core/names.js';\nimport type {JavascriptGenerator} from './javascript_generator.js';\nimport {Order} from './javascript_generator.js';\n\nexport function lists_create_empty(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Create an empty list.\n  return ['[]', Order.ATOMIC];\n}\n\nexport function lists_create_with(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Create a list with any number of elements of any type.\n  const createWithBlock = block as CreateWithBlock;\n  const elements = new Array(createWithBlock.itemCount_);\n  for (let i = 0; i < createWithBlock.itemCount_; i++) {\n    elements[i] = generator.valueToCode(block, 'ADD' + i, Order.NONE) || 'null';\n  }\n  const code = '[' + elements.join(', ') + ']';\n  return [code, Order.ATOMIC];\n}\n\nexport function lists_repeat(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Create a list with one element repeated.\n  const functionName = generator.provideFunction_(\n    'listsRepeat',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(value, n) {\n  var array = [];\n  for (var i = 0; i < n; i++) {\n    array[i] = value;\n  }\n  return array;\n}\n`,\n  );\n  const element = generator.valueToCode(block, 'ITEM', Order.NONE) || 'null';\n  const repeatCount = generator.valueToCode(block, 'NUM', Order.NONE) || '0';\n  const code = functionName + '(' + element + ', ' + repeatCount + ')';\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function lists_length(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // String or array length.\n  const list = generator.valueToCode(block, 'VALUE', Order.MEMBER) || '[]';\n  return [list + '.length', Order.MEMBER];\n}\n\nexport function lists_isEmpty(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Is the string null or array empty?\n  const list = generator.valueToCode(block, 'VALUE', Order.MEMBER) || '[]';\n  return ['!' + list + '.length', Order.LOGICAL_NOT];\n}\n\nexport function lists_indexOf(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Find an item in the list.\n  const operator =\n    block.getFieldValue('END') === 'FIRST' ? 'indexOf' : 'lastIndexOf';\n  const item = generator.valueToCode(block, 'FIND', Order.NONE) || \"''\";\n  const list = generator.valueToCode(block, 'VALUE', Order.MEMBER) || '[]';\n  const code = list + '.' + operator + '(' + item + ')';\n  if (block.workspace.options.oneBasedIndex) {\n    return [code + ' + 1', Order.ADDITION];\n  }\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function lists_getIndex(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] | string {\n  // Get element at index.\n  // Note: Until January 2013 this block did not have MODE or WHERE inputs.\n  const mode = block.getFieldValue('MODE') || 'GET';\n  const where = block.getFieldValue('WHERE') || 'FROM_START';\n  const listOrder = where === 'RANDOM' ? Order.NONE : Order.MEMBER;\n  const list = generator.valueToCode(block, 'VALUE', listOrder) || '[]';\n\n  switch (where) {\n    case 'FIRST':\n      if (mode === 'GET') {\n        const code = list + '[0]';\n        return [code, Order.MEMBER];\n      } else if (mode === 'GET_REMOVE') {\n        const code = list + '.shift()';\n        return [code, Order.MEMBER];\n      } else if (mode === 'REMOVE') {\n        return list + '.shift();\\n';\n      }\n      break;\n    case 'LAST':\n      if (mode === 'GET') {\n        const code = list + '.slice(-1)[0]';\n        return [code, Order.MEMBER];\n      } else if (mode === 'GET_REMOVE') {\n        const code = list + '.pop()';\n        return [code, Order.MEMBER];\n      } else if (mode === 'REMOVE') {\n        return list + '.pop();\\n';\n      }\n      break;\n    case 'FROM_START': {\n      const at = generator.getAdjusted(block, 'AT');\n      if (mode === 'GET') {\n        const code = list + '[' + at + ']';\n        return [code, Order.MEMBER];\n      } else if (mode === 'GET_REMOVE') {\n        const code = list + '.splice(' + at + ', 1)[0]';\n        return [code, Order.FUNCTION_CALL];\n      } else if (mode === 'REMOVE') {\n        return list + '.splice(' + at + ', 1);\\n';\n      }\n      break;\n    }\n    case 'FROM_END': {\n      const at = generator.getAdjusted(block, 'AT', 1, true);\n      if (mode === 'GET') {\n        const code = list + '.slice(' + at + ')[0]';\n        return [code, Order.FUNCTION_CALL];\n      } else if (mode === 'GET_REMOVE') {\n        const code = list + '.splice(' + at + ', 1)[0]';\n        return [code, Order.FUNCTION_CALL];\n      } else if (mode === 'REMOVE') {\n        return list + '.splice(' + at + ', 1);';\n      }\n      break;\n    }\n    case 'RANDOM': {\n      const functionName = generator.provideFunction_(\n        'listsGetRandomItem',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(list, remove) {\n  var x = Math.floor(Math.random() * list.length);\n  if (remove) {\n    return list.splice(x, 1)[0];\n  } else {\n    return list[x];\n  }\n}\n`,\n      );\n      const code = functionName + '(' + list + ', ' + (mode !== 'GET') + ')';\n      if (mode === 'GET' || mode === 'GET_REMOVE') {\n        return [code, Order.FUNCTION_CALL];\n      } else if (mode === 'REMOVE') {\n        return code + ';\\n';\n      }\n      break;\n    }\n  }\n  throw Error('Unhandled combination (lists_getIndex).');\n}\n\nexport function lists_setIndex(block: Block, generator: JavascriptGenerator) {\n  // Set element at index.\n  // Note: Until February 2013 this block did not have MODE or WHERE inputs.\n  let list = generator.valueToCode(block, 'LIST', Order.MEMBER) || '[]';\n  const mode = block.getFieldValue('MODE') || 'GET';\n  const where = block.getFieldValue('WHERE') || 'FROM_START';\n  const value = generator.valueToCode(block, 'TO', Order.ASSIGNMENT) || 'null';\n  // Cache non-trivial values to variables to prevent repeated look-ups.\n  // Closure, which accesses and modifies 'list'.\n  function cacheList() {\n    if (list.match(/^\\w+$/)) {\n      return '';\n    }\n    const listVar = generator.nameDB_!.getDistinctName(\n      'tmpList',\n      NameType.VARIABLE,\n    )!;\n    const code = 'var ' + listVar + ' = ' + list + ';\\n';\n    list = listVar;\n    return code;\n  }\n  switch (where) {\n    case 'FIRST':\n      if (mode === 'SET') {\n        return list + '[0] = ' + value + ';\\n';\n      } else if (mode === 'INSERT') {\n        return list + '.unshift(' + value + ');\\n';\n      }\n      break;\n    case 'LAST':\n      if (mode === 'SET') {\n        let code = cacheList();\n        code += list + '[' + list + '.length - 1] = ' + value + ';\\n';\n        return code;\n      } else if (mode === 'INSERT') {\n        return list + '.push(' + value + ');\\n';\n      }\n      break;\n    case 'FROM_START': {\n      const at = generator.getAdjusted(block, 'AT');\n      if (mode === 'SET') {\n        return list + '[' + at + '] = ' + value + ';\\n';\n      } else if (mode === 'INSERT') {\n        return list + '.splice(' + at + ', 0, ' + value + ');\\n';\n      }\n      break;\n    }\n    case 'FROM_END': {\n      const at = generator.getAdjusted(\n        block,\n        'AT',\n        1,\n        false,\n        Order.SUBTRACTION,\n      );\n      let code = cacheList();\n      if (mode === 'SET') {\n        code += list + '[' + list + '.length - ' + at + '] = ' + value + ';\\n';\n        return code;\n      } else if (mode === 'INSERT') {\n        code +=\n          list +\n          '.splice(' +\n          list +\n          '.length - ' +\n          at +\n          ', 0, ' +\n          value +\n          ');\\n';\n        return code;\n      }\n      break;\n    }\n    case 'RANDOM': {\n      let code = cacheList();\n      const xVar = generator.nameDB_!.getDistinctName(\n        'tmpX',\n        NameType.VARIABLE,\n      );\n      code +=\n        'var ' + xVar + ' = Math.floor(Math.random() * ' + list + '.length);\\n';\n      if (mode === 'SET') {\n        code += list + '[' + xVar + '] = ' + value + ';\\n';\n        return code;\n      } else if (mode === 'INSERT') {\n        code += list + '.splice(' + xVar + ', 0, ' + value + ');\\n';\n        return code;\n      }\n      break;\n    }\n  }\n  throw Error('Unhandled combination (lists_setIndex).');\n}\n\n/**\n * Returns an expression calculating the index into a list.\n * @param listName Name of the list, used to calculate length.\n * @param where The method of indexing, selected by dropdown in Blockly\n * @param opt_at The optional offset when indexing from start/end.\n * @returns Index expression.\n */\nconst getSubstringIndex = function (\n  listName: string,\n  where: string,\n  opt_at?: string,\n): string | undefined {\n  if (where === 'FIRST') {\n    return '0';\n  } else if (where === 'FROM_END') {\n    return listName + '.length - 1 - ' + opt_at;\n  } else if (where === 'LAST') {\n    return listName + '.length - 1';\n  } else {\n    return opt_at;\n  }\n};\n\nexport function lists_getSublist(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Get sublist.\n  // Dictionary of WHEREn field choices and their CamelCase equivalents.\n  const wherePascalCase = {\n    'FIRST': 'First',\n    'LAST': 'Last',\n    'FROM_START': 'FromStart',\n    'FROM_END': 'FromEnd',\n  };\n  type WhereOption = keyof typeof wherePascalCase;\n  const list = generator.valueToCode(block, 'LIST', Order.MEMBER) || '[]';\n  const where1 = block.getFieldValue('WHERE1') as WhereOption;\n  const where2 = block.getFieldValue('WHERE2') as WhereOption;\n  let code;\n  if (where1 === 'FIRST' && where2 === 'LAST') {\n    code = list + '.slice(0)';\n  } else if (\n    list.match(/^\\w+$/) ||\n    (where1 !== 'FROM_END' && where2 === 'FROM_START')\n  ) {\n    // If the list is a variable or doesn't require a call for length, don't\n    // generate a helper function.\n    let at1;\n    switch (where1) {\n      case 'FROM_START':\n        at1 = generator.getAdjusted(block, 'AT1');\n        break;\n      case 'FROM_END':\n        at1 = generator.getAdjusted(block, 'AT1', 1, false, Order.SUBTRACTION);\n        at1 = list + '.length - ' + at1;\n        break;\n      case 'FIRST':\n        at1 = '0';\n        break;\n      default:\n        throw Error('Unhandled option (lists_getSublist).');\n    }\n    let at2;\n    switch (where2) {\n      case 'FROM_START':\n        at2 = generator.getAdjusted(block, 'AT2', 1);\n        break;\n      case 'FROM_END':\n        at2 = generator.getAdjusted(block, 'AT2', 0, false, Order.SUBTRACTION);\n        at2 = list + '.length - ' + at2;\n        break;\n      case 'LAST':\n        at2 = list + '.length';\n        break;\n      default:\n        throw Error('Unhandled option (lists_getSublist).');\n    }\n    code = list + '.slice(' + at1 + ', ' + at2 + ')';\n  } else {\n    const at1 = generator.getAdjusted(block, 'AT1');\n    const at2 = generator.getAdjusted(block, 'AT2');\n    // The value for 'FROM_END' and'FROM_START' depends on `at` so\n    // we add it as a parameter.\n    const at1Param =\n      where1 === 'FROM_END' || where1 === 'FROM_START' ? ', at1' : '';\n    const at2Param =\n      where2 === 'FROM_END' || where2 === 'FROM_START' ? ', at2' : '';\n    const functionName = generator.provideFunction_(\n      'subsequence' + wherePascalCase[where1] + wherePascalCase[where2],\n      `\nfunction ${\n        generator.FUNCTION_NAME_PLACEHOLDER_\n      }(sequence${at1Param}${at2Param}) {\n  var start = ${getSubstringIndex('sequence', where1, 'at1')};\n  var end = ${getSubstringIndex('sequence', where2, 'at2')} + 1;\n  return sequence.slice(start, end);\n}\n`,\n    );\n    code =\n      functionName +\n      '(' +\n      list +\n      // The value for 'FROM_END' and 'FROM_START' depends on `at` so we\n      // pass it.\n      (where1 === 'FROM_END' || where1 === 'FROM_START' ? ', ' + at1 : '') +\n      (where2 === 'FROM_END' || where2 === 'FROM_START' ? ', ' + at2 : '') +\n      ')';\n  }\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function lists_sort(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Block for sorting a list.\n  const list =\n    generator.valueToCode(block, 'LIST', Order.FUNCTION_CALL) || '[]';\n  const direction = block.getFieldValue('DIRECTION') === '1' ? 1 : -1;\n  const type = block.getFieldValue('TYPE');\n  const getCompareFunctionName = generator.provideFunction_(\n    'listsGetSortCompare',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(type, direction) {\n  var compareFuncs = {\n    'NUMERIC': function(a, b) {\n        return Number(a) - Number(b); },\n    'TEXT': function(a, b) {\n        return String(a) > String(b) ? 1 : -1; },\n    'IGNORE_CASE': function(a, b) {\n        return String(a).toLowerCase() > String(b).toLowerCase() ? 1 : -1; },\n  };\n  var compare = compareFuncs[type];\n  return function(a, b) { return compare(a, b) * direction; };\n}\n      `,\n  );\n  return [\n    list +\n      '.slice().sort(' +\n      getCompareFunctionName +\n      '(\"' +\n      type +\n      '\", ' +\n      direction +\n      '))',\n    Order.FUNCTION_CALL,\n  ];\n}\n\nexport function lists_split(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Block for splitting text into a list, or joining a list into text.\n  let input = generator.valueToCode(block, 'INPUT', Order.MEMBER);\n  const delimiter = generator.valueToCode(block, 'DELIM', Order.NONE) || \"''\";\n  const mode = block.getFieldValue('MODE');\n  let functionName;\n  if (mode === 'SPLIT') {\n    if (!input) {\n      input = \"''\";\n    }\n    functionName = 'split';\n  } else if (mode === 'JOIN') {\n    if (!input) {\n      input = '[]';\n    }\n    functionName = 'join';\n  } else {\n    throw Error('Unknown mode: ' + mode);\n  }\n  const code = input + '.' + functionName + '(' + delimiter + ')';\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function lists_reverse(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Block for reversing a list.\n  const list =\n    generator.valueToCode(block, 'LIST', Order.FUNCTION_CALL) || '[]';\n  const code = list + '.slice().reverse()';\n  return [code, Order.FUNCTION_CALL];\n}\n", "/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating JavaScript for logic blocks.\n */\n\n// Former goog.module ID: Blockly.JavaScript.logic\n\nimport type {Block} from '../../core/block.js';\nimport type {JavascriptGenerator} from './javascript_generator.js';\nimport {Order} from './javascript_generator.js';\n\nexport function controls_if(block: Block, generator: JavascriptGenerator) {\n  // If/elseif/else condition.\n  let n = 0;\n  let code = '';\n  if (generator.STATEMENT_PREFIX) {\n    // Automatic prefix insertion is switched off for this block.  Add manually.\n    code += generator.injectId(generator.STATEMENT_PREFIX, block);\n  }\n  do {\n    const conditionCode =\n      generator.valueToCode(block, 'IF' + n, Order.NONE) || 'false';\n    let branchCode = generator.statementToCode(block, 'DO' + n);\n    if (generator.STATEMENT_SUFFIX) {\n      branchCode =\n        generator.prefixLines(\n          generator.injectId(generator.STATEMENT_SUFFIX, block),\n          generator.INDENT,\n        ) + branchCode;\n    }\n    code +=\n      (n > 0 ? ' else ' : '') +\n      'if (' +\n      conditionCode +\n      ') {\\n' +\n      branchCode +\n      '}';\n    n++;\n  } while (block.getInput('IF' + n));\n\n  if (block.getInput('ELSE') || generator.STATEMENT_SUFFIX) {\n    let branchCode = block.getInput('ELSE')\n      ? generator.statementToCode(block, 'ELSE')\n      : '';\n    if (generator.STATEMENT_SUFFIX) {\n      branchCode =\n        generator.prefixLines(\n          generator.injectId(generator.STATEMENT_SUFFIX, block),\n          generator.INDENT,\n        ) + branchCode;\n    }\n    code += ' else {\\n' + branchCode + '}';\n  }\n  return code + '\\n';\n}\n\nexport const controls_ifelse = controls_if;\n\nexport function logic_compare(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Comparison operator.\n  const OPERATORS = {\n    'EQ': '==',\n    'NEQ': '!=',\n    'LT': '<',\n    'LTE': '<=',\n    'GT': '>',\n    'GTE': '>=',\n  };\n  type OperatorOption = keyof typeof OPERATORS;\n  const operator = OPERATORS[block.getFieldValue('OP') as OperatorOption];\n  const order =\n    operator === '==' || operator === '!=' ? Order.EQUALITY : Order.RELATIONAL;\n  const argument0 = generator.valueToCode(block, 'A', order) || '0';\n  const argument1 = generator.valueToCode(block, 'B', order) || '0';\n  const code = argument0 + ' ' + operator + ' ' + argument1;\n  return [code, order];\n}\n\nexport function logic_operation(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Operations 'and', 'or'.\n  const operator = block.getFieldValue('OP') === 'AND' ? '&&' : '||';\n  const order = operator === '&&' ? Order.LOGICAL_AND : Order.LOGICAL_OR;\n  let argument0 = generator.valueToCode(block, 'A', order);\n  let argument1 = generator.valueToCode(block, 'B', order);\n  if (!argument0 && !argument1) {\n    // If there are no arguments, then the return value is false.\n    argument0 = 'false';\n    argument1 = 'false';\n  } else {\n    // Single missing arguments have no effect on the return value.\n    const defaultArgument = operator === '&&' ? 'true' : 'false';\n    if (!argument0) {\n      argument0 = defaultArgument;\n    }\n    if (!argument1) {\n      argument1 = defaultArgument;\n    }\n  }\n  const code = argument0 + ' ' + operator + ' ' + argument1;\n  return [code, order];\n}\n\nexport function logic_negate(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Negation.\n  const order = Order.LOGICAL_NOT;\n  const argument0 = generator.valueToCode(block, 'BOOL', order) || 'true';\n  const code = '!' + argument0;\n  return [code, order];\n}\n\nexport function logic_boolean(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Boolean values true and false.\n  const code = block.getFieldValue('BOOL') === 'TRUE' ? 'true' : 'false';\n  return [code, Order.ATOMIC];\n}\n\nexport function logic_null(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Null data type.\n  return ['null', Order.ATOMIC];\n}\n\nexport function logic_ternary(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Ternary operator.\n  const value_if =\n    generator.valueToCode(block, 'IF', Order.CONDITIONAL) || 'false';\n  const value_then =\n    generator.valueToCode(block, 'THEN', Order.CONDITIONAL) || 'null';\n  const value_else =\n    generator.valueToCode(block, 'ELSE', Order.CONDITIONAL) || 'null';\n  const code = value_if + ' ? ' + value_then + ' : ' + value_else;\n  return [code, Order.CONDITIONAL];\n}\n", "/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating JavaScript for loop blocks.\n */\n\n// Former goog.module ID: Blockly.JavaScript.loops\n\nimport type {ControlFlowInLoopBlock} from '../../blocks/loops.js';\nimport type {Block} from '../../core/block.js';\nimport {NameType} from '../../core/names.js';\nimport * as stringUtils from '../../core/utils/string.js';\nimport type {JavascriptGenerator} from './javascript_generator.js';\nimport {Order} from './javascript_generator.js';\n\nexport function controls_repeat_ext(\n  block: Block,\n  generator: JavascriptGenerator,\n) {\n  // Repeat n times.\n  let repeats;\n  if (block.getField('TIMES')) {\n    // Internal number.\n    repeats = String(Number(block.getFieldValue('TIMES')));\n  } else {\n    // External number.\n    repeats = generator.valueToCode(block, 'TIMES', Order.ASSIGNMENT) || '0';\n  }\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  let code = '';\n  const loopVar = generator.nameDB_!.getDistinctName(\n    'count',\n    NameType.VARIABLE,\n  );\n  let endVar = repeats;\n  if (!repeats.match(/^\\w+$/) && !stringUtils.isNumber(repeats)) {\n    endVar = generator.nameDB_!.getDistinctName(\n      'repeat_end',\n      NameType.VARIABLE,\n    );\n    code += 'var ' + endVar + ' = ' + repeats + ';\\n';\n  }\n  code +=\n    'for (var ' +\n    loopVar +\n    ' = 0; ' +\n    loopVar +\n    ' < ' +\n    endVar +\n    '; ' +\n    loopVar +\n    '++) {\\n' +\n    branch +\n    '}\\n';\n  return code;\n}\n\nexport const controls_repeat = controls_repeat_ext;\n\nexport function controls_whileUntil(\n  block: Block,\n  generator: JavascriptGenerator,\n) {\n  // Do while/until loop.\n  const until = block.getFieldValue('MODE') === 'UNTIL';\n  let argument0 =\n    generator.valueToCode(\n      block,\n      'BOOL',\n      until ? Order.LOGICAL_NOT : Order.NONE,\n    ) || 'false';\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  if (until) {\n    argument0 = '!' + argument0;\n  }\n  return 'while (' + argument0 + ') {\\n' + branch + '}\\n';\n}\n\nexport function controls_for(block: Block, generator: JavascriptGenerator) {\n  // For loop.\n  const variable0 = generator.getVariableName(block.getFieldValue('VAR'));\n  const argument0 =\n    generator.valueToCode(block, 'FROM', Order.ASSIGNMENT) || '0';\n  const argument1 = generator.valueToCode(block, 'TO', Order.ASSIGNMENT) || '0';\n  const increment = generator.valueToCode(block, 'BY', Order.ASSIGNMENT) || '1';\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  let code;\n  if (\n    stringUtils.isNumber(argument0) &&\n    stringUtils.isNumber(argument1) &&\n    stringUtils.isNumber(increment)\n  ) {\n    // All arguments are simple numbers.\n    const up = Number(argument0) <= Number(argument1);\n    code =\n      'for (' +\n      variable0 +\n      ' = ' +\n      argument0 +\n      '; ' +\n      variable0 +\n      (up ? ' <= ' : ' >= ') +\n      argument1 +\n      '; ' +\n      variable0;\n    const step = Math.abs(Number(increment));\n    if (step === 1) {\n      code += up ? '++' : '--';\n    } else {\n      code += (up ? ' += ' : ' -= ') + step;\n    }\n    code += ') {\\n' + branch + '}\\n';\n  } else {\n    code = '';\n    // Cache non-trivial values to variables to prevent repeated look-ups.\n    let startVar = argument0;\n    if (!argument0.match(/^\\w+$/) && !stringUtils.isNumber(argument0)) {\n      startVar = generator.nameDB_!.getDistinctName(\n        variable0 + '_start',\n        NameType.VARIABLE,\n      );\n      code += 'var ' + startVar + ' = ' + argument0 + ';\\n';\n    }\n    let endVar = argument1;\n    if (!argument1.match(/^\\w+$/) && !stringUtils.isNumber(argument1)) {\n      endVar = generator.nameDB_!.getDistinctName(\n        variable0 + '_end',\n        NameType.VARIABLE,\n      );\n      code += 'var ' + endVar + ' = ' + argument1 + ';\\n';\n    }\n    // Determine loop direction at start, in case one of the bounds\n    // changes during loop execution.\n    const incVar = generator.nameDB_!.getDistinctName(\n      variable0 + '_inc',\n      NameType.VARIABLE,\n    );\n    code += 'var ' + incVar + ' = ';\n    if (stringUtils.isNumber(increment)) {\n      code += Math.abs(Number(increment)) + ';\\n';\n    } else {\n      code += 'Math.abs(' + increment + ');\\n';\n    }\n    code += 'if (' + startVar + ' > ' + endVar + ') {\\n';\n    code += generator.INDENT + incVar + ' = -' + incVar + ';\\n';\n    code += '}\\n';\n    code +=\n      'for (' +\n      variable0 +\n      ' = ' +\n      startVar +\n      '; ' +\n      incVar +\n      ' >= 0 ? ' +\n      variable0 +\n      ' <= ' +\n      endVar +\n      ' : ' +\n      variable0 +\n      ' >= ' +\n      endVar +\n      '; ' +\n      variable0 +\n      ' += ' +\n      incVar +\n      ') {\\n' +\n      branch +\n      '}\\n';\n  }\n  return code;\n}\n\nexport function controls_forEach(block: Block, generator: JavascriptGenerator) {\n  // For each loop.\n  const variable0 = generator.getVariableName(block.getFieldValue('VAR'));\n  const argument0 =\n    generator.valueToCode(block, 'LIST', Order.ASSIGNMENT) || '[]';\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  let code = '';\n  // Cache non-trivial values to variables to prevent repeated look-ups.\n  let listVar = argument0;\n  if (!argument0.match(/^\\w+$/)) {\n    listVar = generator.nameDB_!.getDistinctName(\n      variable0 + '_list',\n      NameType.VARIABLE,\n    );\n    code += 'var ' + listVar + ' = ' + argument0 + ';\\n';\n  }\n  const indexVar = generator.nameDB_!.getDistinctName(\n    variable0 + '_index',\n    NameType.VARIABLE,\n  );\n  branch =\n    generator.INDENT +\n    variable0 +\n    ' = ' +\n    listVar +\n    '[' +\n    indexVar +\n    '];\\n' +\n    branch;\n  code += 'for (var ' + indexVar + ' in ' + listVar + ') {\\n' + branch + '}\\n';\n  return code;\n}\n\nexport function controls_flow_statements(\n  block: Block,\n  generator: JavascriptGenerator,\n) {\n  // Flow statements: continue, break.\n  let xfix = '';\n  if (generator.STATEMENT_PREFIX) {\n    // Automatic prefix insertion is switched off for this block.  Add manually.\n    xfix += generator.injectId(generator.STATEMENT_PREFIX, block);\n  }\n  if (generator.STATEMENT_SUFFIX) {\n    // Inject any statement suffix here since the regular one at the end\n    // will not get executed if the break/continue is triggered.\n    xfix += generator.injectId(generator.STATEMENT_SUFFIX, block);\n  }\n  if (generator.STATEMENT_PREFIX) {\n    const loop = (block as ControlFlowInLoopBlock).getSurroundLoop();\n    if (loop && !loop.suppressPrefixSuffix) {\n      // Inject loop's statement prefix here since the regular one at the end\n      // of the loop will not get executed if 'continue' is triggered.\n      // In the case of 'break', a prefix is needed due to the loop's suffix.\n      xfix += generator.injectId(generator.STATEMENT_PREFIX, loop);\n    }\n  }\n  switch (block.getFieldValue('FLOW')) {\n    case 'BREAK':\n      return xfix + 'break;\\n';\n    case 'CONTINUE':\n      return xfix + 'continue;\\n';\n  }\n  throw Error('Unknown flow statement.');\n}\n", "/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating JavaScript for math blocks.\n */\n\n// Former goog.module ID: Blockly.JavaScript.math\n\nimport type {Block} from '../../core/block.js';\nimport type {JavascriptGenerator} from './javascript_generator.js';\nimport {Order} from './javascript_generator.js';\n\nexport function math_number(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Numeric value.\n  const number = Number(block.getFieldValue('NUM'));\n  const order = number >= 0 ? Order.ATOMIC : Order.UNARY_NEGATION;\n  return [String(number), order];\n}\n\nexport function math_arithmetic(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Basic arithmetic operators, and power.\n  const OPERATORS: Record<string, [string | null, Order]> = {\n    'ADD': [' + ', Order.ADDITION],\n    'MINUS': [' - ', Order.SUBTRACTION],\n    'MULTIPLY': [' * ', Order.MULTIPLICATION],\n    'DIVIDE': [' / ', Order.DIVISION],\n    'POWER': [null, Order.NONE], // Handle power separately.\n  };\n  type OperatorOption = keyof typeof OPERATORS;\n  const tuple = OPERATORS[block.getFieldValue('OP') as OperatorOption];\n  const operator = tuple[0];\n  const order = tuple[1];\n  const argument0 = generator.valueToCode(block, 'A', order) || '0';\n  const argument1 = generator.valueToCode(block, 'B', order) || '0';\n  let code;\n  // Power in JavaScript requires a special case since it has no operator.\n  if (!operator) {\n    code = 'Math.pow(' + argument0 + ', ' + argument1 + ')';\n    return [code, Order.FUNCTION_CALL];\n  }\n  code = argument0 + operator + argument1;\n  return [code, order];\n}\n\nexport function math_single(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Math operators with single operand.\n  const operator = block.getFieldValue('OP');\n  let code;\n  let arg;\n  if (operator === 'NEG') {\n    // Negation is a special case given its different operator precedence.\n    arg = generator.valueToCode(block, 'NUM', Order.UNARY_NEGATION) || '0';\n    if (arg[0] === '-') {\n      // --3 is not legal in JS.\n      arg = ' ' + arg;\n    }\n    code = '-' + arg;\n    return [code, Order.UNARY_NEGATION];\n  }\n  if (operator === 'SIN' || operator === 'COS' || operator === 'TAN') {\n    arg = generator.valueToCode(block, 'NUM', Order.DIVISION) || '0';\n  } else {\n    arg = generator.valueToCode(block, 'NUM', Order.NONE) || '0';\n  }\n  // First, handle cases which generate values that don't need parentheses\n  // wrapping the code.\n  switch (operator) {\n    case 'ABS':\n      code = 'Math.abs(' + arg + ')';\n      break;\n    case 'ROOT':\n      code = 'Math.sqrt(' + arg + ')';\n      break;\n    case 'LN':\n      code = 'Math.log(' + arg + ')';\n      break;\n    case 'EXP':\n      code = 'Math.exp(' + arg + ')';\n      break;\n    case 'POW10':\n      code = 'Math.pow(10,' + arg + ')';\n      break;\n    case 'ROUND':\n      code = 'Math.round(' + arg + ')';\n      break;\n    case 'ROUNDUP':\n      code = 'Math.ceil(' + arg + ')';\n      break;\n    case 'ROUNDDOWN':\n      code = 'Math.floor(' + arg + ')';\n      break;\n    case 'SIN':\n      code = 'Math.sin(' + arg + ' / 180 * Math.PI)';\n      break;\n    case 'COS':\n      code = 'Math.cos(' + arg + ' / 180 * Math.PI)';\n      break;\n    case 'TAN':\n      code = 'Math.tan(' + arg + ' / 180 * Math.PI)';\n      break;\n  }\n  if (code) {\n    return [code, Order.FUNCTION_CALL];\n  }\n  // Second, handle cases which generate values that may need parentheses\n  // wrapping the code.\n  switch (operator) {\n    case 'LOG10':\n      code = 'Math.log(' + arg + ') / Math.log(10)';\n      break;\n    case 'ASIN':\n      code = 'Math.asin(' + arg + ') / Math.PI * 180';\n      break;\n    case 'ACOS':\n      code = 'Math.acos(' + arg + ') / Math.PI * 180';\n      break;\n    case 'ATAN':\n      code = 'Math.atan(' + arg + ') / Math.PI * 180';\n      break;\n    default:\n      throw Error('Unknown math operator: ' + operator);\n  }\n  return [code, Order.DIVISION];\n}\n\nexport function math_constant(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Constants: PI, E, the Golden Ratio, sqrt(2), 1/sqrt(2), INFINITY.\n  const CONSTANTS: Record<string, [string, Order]> = {\n    'PI': ['Math.PI', Order.MEMBER],\n    'E': ['Math.E', Order.MEMBER],\n    'GOLDEN_RATIO': ['(1 + Math.sqrt(5)) / 2', Order.DIVISION],\n    'SQRT2': ['Math.SQRT2', Order.MEMBER],\n    'SQRT1_2': ['Math.SQRT1_2', Order.MEMBER],\n    'INFINITY': ['Infinity', Order.ATOMIC],\n  };\n  type ConstantOption = keyof typeof CONSTANTS;\n  return CONSTANTS[block.getFieldValue('CONSTANT') as ConstantOption];\n}\n\nexport function math_number_property(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Check if a number is even, odd, prime, whole, positive, or negative\n  // or if it is divisible by certain number. Returns true or false.\n  const PROPERTIES: Record<string, [string | null, Order, Order]> = {\n    'EVEN': [' % 2 === 0', Order.MODULUS, Order.EQUALITY],\n    'ODD': [' % 2 === 1', Order.MODULUS, Order.EQUALITY],\n    'WHOLE': [' % 1 === 0', Order.MODULUS, Order.EQUALITY],\n    'POSITIVE': [' > 0', Order.RELATIONAL, Order.RELATIONAL],\n    'NEGATIVE': [' < 0', Order.RELATIONAL, Order.RELATIONAL],\n    'DIVISIBLE_BY': [null, Order.MODULUS, Order.EQUALITY],\n    'PRIME': [null, Order.NONE, Order.FUNCTION_CALL],\n  };\n  type PropertyOption = keyof typeof PROPERTIES;\n  const dropdownProperty = block.getFieldValue('PROPERTY') as PropertyOption;\n  const [suffix, inputOrder, outputOrder] = PROPERTIES[dropdownProperty];\n  const numberToCheck =\n    generator.valueToCode(block, 'NUMBER_TO_CHECK', inputOrder) || '0';\n  let code;\n  if (dropdownProperty === 'PRIME') {\n    // Prime is a special case as it is not a one-liner test.\n    const functionName = generator.provideFunction_(\n      'mathIsPrime',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(n) {\n  // https://en.wikipedia.org/wiki/Primality_test#Naive_methods\n  if (n == 2 || n == 3) {\n    return true;\n  }\n  // False if n is NaN, negative, is 1, or not whole.\n  // And false if n is divisible by 2 or 3.\n  if (isNaN(n) || n <= 1 || n % 1 !== 0 || n % 2 === 0 || n % 3 === 0) {\n    return false;\n  }\n  // Check all the numbers of form 6k +/- 1, up to sqrt(n).\n  for (var x = 6; x <= Math.sqrt(n) + 1; x += 6) {\n    if (n % (x - 1) === 0 || n % (x + 1) === 0) {\n      return false;\n    }\n  }\n  return true;\n}\n`,\n    );\n    code = functionName + '(' + numberToCheck + ')';\n  } else if (dropdownProperty === 'DIVISIBLE_BY') {\n    const divisor =\n      generator.valueToCode(block, 'DIVISOR', Order.MODULUS) || '0';\n    code = numberToCheck + ' % ' + divisor + ' === 0';\n  } else {\n    code = numberToCheck + suffix;\n  }\n  return [code, outputOrder];\n}\n\nexport function math_change(block: Block, generator: JavascriptGenerator) {\n  // Add to a variable in place.\n  const argument0 =\n    generator.valueToCode(block, 'DELTA', Order.ADDITION) || '0';\n  const varName = generator.getVariableName(block.getFieldValue('VAR'));\n  return (\n    varName +\n    ' = (typeof ' +\n    varName +\n    \" === 'number' ? \" +\n    varName +\n    ' : 0) + ' +\n    argument0 +\n    ';\\n'\n  );\n}\n\n// Rounding functions have a single operand.\nexport const math_round = math_single;\n// Trigonometry functions have a single operand.\nexport const math_trig = math_single;\n\nexport function math_on_list(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Math functions for lists.\n  const func = block.getFieldValue('OP');\n  let list;\n  let code;\n  switch (func) {\n    case 'SUM':\n      list = generator.valueToCode(block, 'LIST', Order.MEMBER) || '[]';\n      code = list + '.reduce(function(x, y) {return x + y;}, 0)';\n      break;\n    case 'MIN':\n      list = generator.valueToCode(block, 'LIST', Order.NONE) || '[]';\n      code = 'Math.min.apply(null, ' + list + ')';\n      break;\n    case 'MAX':\n      list = generator.valueToCode(block, 'LIST', Order.NONE) || '[]';\n      code = 'Math.max.apply(null, ' + list + ')';\n      break;\n    case 'AVERAGE': {\n      // mathMean([null,null,1,3]) === 2.0.\n      const functionName = generator.provideFunction_(\n        'mathMean',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(myList) {\n  return myList.reduce(function(x, y) {return x + y;}, 0) / myList.length;\n}\n`,\n      );\n      list = generator.valueToCode(block, 'LIST', Order.NONE) || '[]';\n      code = functionName + '(' + list + ')';\n      break;\n    }\n    case 'MEDIAN': {\n      // mathMedian([null,null,1,3]) === 2.0.\n      const functionName = generator.provideFunction_(\n        'mathMedian',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(myList) {\n  var localList = myList.filter(function (x) {return typeof x === 'number';});\n  if (!localList.length) return null;\n  localList.sort(function(a, b) {return b - a;});\n  if (localList.length % 2 === 0) {\n    return (localList[localList.length / 2 - 1] + localList[localList.length / 2]) / 2;\n  } else {\n    return localList[(localList.length - 1) / 2];\n  }\n}\n`,\n      );\n      list = generator.valueToCode(block, 'LIST', Order.NONE) || '[]';\n      code = functionName + '(' + list + ')';\n      break;\n    }\n    case 'MODE': {\n      // As a list of numbers can contain more than one mode,\n      // the returned result is provided as an array.\n      // Mode of [3, 'x', 'x', 1, 1, 2, '3'] -> ['x', 1].\n      const functionName = generator.provideFunction_(\n        'mathModes',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(values) {\n  var modes = [];\n  var counts = [];\n  var maxCount = 0;\n  for (var i = 0; i < values.length; i++) {\n    var value = values[i];\n    var found = false;\n    var thisCount;\n    for (var j = 0; j < counts.length; j++) {\n      if (counts[j][0] === value) {\n        thisCount = ++counts[j][1];\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      counts.push([value, 1]);\n      thisCount = 1;\n    }\n    maxCount = Math.max(thisCount, maxCount);\n  }\n  for (var j = 0; j < counts.length; j++) {\n    if (counts[j][1] === maxCount) {\n      modes.push(counts[j][0]);\n    }\n  }\n  return modes;\n}\n`,\n      );\n      list = generator.valueToCode(block, 'LIST', Order.NONE) || '[]';\n      code = functionName + '(' + list + ')';\n      break;\n    }\n    case 'STD_DEV': {\n      const functionName = generator.provideFunction_(\n        'mathStandardDeviation',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(numbers) {\n  var n = numbers.length;\n  if (!n) return null;\n  var mean = numbers.reduce(function(x, y) {return x + y;}) / n;\n  var variance = 0;\n  for (var j = 0; j < n; j++) {\n    variance += Math.pow(numbers[j] - mean, 2);\n  }\n  variance /= n;\n  return Math.sqrt(variance);\n}\n`,\n      );\n      list = generator.valueToCode(block, 'LIST', Order.NONE) || '[]';\n      code = functionName + '(' + list + ')';\n      break;\n    }\n    case 'RANDOM': {\n      const functionName = generator.provideFunction_(\n        'mathRandomList',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(list) {\n  var x = Math.floor(Math.random() * list.length);\n  return list[x];\n}\n`,\n      );\n      list = generator.valueToCode(block, 'LIST', Order.NONE) || '[]';\n      code = functionName + '(' + list + ')';\n      break;\n    }\n    default:\n      throw Error('Unknown operator: ' + func);\n  }\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function math_modulo(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Remainder computation.\n  const argument0 =\n    generator.valueToCode(block, 'DIVIDEND', Order.MODULUS) || '0';\n  const argument1 =\n    generator.valueToCode(block, 'DIVISOR', Order.MODULUS) || '0';\n  const code = argument0 + ' % ' + argument1;\n  return [code, Order.MODULUS];\n}\n\nexport function math_constrain(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Constrain a number between two limits.\n  const argument0 = generator.valueToCode(block, 'VALUE', Order.NONE) || '0';\n  const argument1 = generator.valueToCode(block, 'LOW', Order.NONE) || '0';\n  const argument2 =\n    generator.valueToCode(block, 'HIGH', Order.NONE) || 'Infinity';\n  const code =\n    'Math.min(Math.max(' +\n    argument0 +\n    ', ' +\n    argument1 +\n    '), ' +\n    argument2 +\n    ')';\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function math_random_int(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Random integer between [X] and [Y].\n  const argument0 = generator.valueToCode(block, 'FROM', Order.NONE) || '0';\n  const argument1 = generator.valueToCode(block, 'TO', Order.NONE) || '0';\n  const functionName = generator.provideFunction_(\n    'mathRandomInt',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(a, b) {\n  if (a > b) {\n    // Swap a and b to ensure a is smaller.\n    var c = a;\n    a = b;\n    b = c;\n  }\n  return Math.floor(Math.random() * (b - a + 1) + a);\n}\n`,\n  );\n  const code = functionName + '(' + argument0 + ', ' + argument1 + ')';\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function math_random_float(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Random fraction between 0 and 1.\n  return ['Math.random()', Order.FUNCTION_CALL];\n}\n\nexport function math_atan2(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Arctangent of point (X, Y) in degrees from -180 to 180.\n  const argument0 = generator.valueToCode(block, 'X', Order.NONE) || '0';\n  const argument1 = generator.valueToCode(block, 'Y', Order.NONE) || '0';\n  return [\n    'Math.atan2(' + argument1 + ', ' + argument0 + ') / Math.PI * 180',\n    Order.DIVISION,\n  ];\n}\n", "/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating JavaScript for procedure blocks.\n */\n\n// Former goog.module ID: Blockly.JavaScript.procedures\n\nimport type {IfReturnBlock} from '../../blocks/procedures.js';\nimport type {Block} from '../../core/block.js';\nimport type {JavascriptGenerator} from './javascript_generator.js';\nimport {Order} from './javascript_generator.js';\n\nexport function procedures_defreturn(\n  block: Block,\n  generator: JavascriptGenerator,\n) {\n  // Define a procedure with a return value.\n  const funcName = generator.getProcedureName(block.getFieldValue('NAME'));\n  let xfix1 = '';\n  if (generator.STATEMENT_PREFIX) {\n    xfix1 += generator.injectId(generator.STATEMENT_PREFIX, block);\n  }\n  if (generator.STATEMENT_SUFFIX) {\n    xfix1 += generator.injectId(generator.STATEMENT_SUFFIX, block);\n  }\n  if (xfix1) {\n    xfix1 = generator.prefixLines(xfix1, generator.INDENT);\n  }\n  let loopTrap = '';\n  if (generator.INFINITE_LOOP_TRAP) {\n    loopTrap = generator.prefixLines(\n      generator.injectId(generator.INFINITE_LOOP_TRAP, block),\n      generator.INDENT,\n    );\n  }\n  let branch = '';\n  if (block.getInput('STACK')) {\n    // The 'procedures_defreturn' block might not have a STACK input.\n    branch = generator.statementToCode(block, 'STACK');\n  }\n  let returnValue = '';\n  if (block.getInput('RETURN')) {\n    // The 'procedures_defnoreturn' block (which shares this code)\n    // does not have a RETURN input.\n    returnValue = generator.valueToCode(block, 'RETURN', Order.NONE) || '';\n  }\n  let xfix2 = '';\n  if (branch && returnValue) {\n    // After executing the function body, revisit this block for the return.\n    xfix2 = xfix1;\n  }\n  if (returnValue) {\n    returnValue = generator.INDENT + 'return ' + returnValue + ';\\n';\n  }\n  const args = [];\n  const variables = block.getVars();\n  for (let i = 0; i < variables.length; i++) {\n    args[i] = generator.getVariableName(variables[i]);\n  }\n  let code =\n    'function ' +\n    funcName +\n    '(' +\n    args.join(', ') +\n    ') {\\n' +\n    xfix1 +\n    loopTrap +\n    branch +\n    xfix2 +\n    returnValue +\n    '}';\n  code = generator.scrub_(block, code);\n  // Add % so as not to collide with helper functions in definitions list.\n  // TODO(#7600): find better approach than casting to any to override\n  // CodeGenerator declaring .definitions protected.\n  (generator as AnyDuringMigration).definitions_['%' + funcName] = code;\n  return null;\n}\n\n// Defining a procedure without a return value uses the same generator as\n// a procedure with a return value.\nexport const procedures_defnoreturn = procedures_defreturn;\n\nexport function procedures_callreturn(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Call a procedure with a return value.\n  const funcName = generator.getProcedureName(block.getFieldValue('NAME'));\n  const args = [];\n  const variables = block.getVars();\n  for (let i = 0; i < variables.length; i++) {\n    args[i] = generator.valueToCode(block, 'ARG' + i, Order.NONE) || 'null';\n  }\n  const code = funcName + '(' + args.join(', ') + ')';\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function procedures_callnoreturn(\n  block: Block,\n  generator: JavascriptGenerator,\n) {\n  // Call a procedure with no return value.\n  // Generated code is for a function call as a statement is the same as a\n  // function call as a value, with the addition of line ending.\n  const tuple = generator.forBlock['procedures_callreturn'](\n    block,\n    generator,\n  ) as [string, Order];\n  return tuple[0] + ';\\n';\n}\n\nexport function procedures_ifreturn(\n  block: Block,\n  generator: JavascriptGenerator,\n) {\n  // Conditionally return value from a procedure.\n  const condition =\n    generator.valueToCode(block, 'CONDITION', Order.NONE) || 'false';\n  let code = 'if (' + condition + ') {\\n';\n  if (generator.STATEMENT_SUFFIX) {\n    // Inject any statement suffix here since the regular one at the end\n    // will not get executed if the return is triggered.\n    code += generator.prefixLines(\n      generator.injectId(generator.STATEMENT_SUFFIX, block),\n      generator.INDENT,\n    );\n  }\n  if ((block as IfReturnBlock).hasReturnValue_) {\n    const value = generator.valueToCode(block, 'VALUE', Order.NONE) || 'null';\n    code += generator.INDENT + 'return ' + value + ';\\n';\n  } else {\n    code += generator.INDENT + 'return;\\n';\n  }\n  code += '}\\n';\n  return code;\n}\n", "/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating JavaScript for text blocks.\n */\n\n// Former goog.module ID: Blockly.JavaScript.texts\n\nimport type {JoinMutatorBlock} from '../../blocks/text.js';\nimport type {Block} from '../../core/block.js';\nimport type {JavascriptGenerator} from './javascript_generator.js';\nimport {Order} from './javascript_generator.js';\n\n/**\n * Regular expression to detect a single-quoted string literal.\n */\nconst strRegExp = /^\\s*'([^']|\\\\')*'\\s*$/;\n\n/**\n * Enclose the provided value in 'String(...)' function.\n * Leave string literals alone.\n * @param value Code evaluating to a value.\n * @returns Array containing code evaluating to a string\n *     and the order of the returned code.[string, number]\n */\nconst forceString = function (value: string): [string, Order] {\n  if (strRegExp.test(value)) {\n    return [value, Order.ATOMIC];\n  }\n  return ['String(' + value + ')', Order.FUNCTION_CALL];\n};\n\n/**\n * Returns an expression calculating the index into a string.\n * @param stringName Name of the string, used to calculate length.\n * @param where The method of indexing, selected by dropdown in Blockly\n * @param opt_at The optional offset when indexing from start/end.\n * @returns Index expression.\n */\nconst getSubstringIndex = function (\n  stringName: string,\n  where: string,\n  opt_at?: string,\n): string | undefined {\n  if (where === 'FIRST') {\n    return '0';\n  } else if (where === 'FROM_END') {\n    return stringName + '.length - 1 - ' + opt_at;\n  } else if (where === 'LAST') {\n    return stringName + '.length - 1';\n  } else {\n    return opt_at;\n  }\n};\n\nexport function text(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Text value.\n  const code = generator.quote_(block.getFieldValue('TEXT'));\n  return [code, Order.ATOMIC];\n}\n\nexport function text_join(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Create a string made up of any number of elements of any type.\n  const joinBlock = block as JoinMutatorBlock;\n  switch (joinBlock.itemCount_) {\n    case 0:\n      return [\"''\", Order.ATOMIC];\n    case 1: {\n      const element =\n        generator.valueToCode(joinBlock, 'ADD0', Order.NONE) || \"''\";\n      const codeAndOrder = forceString(element);\n      return codeAndOrder;\n    }\n    case 2: {\n      const element0 =\n        generator.valueToCode(joinBlock, 'ADD0', Order.NONE) || \"''\";\n      const element1 =\n        generator.valueToCode(joinBlock, 'ADD1', Order.NONE) || \"''\";\n      const code = forceString(element0)[0] + ' + ' + forceString(element1)[0];\n      return [code, Order.ADDITION];\n    }\n    default: {\n      const elements = new Array(joinBlock.itemCount_);\n      for (let i = 0; i < joinBlock.itemCount_; i++) {\n        elements[i] =\n          generator.valueToCode(joinBlock, 'ADD' + i, Order.NONE) || \"''\";\n      }\n      const code = '[' + elements.join(',') + \"].join('')\";\n      return [code, Order.FUNCTION_CALL];\n    }\n  }\n}\n\nexport function text_append(block: Block, generator: JavascriptGenerator) {\n  // Append to a variable in place.\n  const varName = generator.getVariableName(block.getFieldValue('VAR'));\n  const value = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const code = varName + ' += ' + forceString(value)[0] + ';\\n';\n  return code;\n}\n\nexport function text_length(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // String or array length.\n  const text = generator.valueToCode(block, 'VALUE', Order.MEMBER) || \"''\";\n  return [text + '.length', Order.MEMBER];\n}\n\nexport function text_isEmpty(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Is the string null or array empty?\n  const text = generator.valueToCode(block, 'VALUE', Order.MEMBER) || \"''\";\n  return ['!' + text + '.length', Order.LOGICAL_NOT];\n}\n\nexport function text_indexOf(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Search the text for a substring.\n  const operator =\n    block.getFieldValue('END') === 'FIRST' ? 'indexOf' : 'lastIndexOf';\n  const substring = generator.valueToCode(block, 'FIND', Order.NONE) || \"''\";\n  const text = generator.valueToCode(block, 'VALUE', Order.MEMBER) || \"''\";\n  const code = text + '.' + operator + '(' + substring + ')';\n  // Adjust index if using one-based indices.\n  if (block.workspace.options.oneBasedIndex) {\n    return [code + ' + 1', Order.ADDITION];\n  }\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function text_charAt(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Get letter at index.\n  // Note: Until January 2013 this block did not have the WHERE input.\n  const where = block.getFieldValue('WHERE') || 'FROM_START';\n  const textOrder = where === 'RANDOM' ? Order.NONE : Order.MEMBER;\n  const text = generator.valueToCode(block, 'VALUE', textOrder) || \"''\";\n  switch (where) {\n    case 'FIRST': {\n      const code = text + '.charAt(0)';\n      return [code, Order.FUNCTION_CALL];\n    }\n    case 'LAST': {\n      const code = text + '.slice(-1)';\n      return [code, Order.FUNCTION_CALL];\n    }\n    case 'FROM_START': {\n      const at = generator.getAdjusted(block, 'AT');\n      // Adjust index if using one-based indices.\n      const code = text + '.charAt(' + at + ')';\n      return [code, Order.FUNCTION_CALL];\n    }\n    case 'FROM_END': {\n      const at = generator.getAdjusted(block, 'AT', 1, true);\n      const code = text + '.slice(' + at + ').charAt(0)';\n      return [code, Order.FUNCTION_CALL];\n    }\n    case 'RANDOM': {\n      const functionName = generator.provideFunction_(\n        'textRandomLetter',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(text) {\n  var x = Math.floor(Math.random() * text.length);\n  return text[x];\n}\n`,\n      );\n      const code = functionName + '(' + text + ')';\n      return [code, Order.FUNCTION_CALL];\n    }\n  }\n  throw Error('Unhandled option (text_charAt).');\n}\n\nexport function text_getSubstring(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Dictionary of WHEREn field choices and their CamelCase equivalents. */\n  const wherePascalCase = {\n    'FIRST': 'First',\n    'LAST': 'Last',\n    'FROM_START': 'FromStart',\n    'FROM_END': 'FromEnd',\n  };\n  type WhereOption = keyof typeof wherePascalCase;\n  // Get substring.\n  const where1 = block.getFieldValue('WHERE1') as WhereOption;\n  const where2 = block.getFieldValue('WHERE2') as WhereOption;\n  const requiresLengthCall =\n    where1 !== 'FROM_END' &&\n    where1 !== 'LAST' &&\n    where2 !== 'FROM_END' &&\n    where2 !== 'LAST';\n  const textOrder = requiresLengthCall ? Order.MEMBER : Order.NONE;\n  const text = generator.valueToCode(block, 'STRING', textOrder) || \"''\";\n  let code;\n  if (where1 === 'FIRST' && where2 === 'LAST') {\n    code = text;\n    return [code, Order.NONE];\n  } else if (text.match(/^'?\\w+'?$/) || requiresLengthCall) {\n    // If the text is a variable or literal or doesn't require a call for\n    // length, don't generate a helper function.\n    let at1;\n    switch (where1) {\n      case 'FROM_START':\n        at1 = generator.getAdjusted(block, 'AT1');\n        break;\n      case 'FROM_END':\n        at1 = generator.getAdjusted(block, 'AT1', 1, false, Order.SUBTRACTION);\n        at1 = text + '.length - ' + at1;\n        break;\n      case 'FIRST':\n        at1 = '0';\n        break;\n      default:\n        throw Error('Unhandled option (text_getSubstring).');\n    }\n    let at2;\n    switch (where2) {\n      case 'FROM_START':\n        at2 = generator.getAdjusted(block, 'AT2', 1);\n        break;\n      case 'FROM_END':\n        at2 = generator.getAdjusted(block, 'AT2', 0, false, Order.SUBTRACTION);\n        at2 = text + '.length - ' + at2;\n        break;\n      case 'LAST':\n        at2 = text + '.length';\n        break;\n      default:\n        throw Error('Unhandled option (text_getSubstring).');\n    }\n    code = text + '.slice(' + at1 + ', ' + at2 + ')';\n  } else {\n    const at1 = generator.getAdjusted(block, 'AT1');\n    const at2 = generator.getAdjusted(block, 'AT2');\n    // The value for 'FROM_END' and'FROM_START' depends on `at` so\n    // we add it as a parameter.\n    const at1Param =\n      where1 === 'FROM_END' || where1 === 'FROM_START' ? ', at1' : '';\n    const at2Param =\n      where2 === 'FROM_END' || where2 === 'FROM_START' ? ', at2' : '';\n    const functionName = generator.provideFunction_(\n      'subsequence' + wherePascalCase[where1] + wherePascalCase[where2],\n      `\nfunction ${\n        generator.FUNCTION_NAME_PLACEHOLDER_\n      }(sequence${at1Param}${at2Param}) {\n  var start = ${getSubstringIndex('sequence', where1, 'at1')};\n  var end = ${getSubstringIndex('sequence', where2, 'at2')} + 1;\n  return sequence.slice(start, end);\n}\n`,\n    );\n    code =\n      functionName +\n      '(' +\n      text +\n      // The value for 'FROM_END' and 'FROM_START' depends on `at` so we\n      // pass it.\n      (where1 === 'FROM_END' || where1 === 'FROM_START' ? ', ' + at1 : '') +\n      (where2 === 'FROM_END' || where2 === 'FROM_START' ? ', ' + at2 : '') +\n      ')';\n  }\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function text_changeCase(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Change capitalization.\n  const OPERATORS = {\n    'UPPERCASE': '.toUpperCase()',\n    'LOWERCASE': '.toLowerCase()',\n    'TITLECASE': null,\n  };\n  type OperatorOption = keyof typeof OPERATORS;\n  const operator = OPERATORS[block.getFieldValue('CASE') as OperatorOption];\n  const textOrder = operator ? Order.MEMBER : Order.NONE;\n  const text = generator.valueToCode(block, 'TEXT', textOrder) || \"''\";\n  let code;\n  if (operator) {\n    // Upper and lower case are functions built into generator.\n    code = text + operator;\n  } else {\n    // Title case is not a native JavaScript function.  Define one.\n    const functionName = generator.provideFunction_(\n      'textToTitleCase',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(str) {\n  return str.replace(/\\\\S+/g,\n      function(txt) {return txt[0].toUpperCase() + txt.substring(1).toLowerCase();});\n}\n`,\n    );\n    code = functionName + '(' + text + ')';\n  }\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function text_trim(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Trim spaces.\n  const OPERATORS = {\n    'LEFT': \".replace(/^[\\\\s\\\\xa0]+/, '')\",\n    'RIGHT': \".replace(/[\\\\s\\\\xa0]+$/, '')\",\n    'BOTH': '.trim()',\n  };\n  type OperatorOption = keyof typeof OPERATORS;\n  const operator = OPERATORS[block.getFieldValue('MODE') as OperatorOption];\n  const text = generator.valueToCode(block, 'TEXT', Order.MEMBER) || \"''\";\n  return [text + operator, Order.FUNCTION_CALL];\n}\n\nexport function text_print(block: Block, generator: JavascriptGenerator) {\n  // Print statement.\n  const msg = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  return 'window.alert(' + msg + ');\\n';\n}\n\nexport function text_prompt_ext(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Prompt function.\n  let msg;\n  if (block.getField('TEXT')) {\n    // Internal message.\n    msg = generator.quote_(block.getFieldValue('TEXT'));\n  } else {\n    // External message.\n    msg = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  }\n  let code = 'window.prompt(' + msg + ')';\n  const toNumber = block.getFieldValue('TYPE') === 'NUMBER';\n  if (toNumber) {\n    code = 'Number(' + code + ')';\n  }\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport const text_prompt = text_prompt_ext;\n\nexport function text_count(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const sub = generator.valueToCode(block, 'SUB', Order.NONE) || \"''\";\n  const functionName = generator.provideFunction_(\n    'textCount',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(haystack, needle) {\n  if (needle.length === 0) {\n    return haystack.length + 1;\n  } else {\n    return haystack.split(needle).length - 1;\n  }\n}\n`,\n  );\n  const code = functionName + '(' + text + ', ' + sub + ')';\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function text_replace(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const from = generator.valueToCode(block, 'FROM', Order.NONE) || \"''\";\n  const to = generator.valueToCode(block, 'TO', Order.NONE) || \"''\";\n  // The regex escaping code below is taken from the implementation of\n  // goog.string.regExpEscape.\n  const functionName = generator.provideFunction_(\n    'textReplace',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(haystack, needle, replacement) {\n  needle = needle.replace(/([-()\\\\[\\\\]{}+?*.$\\\\^|,:#<!\\\\\\\\])/g, '\\\\\\\\$1')\n                 .replace(/\\\\x08/g, '\\\\\\\\x08');\n  return haystack.replace(new RegExp(needle, 'g'), replacement);\n}\n`,\n  );\n  const code = functionName + '(' + text + ', ' + from + ', ' + to + ')';\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function text_reverse(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  const text = generator.valueToCode(block, 'TEXT', Order.MEMBER) || \"''\";\n  const code = text + \".split('').reverse().join('')\";\n  return [code, Order.FUNCTION_CALL];\n}\n", "/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating JavaScript for variable blocks.\n */\n\n// Former goog.module ID: Blockly.JavaScript.variables\n\nimport type {Block} from '../../core/block.js';\nimport type {JavascriptGenerator} from './javascript_generator.js';\nimport {Order} from './javascript_generator.js';\n\nexport function variables_get(\n  block: Block,\n  generator: JavascriptGenerator,\n): [string, Order] {\n  // Variable getter.\n  const code = generator.getVariableName(block.getFieldValue('VAR'));\n  return [code, Order.ATOMIC];\n}\n\nexport function variables_set(block: Block, generator: JavascriptGenerator) {\n  // Variable setter.\n  const argument0 =\n    generator.valueToCode(block, 'VALUE', Order.ASSIGNMENT) || '0';\n  const varName = generator.getVariableName(block.getFieldValue('VAR'));\n  return varName + ' = ' + argument0 + ';\\n';\n}\n", "/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file JavaScript code generator class, including helper methods for\n * generating JavaScript for blocks.\n */\n\n// Former goog.module ID: Blockly.JavaScript\n\nimport type {Block} from '../../core/block.js';\nimport {CodeGenerator} from '../../core/generator.js';\nimport {inputTypes} from '../../core/inputs/input_types.js';\nimport {Names, NameType} from '../../core/names.js';\nimport * as stringUtils from '../../core/utils/string.js';\nimport * as Variables from '../../core/variables.js';\nimport type {Workspace} from '../../core/workspace.js';\n\n/**\n * Order of operation ENUMs.\n * https://developer.mozilla.org/en/JavaScript/Reference/Operators/Operator_Precedence\n */\n// prettier-ignore\nexport enum Order {\n  ATOMIC = 0,            // 0 \"\" ...\n  NEW = 1.1,             // new\n  MEMBER = 1.2,          // . []\n  FUNCTION_CALL = 2,     // ()\n  INCREMENT = 3,         // ++\n  DECREMENT = 3,         // --\n  BITWISE_NOT = 4.1,     // ~\n  UNARY_PLUS = 4.2,      // +\n  UNARY_NEGATION = 4.3,  // -\n  LOGICAL_NOT = 4.4,     // !\n  TYPEOF = 4.5,          // typeof\n  VOID = 4.6,            // void\n  DELETE = 4.7,          // delete\n  AWAIT = 4.8,           // await\n  EXPONENTIATION = 5.0,  // **\n  MULTIPLICATION = 5.1,  // *\n  DIVISION = 5.2,        // /\n  MODULUS = 5.3,         // %\n  SUBTRACTION = 6.1,     // -\n  ADDITION = 6.2,        // +\n  BITWISE_SHIFT = 7,     // << >> >>>\n  RELATIONAL = 8,        // < <= > >=\n  IN = 8,                // in\n  INSTANCEOF = 8,        // instanceof\n  EQUALITY = 9,          // == != === !==\n  BITWISE_AND = 10,      // &\n  BITWISE_XOR = 11,      // ^\n  BITWISE_OR = 12,       // |\n  LOGICAL_AND = 13,      // &&\n  LOGICAL_OR = 14,       // ||\n  CONDITIONAL = 15,      // ?:\n  ASSIGNMENT = 16,       // = += -= **= *= /= %= <<= >>= ...\n  YIELD = 17,            // yield\n  COMMA = 18,            // ,\n  NONE = 99,             // (...)\n}\n\n/**\n * JavaScript code generator class.\n */\nexport class JavascriptGenerator extends CodeGenerator {\n  /** List of outer-inner pairings that do NOT require parentheses. */\n  ORDER_OVERRIDES: [Order, Order][] = [\n    // (foo()).bar -> foo().bar\n    // (foo())[0] -> foo()[0]\n    [Order.FUNCTION_CALL, Order.MEMBER],\n    // (foo())() -> foo()()\n    [Order.FUNCTION_CALL, Order.FUNCTION_CALL],\n    // (foo.bar).baz -> foo.bar.baz\n    // (foo.bar)[0] -> foo.bar[0]\n    // (foo[0]).bar -> foo[0].bar\n    // (foo[0])[1] -> foo[0][1]\n    [Order.MEMBER, Order.MEMBER],\n    // (foo.bar)() -> foo.bar()\n    // (foo[0])() -> foo[0]()\n    [Order.MEMBER, Order.FUNCTION_CALL],\n\n    // !(!foo) -> !!foo\n    [Order.LOGICAL_NOT, Order.LOGICAL_NOT],\n    // a * (b * c) -> a * b * c\n    [Order.MULTIPLICATION, Order.MULTIPLICATION],\n    // a + (b + c) -> a + b + c\n    [Order.ADDITION, Order.ADDITION],\n    // a && (b && c) -> a && b && c\n    [Order.LOGICAL_AND, Order.LOGICAL_AND],\n    // a || (b || c) -> a || b || c\n    [Order.LOGICAL_OR, Order.LOGICAL_OR],\n  ];\n\n  /** @param name Name of the language the generator is for. */\n  constructor(name = 'JavaScript') {\n    super(name);\n    this.isInitialized = false;\n\n    // Copy Order values onto instance for backwards compatibility\n    // while ensuring they are not part of the publically-advertised\n    // API.\n    //\n    // TODO(#7085): deprecate these in due course.  (Could initially\n    // replace data properties with get accessors that call\n    // deprecate.warn().)\n    for (const key in Order) {\n      // Must assign Order[key] to a temporary to get the type guard to work;\n      // see https://github.com/microsoft/TypeScript/issues/10530.\n      const value = Order[key];\n      // Skip reverse-lookup entries in the enum.  Due to\n      // https://github.com/microsoft/TypeScript/issues/55713 this (as\n      // of TypeScript 5.5.2) actually narrows the type of value to\n      // never - but that still allows the following assignment to\n      // succeed.\n      if (typeof value === 'string') continue;\n      (this as unknown as Record<string, Order>)['ORDER_' + key] = value;\n    }\n\n    // List of illegal variable names.  This is not intended to be a\n    // security feature.  Blockly is 100% client-side, so bypassing\n    // this list is trivial.  This is intended to prevent users from\n    // accidentally clobbering a built-in object or function.\n    //\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords\n    this.addReservedWords(\n      'break,case,catch,class,const,continue,debugger,default,delete,do,' +\n        'else,export,extends,finally,for,function,if,import,in,instanceof,' +\n        'new,return,super,switch,this,throw,try,typeof,var,void,' +\n        'while,with,yield,' +\n        'enum,' +\n        'implements,interface,let,package,private,protected,public,static,' +\n        'await,' +\n        'null,true,false,' +\n        // Magic variable.\n        'arguments,' +\n        // Everything in the current environment (835 items in Chrome,\n        // 104 in Node).\n        Object.getOwnPropertyNames(globalThis).join(','),\n    );\n  }\n\n  /**\n   * Initialise the database of variable names.\n   *\n   * @param workspace Workspace to generate code from.\n   */\n  init(workspace: Workspace) {\n    super.init(workspace);\n\n    if (!this.nameDB_) {\n      this.nameDB_ = new Names(this.RESERVED_WORDS_);\n    } else {\n      this.nameDB_.reset();\n    }\n\n    this.nameDB_.setVariableMap(workspace.getVariableMap());\n    this.nameDB_.populateVariables(workspace);\n    this.nameDB_.populateProcedures(workspace);\n\n    const defvars = [];\n    // Add developer variables (not created or named by the user).\n    const devVarList = Variables.allDeveloperVariables(workspace);\n    for (let i = 0; i < devVarList.length; i++) {\n      defvars.push(\n        this.nameDB_.getName(devVarList[i], NameType.DEVELOPER_VARIABLE),\n      );\n    }\n\n    // Add user variables, but only ones that are being used.\n    const variables = Variables.allUsedVarModels(workspace);\n    for (let i = 0; i < variables.length; i++) {\n      defvars.push(\n        this.nameDB_.getName(variables[i].getId(), NameType.VARIABLE),\n      );\n    }\n\n    // Declare all of the variables.\n    if (defvars.length) {\n      this.definitions_['variables'] = 'var ' + defvars.join(', ') + ';';\n    }\n    this.isInitialized = true;\n  }\n\n  /**\n   * Prepend the generated code with the variable definitions.\n   *\n   * @param code Generated code.\n   * @returns Completed code.\n   */\n  finish(code: string): string {\n    // Convert the definitions dictionary into a list.\n    const definitions = Object.values(this.definitions_);\n    // Call Blockly.CodeGenerator's finish.\n    super.finish(code);\n    this.isInitialized = false;\n\n    this.nameDB_!.reset();\n    return definitions.join('\\n\\n') + '\\n\\n\\n' + code;\n  }\n\n  /**\n   * Naked values are top-level blocks with outputs that aren't plugged into\n   * anything.  A trailing semicolon is needed to make this legal.\n   *\n   * @param line Line of generated code.\n   * @returns Legal line of code.\n   */\n  scrubNakedValue(line: string): string {\n    return line + ';\\n';\n  }\n\n  /**\n   * Encode a string as a properly escaped JavaScript string, complete with\n   * quotes.\n   *\n   * @param string Text to encode.\n   * @returns JavaScript string.\n   */\n  quote_(string: string): string {\n    // Can't use goog.string.quote since Google's style guide recommends\n    // JS string literals use single quotes.\n    string = string\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\n/g, '\\\\\\n')\n      .replace(/'/g, \"\\\\'\");\n    return \"'\" + string + \"'\";\n  }\n\n  /**\n   * Encode a string as a properly escaped multiline JavaScript string, complete\n   * with quotes.\n   * @param string Text to encode.\n   * @returns JavaScript string.\n   */\n  multiline_quote_(string: string): string {\n    // Can't use goog.string.quote since Google's style guide recommends\n    // JS string literals use single quotes.\n    const lines = string.split(/\\n/g).map(this.quote_);\n    return lines.join(\" + '\\\\n' +\\n\");\n  }\n\n  /**\n   * Common tasks for generating JavaScript from blocks.\n   * Handles comments for the specified block and any connected value blocks.\n   * Calls any statements following this block.\n   *\n   * @param block The current block.\n   * @param code The JavaScript code created for this block.\n   * @param thisOnly True to generate code for only this statement.\n   * @returns JavaScript code with comments and subsequent blocks added.\n   */\n  scrub_(block: Block, code: string, thisOnly = false): string {\n    let commentCode = '';\n    // Only collect comments for blocks that aren't inline.\n    if (!block.outputConnection || !block.outputConnection.targetConnection) {\n      // Collect comment for this block.\n      let comment = block.getCommentText();\n      if (comment) {\n        comment = stringUtils.wrap(comment, this.COMMENT_WRAP - 3);\n        commentCode += this.prefixLines(comment + '\\n', '// ');\n      }\n      // Collect comments for all value arguments.\n      // Don't collect comments for nested statements.\n      for (let i = 0; i < block.inputList.length; i++) {\n        if (block.inputList[i].type === inputTypes.VALUE) {\n          const childBlock = block.inputList[i].connection!.targetBlock();\n          if (childBlock) {\n            comment = this.allNestedComments(childBlock);\n            if (comment) {\n              commentCode += this.prefixLines(comment, '// ');\n            }\n          }\n        }\n      }\n    }\n    const nextBlock =\n      block.nextConnection && block.nextConnection.targetBlock();\n    const nextCode = thisOnly ? '' : this.blockToCode(nextBlock);\n    return commentCode + code + nextCode;\n  }\n\n  /**\n   * Generate code representing the specified value input, adjusted to take into\n   * account indexing (zero- or one-based) and optionally by a specified delta\n   * and/or by negation.\n   *\n   * @param block The block.\n   * @param atId The ID of the input block to get (and adjust) the value of.\n   * @param delta Value to add.\n   * @param negate Whether to negate the value.\n   * @param order The highest order acting on this value.\n   * @returns The adjusted value or code that evaluates to it.\n   */\n  getAdjusted(\n    block: Block,\n    atId: string,\n    delta = 0,\n    negate = false,\n    order = Order.NONE,\n  ): string {\n    if (block.workspace.options.oneBasedIndex) {\n      delta--;\n    }\n    const defaultAtIndex = block.workspace.options.oneBasedIndex ? '1' : '0';\n\n    let orderForInput = order;\n    if (delta > 0) {\n      orderForInput = Order.ADDITION;\n    } else if (delta < 0) {\n      orderForInput = Order.SUBTRACTION;\n    } else if (negate) {\n      orderForInput = Order.UNARY_NEGATION;\n    }\n\n    let at = this.valueToCode(block, atId, orderForInput) || defaultAtIndex;\n\n    // Easy case: no adjustments.\n    if (delta === 0 && !negate) {\n      return at;\n    }\n    // If the index is a naked number, adjust it right now.\n    if (stringUtils.isNumber(at)) {\n      at = String(Number(at) + delta);\n      if (negate) {\n        at = String(-Number(at));\n      }\n      return at;\n    }\n    // If the index is dynamic, adjust it in code.\n    if (delta > 0) {\n      at = `${at} + ${delta}`;\n    } else if (delta < 0) {\n      at = `${at} - ${-delta}`;\n    }\n    if (negate) {\n      at = delta ? `-(${at})` : `-${at}`;\n    }\n    if (Math.floor(order) >= Math.floor(orderForInput)) {\n      at = `(${at})`;\n    }\n    return at;\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating JavaScript for dynamic variable blocks.\n */\n\n// Former goog.module ID: Blockly.JavaScript.variablesDynamic\n\n// JavaScript is dynamically typed.\nexport {\n  variables_get as variables_get_dynamic,\n  variables_set as variables_set_dynamic,\n} from './variables.js';\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Instantiate a JavascriptGenerator and populate it with the\n * complete set of block generator functions for JavaScript.  This is\n * the entrypoint for javascript_compressed.js.\n */\n\n// Former goog.module ID: Blockly.JavaScript.all\n\nimport {JavascriptGenerator} from './javascript/javascript_generator.js';\nimport * as lists from './javascript/lists.js';\nimport * as logic from './javascript/logic.js';\nimport * as loops from './javascript/loops.js';\nimport * as math from './javascript/math.js';\nimport * as procedures from './javascript/procedures.js';\nimport * as text from './javascript/text.js';\nimport * as variables from './javascript/variables.js';\nimport * as variablesDynamic from './javascript/variables_dynamic.js';\n\nexport * from './javascript/javascript_generator.js';\n\n/**\n * JavaScript code generator instance.\n * @type {!JavascriptGenerator}\n */\nexport const javascriptGenerator = new JavascriptGenerator();\n\n// Install per-block-type generator functions:\nconst generators: typeof javascriptGenerator.forBlock = {\n  ...lists,\n  ...logic,\n  ...loops,\n  ...math,\n  ...procedures,\n  ...text,\n  ...variables,\n  ...variablesDynamic,\n};\nfor (const name in generators) {\n  javascriptGenerator.forBlock[name] = generators[name];\n}\n", "/**\n * @license\n * Copyright 2014 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Dart for list blocks.\n */\n\n// Former goog.module ID: Blockly.Dart.lists\n\nimport type {CreateWithBlock} from '../../blocks/lists.js';\nimport type {Block} from '../../core/block.js';\nimport {NameType} from '../../core/names.js';\nimport type {DartGenerator} from './dart_generator.js';\nimport {Order} from './dart_generator.js';\n\n// RESERVED WORDS: 'Math'\n\nexport function lists_create_empty(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Create an empty list.\n  return ['[]', Order.ATOMIC];\n}\n\nexport function lists_create_with(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Create a list with any number of elements of any type.\n  const createWithBlock = block as CreateWithBlock;\n  const elements = new Array(createWithBlock.itemCount_);\n  for (let i = 0; i < createWithBlock.itemCount_; i++) {\n    elements[i] = generator.valueToCode(block, 'ADD' + i, Order.NONE) || 'null';\n  }\n  const code = '[' + elements.join(', ') + ']';\n  return [code, Order.ATOMIC];\n}\n\nexport function lists_repeat(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Create a list with one element repeated.\n  const element = generator.valueToCode(block, 'ITEM', Order.NONE) || 'null';\n  const repeatCount = generator.valueToCode(block, 'NUM', Order.NONE) || '0';\n  const code = 'new List.filled(' + repeatCount + ', ' + element + ')';\n  return [code, Order.UNARY_POSTFIX];\n}\n\nexport function lists_length(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // String or array length.\n  const list =\n    generator.valueToCode(block, 'VALUE', Order.UNARY_POSTFIX) || '[]';\n  return [list + '.length', Order.UNARY_POSTFIX];\n}\n\nexport function lists_isEmpty(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Is the string null or array empty?\n  const list =\n    generator.valueToCode(block, 'VALUE', Order.UNARY_POSTFIX) || '[]';\n  return [list + '.isEmpty', Order.UNARY_POSTFIX];\n}\n\nexport function lists_indexOf(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Find an item in the list.\n  const operator =\n    block.getFieldValue('END') === 'FIRST' ? 'indexOf' : 'lastIndexOf';\n  const item = generator.valueToCode(block, 'FIND', Order.NONE) || \"''\";\n  const list =\n    generator.valueToCode(block, 'VALUE', Order.UNARY_POSTFIX) || '[]';\n  const code = list + '.' + operator + '(' + item + ')';\n  if (block.workspace.options.oneBasedIndex) {\n    return [code + ' + 1', Order.ADDITIVE];\n  }\n  return [code, Order.UNARY_POSTFIX];\n}\n\nexport function lists_getIndex(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] | string {\n  // Get element at index.\n  // Note: Until January 2013 this block did not have MODE or WHERE inputs.\n  const mode = block.getFieldValue('MODE') || 'GET';\n  const where = block.getFieldValue('WHERE') || 'FROM_START';\n  const listOrder =\n    where === 'RANDOM' || where === 'FROM_END'\n      ? Order.NONE\n      : Order.UNARY_POSTFIX;\n  let list = generator.valueToCode(block, 'VALUE', listOrder) || '[]';\n  // Cache non-trivial values to variables to prevent repeated look-ups.\n  // Closure, which accesses and modifies 'list'.\n  function cacheList() {\n    const listVar = generator.nameDB_!.getDistinctName(\n      'tmp_list',\n      NameType.VARIABLE,\n    );\n    const code = 'List ' + listVar + ' = ' + list + ';\\n';\n    list = listVar;\n    return code;\n  }\n  // If `list` would be evaluated more than once (which is the case for\n  // RANDOM REMOVE and FROM_END) and is non-trivial, make sure to access it\n  // only once.\n  if (\n    ((where === 'RANDOM' && mode === 'REMOVE') || where === 'FROM_END') &&\n    !list.match(/^\\w+$/)\n  ) {\n    // `list` is an expression, so we may not evaluate it more than once.\n    if (where === 'RANDOM') {\n      // TODO(#7600): find better approach than casting to any to override\n      // CodeGenerator declaring .definitions protected.\n      (generator as AnyDuringMigration).definitions_['import_dart_math'] =\n        \"import 'dart:math' as Math;\";\n      // We can use multiple statements.\n      let code = cacheList();\n      const xVar = generator.nameDB_!.getDistinctName(\n        'tmp_x',\n        NameType.VARIABLE,\n      );\n      code +=\n        'int ' + xVar + ' = new Math.Random().nextInt(' + list + '.length);\\n';\n      code += list + '.removeAt(' + xVar + ');\\n';\n      return code;\n    } else {\n      // where === 'FROM_END'\n      if (mode === 'REMOVE') {\n        // We can use multiple statements.\n        const at = generator.getAdjusted(block, 'AT', 1, false, Order.ADDITIVE);\n        let code = cacheList();\n        code += list + '.removeAt(' + list + '.length' + ' - ' + at + ');\\n';\n        return code;\n      } else if (mode === 'GET') {\n        const at = generator.getAdjusted(block, 'AT', 1);\n        // We need to create a procedure to avoid reevaluating values.\n        const functionName = generator.provideFunction_(\n          'lists_get_from_end',\n          `\ndynamic ${generator.FUNCTION_NAME_PLACEHOLDER_}(List my_list, num x) {\n  x = my_list.length - x;\n  return my_list[x];\n}\n`,\n        );\n        const code = functionName + '(' + list + ', ' + at + ')';\n        return [code, Order.UNARY_POSTFIX];\n      } else if (mode === 'GET_REMOVE') {\n        const at = generator.getAdjusted(block, 'AT', 1);\n        // We need to create a procedure to avoid reevaluating values.\n        const functionName = generator.provideFunction_(\n          'lists_remove_from_end',\n          `\ndynamic ${generator.FUNCTION_NAME_PLACEHOLDER_}(List my_list, num x) {\n  x = my_list.length - x;\n  return my_list.removeAt(x);\n}\n`,\n        );\n        const code = functionName + '(' + list + ', ' + at + ')';\n        return [code, Order.UNARY_POSTFIX];\n      }\n    }\n  } else {\n    // Either `list` is a simple variable, or we only need to refer to `list`\n    // once.\n    switch (where) {\n      case 'FIRST':\n        if (mode === 'GET') {\n          const code = list + '.first';\n          return [code, Order.UNARY_POSTFIX];\n        } else if (mode === 'GET_REMOVE') {\n          const code = list + '.removeAt(0)';\n          return [code, Order.UNARY_POSTFIX];\n        } else if (mode === 'REMOVE') {\n          return list + '.removeAt(0);\\n';\n        }\n        break;\n      case 'LAST':\n        if (mode === 'GET') {\n          const code = list + '.last';\n          return [code, Order.UNARY_POSTFIX];\n        } else if (mode === 'GET_REMOVE') {\n          const code = list + '.removeLast()';\n          return [code, Order.UNARY_POSTFIX];\n        } else if (mode === 'REMOVE') {\n          return list + '.removeLast();\\n';\n        }\n        break;\n      case 'FROM_START': {\n        const at = generator.getAdjusted(block, 'AT');\n        if (mode === 'GET') {\n          const code = list + '[' + at + ']';\n          return [code, Order.UNARY_POSTFIX];\n        } else if (mode === 'GET_REMOVE') {\n          const code = list + '.removeAt(' + at + ')';\n          return [code, Order.UNARY_POSTFIX];\n        } else if (mode === 'REMOVE') {\n          return list + '.removeAt(' + at + ');\\n';\n        }\n        break;\n      }\n      case 'FROM_END': {\n        const at = generator.getAdjusted(block, 'AT', 1, false, Order.ADDITIVE);\n        if (mode === 'GET') {\n          const code = list + '[' + list + '.length - ' + at + ']';\n          return [code, Order.UNARY_POSTFIX];\n        } else if (mode === 'GET_REMOVE' || mode === 'REMOVE') {\n          const code = list + '.removeAt(' + list + '.length - ' + at + ')';\n          if (mode === 'GET_REMOVE') {\n            return [code, Order.UNARY_POSTFIX];\n          } else if (mode === 'REMOVE') {\n            return code + ';\\n';\n          }\n        }\n        break;\n      }\n      case 'RANDOM':\n        // TODO(#7600): find better approach than casting to any to override\n        // CodeGenerator declaring .definitions protected.\n        (generator as AnyDuringMigration).definitions_['import_dart_math'] =\n          \"import 'dart:math' as Math;\";\n        if (mode === 'REMOVE') {\n          // We can use multiple statements.\n          const xVar = generator.nameDB_!.getDistinctName(\n            'tmp_x',\n            NameType.VARIABLE,\n          );\n          let code =\n            'int ' +\n            xVar +\n            ' = new Math.Random().nextInt(' +\n            list +\n            '.length);\\n';\n          code += list + '.removeAt(' + xVar + ');\\n';\n          return code;\n        } else if (mode === 'GET') {\n          const functionName = generator.provideFunction_(\n            'lists_get_random_item',\n            `\ndynamic ${generator.FUNCTION_NAME_PLACEHOLDER_}(List my_list) {\n  int x = new Math.Random().nextInt(my_list.length);\n  return my_list[x];\n}\n`,\n          );\n          const code = functionName + '(' + list + ')';\n          return [code, Order.UNARY_POSTFIX];\n        } else if (mode === 'GET_REMOVE') {\n          const functionName = generator.provideFunction_(\n            'lists_remove_random_item',\n            `\ndynamic ${generator.FUNCTION_NAME_PLACEHOLDER_}(List my_list) {\n  int x = new Math.Random().nextInt(my_list.length);\n  return my_list.removeAt(x);\n}\n`,\n          );\n          const code = functionName + '(' + list + ')';\n          return [code, Order.UNARY_POSTFIX];\n        }\n        break;\n    }\n  }\n  throw Error('Unhandled combination (lists_getIndex).');\n}\n\nexport function lists_setIndex(block: Block, generator: DartGenerator) {\n  // Set element at index.\n  // Note: Until February 2013 this block did not have MODE or WHERE inputs.\n  const mode = block.getFieldValue('MODE') || 'GET';\n  const where = block.getFieldValue('WHERE') || 'FROM_START';\n  let list = generator.valueToCode(block, 'LIST', Order.UNARY_POSTFIX) || '[]';\n  const value = generator.valueToCode(block, 'TO', Order.ASSIGNMENT) || 'null';\n  // Cache non-trivial values to variables to prevent repeated look-ups.\n  // Closure, which accesses and modifies 'list'.\n  function cacheList() {\n    if (list.match(/^\\w+$/)) {\n      return '';\n    }\n    const listVar = generator.nameDB_!.getDistinctName(\n      'tmp_list',\n      NameType.VARIABLE,\n    );\n    const code = 'List ' + listVar + ' = ' + list + ';\\n';\n    list = listVar;\n    return code;\n  }\n  switch (where) {\n    case 'FIRST':\n      if (mode === 'SET') {\n        return list + '[0] = ' + value + ';\\n';\n      } else if (mode === 'INSERT') {\n        return list + '.insert(0, ' + value + ');\\n';\n      }\n      break;\n    case 'LAST':\n      if (mode === 'SET') {\n        let code = cacheList();\n        code += list + '[' + list + '.length - 1] = ' + value + ';\\n';\n        return code;\n      } else if (mode === 'INSERT') {\n        return list + '.add(' + value + ');\\n';\n      }\n      break;\n    case 'FROM_START': {\n      const at = generator.getAdjusted(block, 'AT');\n      if (mode === 'SET') {\n        return list + '[' + at + '] = ' + value + ';\\n';\n      } else if (mode === 'INSERT') {\n        return list + '.insert(' + at + ', ' + value + ');\\n';\n      }\n      break;\n    }\n    case 'FROM_END': {\n      const at = generator.getAdjusted(block, 'AT', 1, false, Order.ADDITIVE);\n      let code = cacheList();\n      if (mode === 'SET') {\n        code += list + '[' + list + '.length - ' + at + '] = ' + value + ';\\n';\n        return code;\n      } else if (mode === 'INSERT') {\n        code +=\n          list + '.insert(' + list + '.length - ' + at + ', ' + value + ');\\n';\n        return code;\n      }\n      break;\n    }\n    case 'RANDOM': {\n      // TODO(#7600): find better approach than casting to any to override\n      // CodeGenerator declaring .definitions protected.\n      (generator as AnyDuringMigration).definitions_['import_dart_math'] =\n        \"import 'dart:math' as Math;\";\n      let code = cacheList();\n      const xVar = generator.nameDB_!.getDistinctName(\n        'tmp_x',\n        NameType.VARIABLE,\n      );\n      code +=\n        'int ' + xVar + ' = new Math.Random().nextInt(' + list + '.length);\\n';\n      if (mode === 'SET') {\n        code += list + '[' + xVar + '] = ' + value + ';\\n';\n        return code;\n      } else if (mode === 'INSERT') {\n        code += list + '.insert(' + xVar + ', ' + value + ');\\n';\n        return code;\n      }\n      break;\n    }\n  }\n  throw Error('Unhandled combination (lists_setIndex).');\n}\n\nexport function lists_getSublist(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Get sublist.\n  const list =\n    generator.valueToCode(block, 'LIST', Order.UNARY_POSTFIX) || '[]';\n  const where1 = block.getFieldValue('WHERE1');\n  const where2 = block.getFieldValue('WHERE2');\n  let code;\n  if (\n    list.match(/^\\w+$/) ||\n    (where1 !== 'FROM_END' && where2 === 'FROM_START')\n  ) {\n    // If the list is a is a variable or doesn't require a call for length,\n    // don't generate a helper function.\n    let at1;\n    switch (where1) {\n      case 'FROM_START':\n        at1 = generator.getAdjusted(block, 'AT1');\n        break;\n      case 'FROM_END':\n        at1 = generator.getAdjusted(block, 'AT1', 1, false, Order.ADDITIVE);\n        at1 = list + '.length - ' + at1;\n        break;\n      case 'FIRST':\n        at1 = '0';\n        break;\n      default:\n        throw Error('Unhandled option (lists_getSublist).');\n    }\n    let at2;\n    switch (where2) {\n      case 'FROM_START':\n        at2 = generator.getAdjusted(block, 'AT2', 1);\n        break;\n      case 'FROM_END':\n        at2 = generator.getAdjusted(block, 'AT2', 0, false, Order.ADDITIVE);\n        at2 = list + '.length - ' + at2;\n        break;\n      case 'LAST':\n        // There is no second index if LAST option is chosen.\n        break;\n      default:\n        throw Error('Unhandled option (lists_getSublist).');\n    }\n    if (where2 === 'LAST') {\n      code = list + '.sublist(' + at1 + ')';\n    } else {\n      code = list + '.sublist(' + at1 + ', ' + at2 + ')';\n    }\n  } else {\n    const at1 = generator.getAdjusted(block, 'AT1');\n    const at2 = generator.getAdjusted(block, 'AT2');\n    const functionName = generator.provideFunction_(\n      'lists_get_sublist',\n      `\nList ${generator.FUNCTION_NAME_PLACEHOLDER_}(List list, String where1, num at1, String where2, num at2) {\n  int getAt(String where, num at) {\n    if (where == 'FROM_END') {\n      at = list.length - 1 - at;\n    } else if (where == 'FIRST') {\n      at = 0;\n    } else if (where == 'LAST') {\n      at = list.length - 1;\n    } else if (where != 'FROM_START') {\n      throw 'Unhandled option (lists_getSublist).';\n    }\n    return at;\n  }\n  at1 = getAt(where1, at1);\n  at2 = getAt(where2, at2) + 1;\n  return list.sublist(at1, at2);\n}\n`,\n    );\n    code =\n      functionName +\n      '(' +\n      list +\n      \", '\" +\n      where1 +\n      \"', \" +\n      at1 +\n      \", '\" +\n      where2 +\n      \"', \" +\n      at2 +\n      ')';\n  }\n  return [code, Order.UNARY_POSTFIX];\n}\n\nexport function lists_sort(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Block for sorting a list.\n  const list = generator.valueToCode(block, 'LIST', Order.NONE) || '[]';\n  const direction = block.getFieldValue('DIRECTION') === '1' ? 1 : -1;\n  const type = block.getFieldValue('TYPE');\n  const sortFunctionName = generator.provideFunction_(\n    'lists_sort',\n    `\nList ${generator.FUNCTION_NAME_PLACEHOLDER_}(List list, String type, int direction) {\n  var compareFuncs = {\n    'NUMERIC': (a, b) => (direction * a.compareTo(b)).toInt(),\n    'TEXT': (a, b) => direction * a.toString().compareTo(b.toString()),\n    'IGNORE_CASE':\n      (a, b) => direction *\n      a.toString().toLowerCase().compareTo(b.toString().toLowerCase())\n  };\n  list = new List.from(list);\n  var compare = compareFuncs[type];\n  list.sort(compare);\n  return list;\n}\n`,\n  );\n  return [\n    sortFunctionName + '(' + list + ', ' + '\"' + type + '\", ' + direction + ')',\n    Order.UNARY_POSTFIX,\n  ];\n}\n\nexport function lists_split(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Block for splitting text into a list, or joining a list into text.\n  let input = generator.valueToCode(block, 'INPUT', Order.UNARY_POSTFIX);\n  const delimiter = generator.valueToCode(block, 'DELIM', Order.NONE) || \"''\";\n  const mode = block.getFieldValue('MODE');\n  let functionName;\n  if (mode === 'SPLIT') {\n    if (!input) {\n      input = \"''\";\n    }\n    functionName = 'split';\n  } else if (mode === 'JOIN') {\n    if (!input) {\n      input = '[]';\n    }\n    functionName = 'join';\n  } else {\n    throw Error('Unknown mode: ' + mode);\n  }\n  const code = input + '.' + functionName + '(' + delimiter + ')';\n  return [code, Order.UNARY_POSTFIX];\n}\n\nexport function lists_reverse(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Block for reversing a list.\n  const list = generator.valueToCode(block, 'LIST', Order.NONE) || '[]';\n  // XXX What should the operator precedence be for a `new`?\n  const code = 'new List.from(' + list + '.reversed)';\n  return [code, Order.UNARY_POSTFIX];\n}\n", "/**\n * @license\n * Copyright 2014 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Dart for logic blocks.\n */\n\n// Former goog.module ID: Blockly.Dart.logic\n\nimport type {Block} from '../../core/block.js';\nimport type {DartGenerator} from './dart_generator.js';\nimport {Order} from './dart_generator.js';\n\nexport function controls_if(block: Block, generator: DartGenerator) {\n  // If/elseif/else condition.\n  let n = 0;\n  let code = '',\n    branchCode,\n    conditionCode;\n  if (generator.STATEMENT_PREFIX) {\n    // Automatic prefix insertion is switched off for this block.  Add manually.\n    code += generator.injectId(generator.STATEMENT_PREFIX, block);\n  }\n  do {\n    conditionCode =\n      generator.valueToCode(block, 'IF' + n, Order.NONE) || 'false';\n    branchCode = generator.statementToCode(block, 'DO' + n);\n    if (generator.STATEMENT_SUFFIX) {\n      branchCode =\n        generator.prefixLines(\n          generator.injectId(generator.STATEMENT_SUFFIX, block),\n          generator.INDENT,\n        ) + branchCode;\n    }\n    code +=\n      (n > 0 ? 'else ' : '') +\n      'if (' +\n      conditionCode +\n      ') {\\n' +\n      branchCode +\n      '}';\n    n++;\n  } while (block.getInput('IF' + n));\n\n  if (block.getInput('ELSE') || generator.STATEMENT_SUFFIX) {\n    branchCode = block.getInput('ELSE')\n      ? generator.statementToCode(block, 'ELSE')\n      : '';\n    if (generator.STATEMENT_SUFFIX) {\n      branchCode =\n        generator.prefixLines(\n          generator.injectId(generator.STATEMENT_SUFFIX, block),\n          generator.INDENT,\n        ) + branchCode;\n    }\n    code += ' else {\\n' + branchCode + '}';\n  }\n  return code + '\\n';\n}\n\nexport const controls_ifelse = controls_if;\n\nexport function logic_compare(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Comparison operator.\n  const OPERATORS = {\n    'EQ': '==',\n    'NEQ': '!=',\n    'LT': '<',\n    'LTE': '<=',\n    'GT': '>',\n    'GTE': '>=',\n  };\n  type OperatorOption = keyof typeof OPERATORS;\n  const operator = OPERATORS[block.getFieldValue('OP') as OperatorOption];\n  const order =\n    operator === '==' || operator === '!=' ? Order.EQUALITY : Order.RELATIONAL;\n  const argument0 = generator.valueToCode(block, 'A', order) || '0';\n  const argument1 = generator.valueToCode(block, 'B', order) || '0';\n  const code = argument0 + ' ' + operator + ' ' + argument1;\n  return [code, order];\n}\n\nexport function logic_operation(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Operations 'and', 'or'.\n  const operator = block.getFieldValue('OP') === 'AND' ? '&&' : '||';\n  const order = operator === '&&' ? Order.LOGICAL_AND : Order.LOGICAL_OR;\n  let argument0 = generator.valueToCode(block, 'A', order);\n  let argument1 = generator.valueToCode(block, 'B', order);\n  if (!argument0 && !argument1) {\n    // If there are no arguments, then the return value is false.\n    argument0 = 'false';\n    argument1 = 'false';\n  } else {\n    // Single missing arguments have no effect on the return value.\n    const defaultArgument = operator === '&&' ? 'true' : 'false';\n    if (!argument0) {\n      argument0 = defaultArgument;\n    }\n    if (!argument1) {\n      argument1 = defaultArgument;\n    }\n  }\n  const code = argument0 + ' ' + operator + ' ' + argument1;\n  return [code, order];\n}\n\nexport function logic_negate(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Negation.\n  const order = Order.UNARY_PREFIX;\n  const argument0 = generator.valueToCode(block, 'BOOL', order) || 'true';\n  const code = '!' + argument0;\n  return [code, order];\n}\n\nexport function logic_boolean(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Boolean values true and false.\n  const code = block.getFieldValue('BOOL') === 'TRUE' ? 'true' : 'false';\n  return [code, Order.ATOMIC];\n}\n\nexport function logic_null(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Null data type.\n  return ['null', Order.ATOMIC];\n}\n\nexport function logic_ternary(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Ternary operator.\n  const value_if =\n    generator.valueToCode(block, 'IF', Order.CONDITIONAL) || 'false';\n  const value_then =\n    generator.valueToCode(block, 'THEN', Order.CONDITIONAL) || 'null';\n  const value_else =\n    generator.valueToCode(block, 'ELSE', Order.CONDITIONAL) || 'null';\n  const code = value_if + ' ? ' + value_then + ' : ' + value_else;\n  return [code, Order.CONDITIONAL];\n}\n", "/**\n * @license\n * Copyright 2014 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Dart for loop blocks.\n */\n\n// Former goog.module ID: Blockly.Dart.loops\n\nimport type {ControlFlowInLoopBlock} from '../../blocks/loops.js';\nimport type {Block} from '../../core/block.js';\nimport {NameType} from '../../core/names.js';\nimport * as stringUtils from '../../core/utils/string.js';\nimport type {DartGenerator} from './dart_generator.js';\nimport {Order} from './dart_generator.js';\n\nexport function controls_repeat_ext(block: Block, generator: DartGenerator) {\n  let repeats;\n  // Repeat n times.\n  if (block.getField('TIMES')) {\n    // Internal number.\n    repeats = String(Number(block.getFieldValue('TIMES')));\n  } else {\n    // External number.\n    repeats = generator.valueToCode(block, 'TIMES', Order.ASSIGNMENT) || '0';\n  }\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  let code = '';\n  const loopVar = generator.nameDB_!.getDistinctName(\n    'count',\n    NameType.VARIABLE,\n  );\n  let endVar = repeats;\n  if (!repeats.match(/^\\w+$/) && !stringUtils.isNumber(repeats)) {\n    endVar = generator.nameDB_!.getDistinctName(\n      'repeat_end',\n      NameType.VARIABLE,\n    );\n    code += 'var ' + endVar + ' = ' + repeats + ';\\n';\n  }\n  code +=\n    'for (int ' +\n    loopVar +\n    ' = 0; ' +\n    loopVar +\n    ' < ' +\n    endVar +\n    '; ' +\n    loopVar +\n    '++) {\\n' +\n    branch +\n    '}\\n';\n  return code;\n}\n\nexport const controls_repeat = controls_repeat_ext;\n\nexport function controls_whileUntil(block: Block, generator: DartGenerator) {\n  // Do while/until loop.\n  const until = block.getFieldValue('MODE') === 'UNTIL';\n  let argument0 =\n    generator.valueToCode(\n      block,\n      'BOOL',\n      until ? Order.UNARY_PREFIX : Order.NONE,\n    ) || 'false';\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  if (until) {\n    argument0 = '!' + argument0;\n  }\n  return 'while (' + argument0 + ') {\\n' + branch + '}\\n';\n}\n\nexport function controls_for(block: Block, generator: DartGenerator) {\n  // For loop.\n  const variable0 = generator.getVariableName(block.getFieldValue('VAR'));\n  const argument0 =\n    generator.valueToCode(block, 'FROM', Order.ASSIGNMENT) || '0';\n  const argument1 = generator.valueToCode(block, 'TO', Order.ASSIGNMENT) || '0';\n  const increment = generator.valueToCode(block, 'BY', Order.ASSIGNMENT) || '1';\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  let code;\n  if (\n    stringUtils.isNumber(argument0) &&\n    stringUtils.isNumber(argument1) &&\n    stringUtils.isNumber(increment)\n  ) {\n    // All arguments are simple numbers.\n    const up = Number(argument0) <= Number(argument1);\n    code =\n      'for (' +\n      variable0 +\n      ' = ' +\n      argument0 +\n      '; ' +\n      variable0 +\n      (up ? ' <= ' : ' >= ') +\n      argument1 +\n      '; ' +\n      variable0;\n    const step = Math.abs(Number(increment));\n    if (step === 1) {\n      code += up ? '++' : '--';\n    } else {\n      code += (up ? ' += ' : ' -= ') + step;\n    }\n    code += ') {\\n' + branch + '}\\n';\n  } else {\n    code = '';\n    // Cache non-trivial values to variables to prevent repeated look-ups.\n    let startVar = argument0;\n    if (!argument0.match(/^\\w+$/) && !stringUtils.isNumber(argument0)) {\n      startVar = generator.nameDB_!.getDistinctName(\n        variable0 + '_start',\n        NameType.VARIABLE,\n      );\n      code += 'var ' + startVar + ' = ' + argument0 + ';\\n';\n    }\n    let endVar = argument1;\n    if (!argument1.match(/^\\w+$/) && !stringUtils.isNumber(argument1)) {\n      endVar = generator.nameDB_!.getDistinctName(\n        variable0 + '_end',\n        NameType.VARIABLE,\n      );\n      code += 'var ' + endVar + ' = ' + argument1 + ';\\n';\n    }\n    // Determine loop direction at start, in case one of the bounds\n    // changes during loop execution.\n    const incVar = generator.nameDB_!.getDistinctName(\n      variable0 + '_inc',\n      NameType.VARIABLE,\n    );\n    code += 'num ' + incVar + ' = ';\n    if (stringUtils.isNumber(increment)) {\n      code += Math.abs(Number(increment)) + ';\\n';\n    } else {\n      code += '(' + increment + ').abs();\\n';\n    }\n    code += 'if (' + startVar + ' > ' + endVar + ') {\\n';\n    code += generator.INDENT + incVar + ' = -' + incVar + ';\\n';\n    code += '}\\n';\n    code +=\n      'for (' +\n      variable0 +\n      ' = ' +\n      startVar +\n      '; ' +\n      incVar +\n      ' >= 0 ? ' +\n      variable0 +\n      ' <= ' +\n      endVar +\n      ' : ' +\n      variable0 +\n      ' >= ' +\n      endVar +\n      '; ' +\n      variable0 +\n      ' += ' +\n      incVar +\n      ') {\\n' +\n      branch +\n      '}\\n';\n  }\n  return code;\n}\n\nexport function controls_forEach(block: Block, generator: DartGenerator) {\n  // For each loop.\n  const variable0 = generator.getVariableName(block.getFieldValue('VAR'));\n  const argument0 =\n    generator.valueToCode(block, 'LIST', Order.ASSIGNMENT) || '[]';\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  const code =\n    'for (var ' + variable0 + ' in ' + argument0 + ') {\\n' + branch + '}\\n';\n  return code;\n}\n\nexport function controls_flow_statements(\n  block: Block,\n  generator: DartGenerator,\n) {\n  // Flow statements: continue, break.\n  let xfix = '';\n  if (generator.STATEMENT_PREFIX) {\n    // Automatic prefix insertion is switched off for this block.  Add manually.\n    xfix += generator.injectId(generator.STATEMENT_PREFIX, block);\n  }\n  if (generator.STATEMENT_SUFFIX) {\n    // Inject any statement suffix here since the regular one at the end\n    // will not get executed if the break/continue is triggered.\n    xfix += generator.injectId(generator.STATEMENT_SUFFIX, block);\n  }\n  if (generator.STATEMENT_PREFIX) {\n    const loop = (block as ControlFlowInLoopBlock).getSurroundLoop();\n    if (loop && !loop.suppressPrefixSuffix) {\n      // Inject loop's statement prefix here since the regular one at the end\n      // of the loop will not get executed if 'continue' is triggered.\n      // In the case of 'break', a prefix is needed due to the loop's suffix.\n      xfix += generator.injectId(generator.STATEMENT_PREFIX, loop);\n    }\n  }\n  switch (block.getFieldValue('FLOW')) {\n    case 'BREAK':\n      return xfix + 'break;\\n';\n    case 'CONTINUE':\n      return xfix + 'continue;\\n';\n  }\n  throw Error('Unknown flow statement.');\n}\n", "/**\n * @license\n * Copyright 2014 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Dart for math blocks.\n */\n\n// Former goog.module ID: Blockly.Dart.math\n\nimport type {Block} from '../../core/block.js';\nimport type {DartGenerator} from './dart_generator.js';\nimport {Order} from './dart_generator.js';\n\n// RESERVED WORDS: 'Math'\n\nexport function math_number(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Numeric value.\n  const number = Number(block.getFieldValue('NUM'));\n  if (number === Infinity) {\n    return ['double.infinity', Order.UNARY_POSTFIX];\n  } else if (number === -Infinity) {\n    return ['-double.infinity', Order.UNARY_PREFIX];\n  } else {\n    // -4.abs() returns -4 in generator due to strange order of\n    // operation choices.  4 is actually an operator and a number.\n    // Reflect this in the order.\n    return [String(number), number < 0 ? Order.UNARY_PREFIX : Order.ATOMIC];\n  }\n}\n\nexport function math_arithmetic(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Basic arithmetic operators, and power.\n  const OPERATORS: Record<string, [string | null, Order]> = {\n    'ADD': [' + ', Order.ADDITIVE],\n    'MINUS': [' - ', Order.ADDITIVE],\n    'MULTIPLY': [' * ', Order.MULTIPLICATIVE],\n    'DIVIDE': [' / ', Order.MULTIPLICATIVE],\n    'POWER': [null, Order.NONE], // Handle power separately.\n  };\n  type OperatorOption = keyof typeof OPERATORS;\n  const tuple = OPERATORS[block.getFieldValue('OP') as OperatorOption];\n  const operator = tuple[0];\n  const order = tuple[1];\n  const argument0 = generator.valueToCode(block, 'A', order) || '0';\n  const argument1 = generator.valueToCode(block, 'B', order) || '0';\n  let code;\n  // Power in generator requires a special case since it has no operator.\n  if (!operator) {\n    // TODO(#7600): find better approach than casting to any to override\n    // CodeGenerator declaring .definitions protected.\n    (generator as AnyDuringMigration).definitions_['import_dart_math'] =\n      \"import 'dart:math' as Math;\";\n    code = 'Math.pow(' + argument0 + ', ' + argument1 + ')';\n    return [code, Order.UNARY_POSTFIX];\n  }\n  code = argument0 + operator + argument1;\n  return [code, order];\n}\n\nexport function math_single(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Math operators with single operand.\n  const operator = block.getFieldValue('OP');\n  let code;\n  let arg;\n  if (operator === 'NEG') {\n    // Negation is a special case given its different operator precedence.\n    arg = generator.valueToCode(block, 'NUM', Order.UNARY_PREFIX) || '0';\n    if (arg[0] === '-') {\n      // --3 is not legal in generator.\n      arg = ' ' + arg;\n    }\n    code = '-' + arg;\n    return [code, Order.UNARY_PREFIX];\n  }\n  // TODO(#7600): find better approach than casting to any to override\n  // CodeGenerator declaring .definitions protected.\n  (generator as AnyDuringMigration).definitions_['import_dart_math'] =\n    \"import 'dart:math' as Math;\";\n  if (operator === 'ABS' || operator.substring(0, 5) === 'ROUND') {\n    arg = generator.valueToCode(block, 'NUM', Order.UNARY_POSTFIX) || '0';\n  } else if (operator === 'SIN' || operator === 'COS' || operator === 'TAN') {\n    arg = generator.valueToCode(block, 'NUM', Order.MULTIPLICATIVE) || '0';\n  } else {\n    arg = generator.valueToCode(block, 'NUM', Order.NONE) || '0';\n  }\n  // First, handle cases which generate values that don't need parentheses\n  // wrapping the code.\n  switch (operator) {\n    case 'ABS':\n      code = arg + '.abs()';\n      break;\n    case 'ROOT':\n      code = 'Math.sqrt(' + arg + ')';\n      break;\n    case 'LN':\n      code = 'Math.log(' + arg + ')';\n      break;\n    case 'EXP':\n      code = 'Math.exp(' + arg + ')';\n      break;\n    case 'POW10':\n      code = 'Math.pow(10,' + arg + ')';\n      break;\n    case 'ROUND':\n      code = arg + '.round()';\n      break;\n    case 'ROUNDUP':\n      code = arg + '.ceil()';\n      break;\n    case 'ROUNDDOWN':\n      code = arg + '.floor()';\n      break;\n    case 'SIN':\n      code = 'Math.sin(' + arg + ' / 180 * Math.pi)';\n      break;\n    case 'COS':\n      code = 'Math.cos(' + arg + ' / 180 * Math.pi)';\n      break;\n    case 'TAN':\n      code = 'Math.tan(' + arg + ' / 180 * Math.pi)';\n      break;\n  }\n  if (code) {\n    return [code, Order.UNARY_POSTFIX];\n  }\n  // Second, handle cases which generate values that may need parentheses\n  // wrapping the code.\n  switch (operator) {\n    case 'LOG10':\n      code = 'Math.log(' + arg + ') / Math.log(10)';\n      break;\n    case 'ASIN':\n      code = 'Math.asin(' + arg + ') / Math.pi * 180';\n      break;\n    case 'ACOS':\n      code = 'Math.acos(' + arg + ') / Math.pi * 180';\n      break;\n    case 'ATAN':\n      code = 'Math.atan(' + arg + ') / Math.pi * 180';\n      break;\n    default:\n      throw Error('Unknown math operator: ' + operator);\n  }\n  return [code, Order.MULTIPLICATIVE];\n}\n\nexport function math_constant(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Constants: PI, E, the Golden Ratio, sqrt(2), 1/sqrt(2), INFINITY.\n  const CONSTANTS: Record<string, [string, Order]> = {\n    'PI': ['Math.pi', Order.UNARY_POSTFIX],\n    'E': ['Math.e', Order.UNARY_POSTFIX],\n    'GOLDEN_RATIO': ['(1 + Math.sqrt(5)) / 2', Order.MULTIPLICATIVE],\n    'SQRT2': ['Math.sqrt2', Order.UNARY_POSTFIX],\n    'SQRT1_2': ['Math.sqrt1_2', Order.UNARY_POSTFIX],\n    'INFINITY': ['double.infinity', Order.ATOMIC],\n  };\n  type ConstantOption = keyof typeof CONSTANTS;\n  const constant = block.getFieldValue('CONSTANT') as ConstantOption;\n  if (constant !== 'INFINITY') {\n    // TODO(#7600): find better approach than casting to any to override\n    // CodeGenerator declaring .definitions protected.\n    (generator as AnyDuringMigration).definitions_['import_dart_math'] =\n      \"import 'dart:math' as Math;\";\n  }\n  return CONSTANTS[constant];\n}\n\nexport function math_number_property(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Check if a number is even, odd, prime, whole, positive, or negative\n  // or if it is divisible by certain number. Returns true or false.\n  const PROPERTIES: Record<string, [string | null, Order, Order]> = {\n    'EVEN': [' % 2 == 0', Order.MULTIPLICATIVE, Order.EQUALITY],\n    'ODD': [' % 2 == 1', Order.MULTIPLICATIVE, Order.EQUALITY],\n    'WHOLE': [' % 1 == 0', Order.MULTIPLICATIVE, Order.EQUALITY],\n    'POSITIVE': [' > 0', Order.RELATIONAL, Order.RELATIONAL],\n    'NEGATIVE': [' < 0', Order.RELATIONAL, Order.RELATIONAL],\n    'DIVISIBLE_BY': [null, Order.MULTIPLICATIVE, Order.EQUALITY],\n    'PRIME': [null, Order.NONE, Order.UNARY_POSTFIX],\n  };\n  type PropertyOption = keyof typeof PROPERTIES;\n  const dropdownProperty = block.getFieldValue('PROPERTY') as PropertyOption;\n  const [suffix, inputOrder, outputOrder] = PROPERTIES[dropdownProperty];\n  const numberToCheck =\n    generator.valueToCode(block, 'NUMBER_TO_CHECK', inputOrder) || '0';\n  let code;\n  if (dropdownProperty === 'PRIME') {\n    // Prime is a special case as it is not a one-liner test.\n    // TODO(#7600): find better approach than casting to any to override\n    // CodeGenerator declaring .definitions protected.\n    (generator as AnyDuringMigration).definitions_['import_dart_math'] =\n      \"import 'dart:math' as Math;\";\n    const functionName = generator.provideFunction_(\n      'math_isPrime',\n      `\nbool ${generator.FUNCTION_NAME_PLACEHOLDER_}(n) {\n  // https://en.wikipedia.org/wiki/Primality_test#Naive_methods\n  if (n == 2 || n == 3) {\n    return true;\n  }\n  // False if n is null, negative, is 1, or not whole.\n  // And false if n is divisible by 2 or 3.\n  if (n == null || n <= 1 || n % 1 != 0 || n % 2 == 0 || n % 3 == 0) {\n    return false;\n  }\n  // Check all the numbers of form 6k +/- 1, up to sqrt(n).\n  for (var x = 6; x <= Math.sqrt(n) + 1; x += 6) {\n    if (n % (x - 1) == 0 || n % (x + 1) == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n`,\n    );\n    code = functionName + '(' + numberToCheck + ')';\n  } else if (dropdownProperty === 'DIVISIBLE_BY') {\n    const divisor =\n      generator.valueToCode(block, 'DIVISOR', Order.MULTIPLICATIVE) || '0';\n    if (divisor === '0') {\n      return ['false', Order.ATOMIC];\n    }\n    code = numberToCheck + ' % ' + divisor + ' == 0';\n  } else {\n    code = numberToCheck + suffix;\n  }\n  return [code, outputOrder];\n}\n\nexport function math_change(block: Block, generator: DartGenerator) {\n  // Add to a variable in place.\n  const argument0 =\n    generator.valueToCode(block, 'DELTA', Order.ADDITIVE) || '0';\n  const varName = generator.getVariableName(block.getFieldValue('VAR'));\n  return (\n    varName +\n    ' = (' +\n    varName +\n    ' is num ? ' +\n    varName +\n    ' : 0) + ' +\n    argument0 +\n    ';\\n'\n  );\n}\n\n// Rounding functions have a single operand.\nexport const math_round = math_single;\n// Trigonometry functions have a single operand.\nexport const math_trig = math_single;\n\nexport function math_on_list(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Math functions for lists.\n  const func = block.getFieldValue('OP');\n  const list = generator.valueToCode(block, 'LIST', Order.NONE) || '[]';\n  let code;\n  switch (func) {\n    case 'SUM': {\n      const functionName = generator.provideFunction_(\n        'math_sum',\n        `\nnum ${generator.FUNCTION_NAME_PLACEHOLDER_}(List<num> myList) {\n  num sumVal = 0;\n  myList.forEach((num entry) {sumVal += entry;});\n  return sumVal;\n}\n`,\n      );\n      code = functionName + '(' + list + ')';\n      break;\n    }\n    case 'MIN': {\n      // TODO(#7600): find better approach than casting to any to override\n      // CodeGenerator declaring .definitions protected.\n      (generator as AnyDuringMigration).definitions_['import_dart_math'] =\n        \"import 'dart:math' as Math;\";\n      const functionName = generator.provideFunction_(\n        'math_min',\n        `\nnum ${generator.FUNCTION_NAME_PLACEHOLDER_}(List<num> myList) {\n  if (myList.isEmpty) return null;\n  num minVal = myList[0];\n  myList.forEach((num entry) {minVal = Math.min(minVal, entry);});\n  return minVal;\n}\n`,\n      );\n      code = functionName + '(' + list + ')';\n      break;\n    }\n    case 'MAX': {\n      // TODO(#7600): find better approach than casting to any to override\n      // CodeGenerator declaring .definitions protected.\n      (generator as AnyDuringMigration).definitions_['import_dart_math'] =\n        \"import 'dart:math' as Math;\";\n      const functionName = generator.provideFunction_(\n        'math_max',\n        `\nnum ${generator.FUNCTION_NAME_PLACEHOLDER_}(List<num> myList) {\n  if (myList.isEmpty) return null;\n  num maxVal = myList[0];\n  myList.forEach((num entry) {maxVal = Math.max(maxVal, entry);});\n  return maxVal;\n}\n`,\n      );\n      code = functionName + '(' + list + ')';\n      break;\n    }\n    case 'AVERAGE': {\n      // This operation exclude null and values that are not int or float:\n      //   math_mean([null,null,\"aString\",1,9]) -> 5.0\n      const functionName = generator.provideFunction_(\n        'math_mean',\n        `\nnum ${generator.FUNCTION_NAME_PLACEHOLDER_}(List myList) {\n  // First filter list for numbers only.\n  List localList = new List.from(myList);\n  localList.removeWhere((a) => a is! num);\n  if (localList.isEmpty) return null;\n  num sumVal = 0;\n  localList.forEach((var entry) {sumVal += entry;});\n  return sumVal / localList.length;\n}\n`,\n      );\n      code = functionName + '(' + list + ')';\n      break;\n    }\n    case 'MEDIAN': {\n      const functionName = generator.provideFunction_(\n        'math_median',\n        `\nnum ${generator.FUNCTION_NAME_PLACEHOLDER_}(List myList) {\n  // First filter list for numbers only, then sort, then return middle value\n  // or the average of two middle values if list has an even number of elements.\n  List localList = new List.from(myList);\n  localList.removeWhere((a) => a is! num);\n  if (localList.isEmpty) return null;\n  localList.sort((a, b) => (a - b));\n  int index = localList.length ~/ 2;\n  if (localList.length % 2 == 1) {\n    return localList[index];\n  } else {\n    return (localList[index - 1] + localList[index]) / 2;\n  }\n}\n`,\n      );\n      code = functionName + '(' + list + ')';\n      break;\n    }\n    case 'MODE': {\n      // TODO(#7600): find better approach than casting to any to override\n      // CodeGenerator declaring .definitions protected.\n      (generator as AnyDuringMigration).definitions_['import_dart_math'] =\n        \"import 'dart:math' as Math;\";\n      // As a list of numbers can contain more than one mode,\n      // the returned result is provided as an array.\n      // Mode of [3, 'x', 'x', 1, 1, 2, '3'] -> ['x', 1]\n      const functionName = generator.provideFunction_(\n        'math_modes',\n        `\nList ${generator.FUNCTION_NAME_PLACEHOLDER_}(List values) {\n  List modes = [];\n  List counts = [];\n  int maxCount = 0;\n  for (int i = 0; i < values.length; i++) {\n    var value = values[i];\n    bool found = false;\n    int thisCount;\n    for (int j = 0; j < counts.length; j++) {\n      if (counts[j][0] == value) {\n        thisCount = ++counts[j][1];\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      counts.add([value, 1]);\n      thisCount = 1;\n    }\n    maxCount = Math.max(thisCount, maxCount);\n  }\n  for (int j = 0; j < counts.length; j++) {\n    if (counts[j][1] == maxCount) {\n        modes.add(counts[j][0]);\n    }\n  }\n  return modes;\n}\n`,\n      );\n      code = functionName + '(' + list + ')';\n      break;\n    }\n    case 'STD_DEV': {\n      // TODO(#7600): find better approach than casting to any to override\n      // CodeGenerator declaring .definitions protected.\n      (generator as AnyDuringMigration).definitions_['import_dart_math'] =\n        \"import 'dart:math' as Math;\";\n      const functionName = generator.provideFunction_(\n        'math_standard_deviation',\n        `\nnum ${generator.FUNCTION_NAME_PLACEHOLDER_}(List myList) {\n  // First filter list for numbers only.\n  List numbers = new List.from(myList);\n  numbers.removeWhere((a) => a is! num);\n  if (numbers.isEmpty) return null;\n  num n = numbers.length;\n  num sum = 0;\n  numbers.forEach((x) => sum += x);\n  num mean = sum / n;\n  num sumSquare = 0;\n  numbers.forEach((x) => sumSquare += Math.pow(x - mean, 2));\n  return Math.sqrt(sumSquare / n);\n}\n`,\n      );\n      code = functionName + '(' + list + ')';\n      break;\n    }\n    case 'RANDOM': {\n      // TODO(#7600): find better approach than casting to any to override\n      // CodeGenerator declaring .definitions protected.\n      (generator as AnyDuringMigration).definitions_['import_dart_math'] =\n        \"import 'dart:math' as Math;\";\n      const functionName = generator.provideFunction_(\n        'math_random_item',\n        `\ndynamic ${generator.FUNCTION_NAME_PLACEHOLDER_}(List myList) {\n  int x = new Math.Random().nextInt(myList.length);\n  return myList[x];\n}\n`,\n      );\n      code = functionName + '(' + list + ')';\n      break;\n    }\n    default:\n      throw Error('Unknown operator: ' + func);\n  }\n  return [code, Order.UNARY_POSTFIX];\n}\n\nexport function math_modulo(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Remainder computation.\n  const argument0 =\n    generator.valueToCode(block, 'DIVIDEND', Order.MULTIPLICATIVE) || '0';\n  const argument1 =\n    generator.valueToCode(block, 'DIVISOR', Order.MULTIPLICATIVE) || '0';\n  const code = argument0 + ' % ' + argument1;\n  return [code, Order.MULTIPLICATIVE];\n}\n\nexport function math_constrain(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Constrain a number between two limits.\n  // TODO(#7600): find better approach than casting to any to override\n  // CodeGenerator declaring .definitions protected.\n  (generator as AnyDuringMigration).definitions_['import_dart_math'] =\n    \"import 'dart:math' as Math;\";\n  const argument0 = generator.valueToCode(block, 'VALUE', Order.NONE) || '0';\n  const argument1 = generator.valueToCode(block, 'LOW', Order.NONE) || '0';\n  const argument2 =\n    generator.valueToCode(block, 'HIGH', Order.NONE) || 'double.infinity';\n  const code =\n    'Math.min(Math.max(' +\n    argument0 +\n    ', ' +\n    argument1 +\n    '), ' +\n    argument2 +\n    ')';\n  return [code, Order.UNARY_POSTFIX];\n}\n\nexport function math_random_int(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Random integer between [X] and [Y].\n  // TODO(#7600): find better approach than casting to any to override\n  // CodeGenerator declaring .definitions protected.\n  (generator as AnyDuringMigration).definitions_['import_dart_math'] =\n    \"import 'dart:math' as Math;\";\n  const argument0 = generator.valueToCode(block, 'FROM', Order.NONE) || '0';\n  const argument1 = generator.valueToCode(block, 'TO', Order.NONE) || '0';\n  const functionName = generator.provideFunction_(\n    'math_random_int',\n    `\nint ${generator.FUNCTION_NAME_PLACEHOLDER_}(num a, num b) {\n  if (a > b) {\n    // Swap a and b to ensure a is smaller.\n    num c = a;\n    a = b;\n    b = c;\n  }\n  return new Math.Random().nextInt(b - a + 1) + a;\n}\n`,\n  );\n  const code = functionName + '(' + argument0 + ', ' + argument1 + ')';\n  return [code, Order.UNARY_POSTFIX];\n}\n\nexport function math_random_float(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Random fraction between 0 and 1.\n  // TODO(#7600): find better approach than casting to any to override\n  // CodeGenerator declaring .definitions protected.\n  (generator as AnyDuringMigration).definitions_['import_dart_math'] =\n    \"import 'dart:math' as Math;\";\n  return ['new Math.Random().nextDouble()', Order.UNARY_POSTFIX];\n}\n\nexport function math_atan2(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Arctangent of point (X, Y) in degrees from -180 to 180.\n  // TODO(#7600): find better approach than casting to any to override\n  // CodeGenerator declaring .definitions protected.\n  (generator as AnyDuringMigration).definitions_['import_dart_math'] =\n    \"import 'dart:math' as Math;\";\n  const argument0 = generator.valueToCode(block, 'X', Order.NONE) || '0';\n  const argument1 = generator.valueToCode(block, 'Y', Order.NONE) || '0';\n  return [\n    'Math.atan2(' + argument1 + ', ' + argument0 + ') / Math.pi * 180',\n    Order.MULTIPLICATIVE,\n  ];\n}\n", "/**\n * @license\n * Copyright 2014 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Dart for procedure blocks.\n */\n\n// Former goog.module ID: Blockly.Dart.procedures\n\nimport type {IfReturnBlock} from '../../blocks/procedures.js';\nimport type {Block} from '../../core/block.js';\nimport type {DartGenerator} from './dart_generator.js';\nimport {Order} from './dart_generator.js';\n\nexport function procedures_defreturn(block: Block, generator: DartGenerator) {\n  // Define a procedure with a return value.\n  const funcName = generator.getProcedureName(block.getFieldValue('NAME'));\n  let xfix1 = '';\n  if (generator.STATEMENT_PREFIX) {\n    xfix1 += generator.injectId(generator.STATEMENT_PREFIX, block);\n  }\n  if (generator.STATEMENT_SUFFIX) {\n    xfix1 += generator.injectId(generator.STATEMENT_SUFFIX, block);\n  }\n  if (xfix1) {\n    xfix1 = generator.prefixLines(xfix1, generator.INDENT);\n  }\n  let loopTrap = '';\n  if (generator.INFINITE_LOOP_TRAP) {\n    loopTrap = generator.prefixLines(\n      generator.injectId(generator.INFINITE_LOOP_TRAP, block),\n      generator.INDENT,\n    );\n  }\n  let branch = '';\n  if (block.getInput('STACK')) {\n    // The 'procedures_defreturn' block might not have a STACK input.\n    branch = generator.statementToCode(block, 'STACK');\n  }\n  let returnValue = '';\n  if (block.getInput('RETURN')) {\n    // The 'procedures_defnoreturn' block (which shares this code)\n    // does not have a RETURN input.\n    returnValue = generator.valueToCode(block, 'RETURN', Order.NONE) || '';\n  }\n  let xfix2 = '';\n  if (branch && returnValue) {\n    // After executing the function body, revisit this block for the return.\n    xfix2 = xfix1;\n  }\n  if (returnValue) {\n    returnValue = generator.INDENT + 'return ' + returnValue + ';\\n';\n  }\n  const returnType = returnValue ? 'dynamic' : 'void';\n  const args = [];\n  const variables = block.getVars();\n  for (let i = 0; i < variables.length; i++) {\n    args[i] = generator.getVariableName(variables[i]);\n  }\n  let code =\n    returnType +\n    ' ' +\n    funcName +\n    '(' +\n    args.join(', ') +\n    ') {\\n' +\n    xfix1 +\n    loopTrap +\n    branch +\n    xfix2 +\n    returnValue +\n    '}';\n  code = generator.scrub_(block, code);\n  // Add % so as not to collide with helper functions in definitions list.\n  // TODO(#7600): find better approach than casting to any to override\n  // CodeGenerator declaring .definitions protected.\n  (generator as AnyDuringMigration).definitions_['%' + funcName] = code;\n  return null;\n}\n\n// Defining a procedure without a return value uses the same generator as\n// a procedure with a return value.\nexport const procedures_defnoreturn = procedures_defreturn;\n\nexport function procedures_callreturn(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Call a procedure with a return value.\n  const funcName = generator.getProcedureName(block.getFieldValue('NAME'));\n  const args = [];\n  const variables = block.getVars();\n  for (let i = 0; i < variables.length; i++) {\n    args[i] = generator.valueToCode(block, 'ARG' + i, Order.NONE) || 'null';\n  }\n  let code = funcName + '(' + args.join(', ') + ')';\n  return [code, Order.UNARY_POSTFIX];\n}\n\nexport function procedures_callnoreturn(\n  block: Block,\n  generator: DartGenerator,\n) {\n  // Call a procedure with no return value.\n  // Generated code is for a function call as a statement is the same as a\n  // function call as a value, with the addition of line ending.\n  const tuple = generator.forBlock['procedures_callreturn'](\n    block,\n    generator,\n  ) as [string, Order];\n  return tuple[0] + ';\\n';\n}\n\nexport function procedures_ifreturn(block: Block, generator: DartGenerator) {\n  // Conditionally return value from a procedure.\n  const condition =\n    generator.valueToCode(block, 'CONDITION', Order.NONE) || 'false';\n  let code = 'if (' + condition + ') {\\n';\n  if (generator.STATEMENT_SUFFIX) {\n    // Inject any statement suffix here since the regular one at the end\n    // will not get executed if the return is triggered.\n    code += generator.prefixLines(\n      generator.injectId(generator.STATEMENT_SUFFIX, block),\n      generator.INDENT,\n    );\n  }\n  if ((block as IfReturnBlock).hasReturnValue_) {\n    const value = generator.valueToCode(block, 'VALUE', Order.NONE) || 'null';\n    code += generator.INDENT + 'return ' + value + ';\\n';\n  } else {\n    code += generator.INDENT + 'return;\\n';\n  }\n  code += '}\\n';\n  return code;\n}\n", "/**\n * @license\n * Copyright 2014 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Dart for text blocks.\n */\n\n// Former goog.module ID: Blockly.Dart.texts\n\nimport type {JoinMutatorBlock} from '../../blocks/text.js';\nimport type {Block} from '../../core/block.js';\nimport type {DartGenerator} from './dart_generator.js';\nimport {Order} from './dart_generator.js';\n\n// RESERVED WORDS: 'Html,Math'\n\nexport function text(block: Block, generator: DartGenerator): [string, Order] {\n  // Text value.\n  const code = generator.quote_(block.getFieldValue('TEXT'));\n  return [code, Order.ATOMIC];\n}\n\nexport function text_join(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Create a string made up of any number of elements of any type.\n  const joinBlock = block as JoinMutatorBlock;\n  switch (joinBlock.itemCount_) {\n    case 0:\n      return [\"''\", Order.ATOMIC];\n    case 1: {\n      const element =\n        generator.valueToCode(block, 'ADD0', Order.UNARY_POSTFIX) || \"''\";\n      const code = element + '.toString()';\n      return [code, Order.UNARY_POSTFIX];\n    }\n    default: {\n      const elements = new Array(joinBlock.itemCount_);\n      for (let i = 0; i < joinBlock.itemCount_; i++) {\n        elements[i] =\n          generator.valueToCode(block, 'ADD' + i, Order.NONE) || \"''\";\n      }\n      const code = '[' + elements.join(',') + '].join()';\n      return [code, Order.UNARY_POSTFIX];\n    }\n  }\n}\n\nexport function text_append(block: Block, generator: DartGenerator) {\n  // Append to a variable in place.\n  const varName = generator.getVariableName(block.getFieldValue('VAR'));\n  const value = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  return varName + ' = [' + varName + ', ' + value + '].join();\\n';\n}\n\nexport function text_length(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // String or array length.\n  const text =\n    generator.valueToCode(block, 'VALUE', Order.UNARY_POSTFIX) || \"''\";\n  return [text + '.length', Order.UNARY_POSTFIX];\n}\n\nexport function text_isEmpty(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Is the string null or array empty?\n  const text =\n    generator.valueToCode(block, 'VALUE', Order.UNARY_POSTFIX) || \"''\";\n  return [text + '.isEmpty', Order.UNARY_POSTFIX];\n}\n\nexport function text_indexOf(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Search the text for a substring.\n  const operator =\n    block.getFieldValue('END') === 'FIRST' ? 'indexOf' : 'lastIndexOf';\n  const substring = generator.valueToCode(block, 'FIND', Order.NONE) || \"''\";\n  const text =\n    generator.valueToCode(block, 'VALUE', Order.UNARY_POSTFIX) || \"''\";\n  const code = text + '.' + operator + '(' + substring + ')';\n  if (block.workspace.options.oneBasedIndex) {\n    return [code + ' + 1', Order.ADDITIVE];\n  }\n  return [code, Order.UNARY_POSTFIX];\n}\n\nexport function text_charAt(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Get letter at index.\n  // Note: Until January 2013 this block did not have the WHERE input.\n  const where = block.getFieldValue('WHERE') || 'FROM_START';\n  const textOrder =\n    where === 'FIRST' || where === 'FROM_START'\n      ? Order.UNARY_POSTFIX\n      : Order.NONE;\n  const text = generator.valueToCode(block, 'VALUE', textOrder) || \"''\";\n  let at;\n  switch (where) {\n    case 'FIRST': {\n      const code = text + '[0]';\n      return [code, Order.UNARY_POSTFIX];\n    }\n    case 'FROM_START': {\n      at = generator.getAdjusted(block, 'AT');\n      const code = text + '[' + at + ']';\n      return [code, Order.UNARY_POSTFIX];\n    }\n    case 'LAST':\n    case 'FROM_END': {\n      if (where === 'LAST') {\n        at = 1;\n      } else {\n        at = generator.getAdjusted(block, 'AT', 1);\n      }\n      const functionName = generator.provideFunction_(\n        'text_get_from_end',\n        `\nString ${generator.FUNCTION_NAME_PLACEHOLDER_}(String text, num x) {\n  return text[text.length - x];\n}\n`,\n      );\n      const code = `${functionName}(${text}, ${at})`;\n      return [code, Order.UNARY_POSTFIX];\n    }\n    case 'RANDOM': {\n      // TODO(#7600): find better approach than casting to any to override\n      // CodeGenerator declaring .definitions protected.\n      (generator as AnyDuringMigration).definitions_['import_dart_math'] =\n        \"import 'dart:math' as Math;\";\n      const functionName = generator.provideFunction_(\n        'text_random_letter',\n        `\nString ${generator.FUNCTION_NAME_PLACEHOLDER_}(String text) {\n  int x = new Math.Random().nextInt(text.length);\n  return text[x];\n}\n`,\n      );\n      const code = functionName + '(' + text + ')';\n      return [code, Order.UNARY_POSTFIX];\n    }\n  }\n  throw Error('Unhandled option (text_charAt).');\n}\n\nexport function text_getSubstring(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Get substring.\n  const where1 = block.getFieldValue('WHERE1');\n  const where2 = block.getFieldValue('WHERE2');\n  const requiresLengthCall = where1 !== 'FROM_END' && where2 === 'FROM_START';\n  const textOrder = requiresLengthCall ? Order.UNARY_POSTFIX : Order.NONE;\n  const text = generator.valueToCode(block, 'STRING', textOrder) || \"''\";\n  let code;\n  if (where1 === 'FIRST' && where2 === 'LAST') {\n    code = text;\n    return [code, Order.NONE];\n  } else if (text.match(/^'?\\w+'?$/) || requiresLengthCall) {\n    // If the text is a variable or literal or doesn't require a call for\n    // length, don't generate a helper function.\n    let at1;\n    switch (where1) {\n      case 'FROM_START':\n        at1 = generator.getAdjusted(block, 'AT1');\n        break;\n      case 'FROM_END':\n        at1 = generator.getAdjusted(block, 'AT1', 1, false, Order.ADDITIVE);\n        at1 = text + '.length - ' + at1;\n        break;\n      case 'FIRST':\n        at1 = '0';\n        break;\n      default:\n        throw Error('Unhandled option (text_getSubstring).');\n    }\n    let at2;\n    switch (where2) {\n      case 'FROM_START':\n        at2 = generator.getAdjusted(block, 'AT2', 1);\n        break;\n      case 'FROM_END':\n        at2 = generator.getAdjusted(block, 'AT2', 0, false, Order.ADDITIVE);\n        at2 = text + '.length - ' + at2;\n        break;\n      case 'LAST':\n        break;\n      default:\n        throw Error('Unhandled option (text_getSubstring).');\n    }\n\n    if (where2 === 'LAST') {\n      code = text + '.substring(' + at1 + ')';\n    } else {\n      code = text + '.substring(' + at1 + ', ' + at2 + ')';\n    }\n  } else {\n    const at1 = generator.getAdjusted(block, 'AT1');\n    const at2 = generator.getAdjusted(block, 'AT2');\n    const functionName = generator.provideFunction_(\n      'text_get_substring',\n      `\nString ${generator.FUNCTION_NAME_PLACEHOLDER_}(String text, String where1, num at1, String where2, num at2) {\n  int getAt(String where, num at) {\n    if (where == 'FROM_END') {\n      at = text.length - 1 - at;\n    } else if (where == 'FIRST') {\n      at = 0;\n    } else if (where == 'LAST') {\n      at = text.length - 1;\n    } else if (where != 'FROM_START') {\n      throw 'Unhandled option (text_getSubstring).';\n    }\n    return at;\n  }\n  at1 = getAt(where1, at1);\n  at2 = getAt(where2, at2) + 1;\n  return text.substring(at1, at2);\n}\n`,\n    );\n    code =\n      functionName +\n      '(' +\n      text +\n      \", '\" +\n      where1 +\n      \"', \" +\n      at1 +\n      \", '\" +\n      where2 +\n      \"', \" +\n      at2 +\n      ')';\n  }\n  return [code, Order.UNARY_POSTFIX];\n}\n\nexport function text_changeCase(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Change capitalization.\n  const OPERATORS = {\n    'UPPERCASE': '.toUpperCase()',\n    'LOWERCASE': '.toLowerCase()',\n    'TITLECASE': null,\n  };\n  type OperatorOption = keyof typeof OPERATORS;\n  const operator = OPERATORS[block.getFieldValue('CASE') as OperatorOption];\n  const textOrder = operator ? Order.UNARY_POSTFIX : Order.NONE;\n  const text = generator.valueToCode(block, 'TEXT', textOrder) || \"''\";\n  let code;\n  if (operator) {\n    // Upper and lower case are functions built into generator.\n    code = text + operator;\n  } else {\n    // Title case is not a native generator function.  Define one.\n    const functionName = generator.provideFunction_(\n      'text_toTitleCase',\n      `\nString ${generator.FUNCTION_NAME_PLACEHOLDER_}(String str) {\n  RegExp exp = new RegExp(r'\\\\b');\n  List<String> list = str.split(exp);\n  final title = new StringBuffer();\n  for (String part in list) {\n    if (part.length > 0) {\n      title.write(part[0].toUpperCase());\n      if (part.length > 0) {\n        title.write(part.substring(1).toLowerCase());\n      }\n    }\n  }\n  return title.toString();\n}\n`,\n    );\n    code = functionName + '(' + text + ')';\n  }\n  return [code, Order.UNARY_POSTFIX];\n}\n\nexport function text_trim(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Trim spaces.\n  const OPERATORS = {\n    'LEFT': \".replaceFirst(new RegExp(r'^\\\\s+'), '')\",\n    'RIGHT': \".replaceFirst(new RegExp(r'\\\\s+$'), '')\",\n    'BOTH': '.trim()',\n  };\n  type OperatorOption = keyof typeof OPERATORS;\n  const operator = OPERATORS[block.getFieldValue('MODE') as OperatorOption];\n  const text =\n    generator.valueToCode(block, 'TEXT', Order.UNARY_POSTFIX) || \"''\";\n  return [text + operator, Order.UNARY_POSTFIX];\n}\n\nexport function text_print(block: Block, generator: DartGenerator) {\n  // Print statement.\n  const msg = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  return 'print(' + msg + ');\\n';\n}\n\nexport function text_prompt_ext(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Prompt function.\n  // TODO(#7600): find better approach than casting to any to override\n  // CodeGenerator declaring .definitions protected.\n  (generator as AnyDuringMigration).definitions_['import_dart_html'] =\n    \"import 'dart:html' as Html;\";\n  let msg;\n  if (block.getField('TEXT')) {\n    // Internal message.\n    msg = generator.quote_(block.getFieldValue('TEXT'));\n  } else {\n    // External message.\n    msg = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  }\n  let code = 'Html.window.prompt(' + msg + \", '')\";\n  const toNumber = block.getFieldValue('TYPE') === 'NUMBER';\n  if (toNumber) {\n    // TODO(#7600): find better approach than casting to any to override\n    // CodeGenerator declaring .definitions protected.\n    (generator as AnyDuringMigration).definitions_['import_dart_math'] =\n      \"import 'dart:math' as Math;\";\n    code = 'Math.parseDouble(' + code + ')';\n  }\n  return [code, Order.UNARY_POSTFIX];\n}\n\nexport const text_prompt = text_prompt_ext;\n\nexport function text_count(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const sub = generator.valueToCode(block, 'SUB', Order.NONE) || \"''\";\n  // Substring count is not a native generator function.  Define one.\n  const functionName = generator.provideFunction_(\n    'text_count',\n    `\nint ${generator.FUNCTION_NAME_PLACEHOLDER_}(String haystack, String needle) {\n  if (needle.length == 0) {\n    return haystack.length + 1;\n  }\n  int index = 0;\n  int count = 0;\n  while (index != -1) {\n    index = haystack.indexOf(needle, index);\n    if (index != -1) {\n      count++;\n     index += needle.length;\n    }\n  }\n  return count;\n}\n`,\n  );\n  const code = functionName + '(' + text + ', ' + sub + ')';\n  return [code, Order.UNARY_POSTFIX];\n}\n\nexport function text_replace(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  const text =\n    generator.valueToCode(block, 'TEXT', Order.UNARY_POSTFIX) || \"''\";\n  const from = generator.valueToCode(block, 'FROM', Order.NONE) || \"''\";\n  const to = generator.valueToCode(block, 'TO', Order.NONE) || \"''\";\n  const code = text + '.replaceAll(' + from + ', ' + to + ')';\n  return [code, Order.UNARY_POSTFIX];\n}\n\nexport function text_reverse(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // There isn't a sensible way to do this in generator. See:\n  // http://stackoverflow.com/a/21613700/3529104\n  // Implementing something is possibly better than not implementing anything?\n  const text =\n    generator.valueToCode(block, 'TEXT', Order.UNARY_POSTFIX) || \"''\";\n  const code = 'new String.fromCharCodes(' + text + '.runes.toList().reversed)';\n  return [code, Order.UNARY_PREFIX];\n}\n", "/**\n * @license\n * Copyright 2014 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Dart for variable blocks.\n */\n\n// Former goog.module ID: Blockly.Dart.variables\n\nimport type {Block} from '../../core/block.js';\nimport type {DartGenerator} from './dart_generator.js';\nimport {Order} from './dart_generator.js';\n\nexport function variables_get(\n  block: Block,\n  generator: DartGenerator,\n): [string, Order] {\n  // Variable getter.\n  const code = generator.getVariableName(block.getFieldValue('VAR'));\n  return [code, Order.ATOMIC];\n}\n\nexport function variables_set(block: Block, generator: DartGenerator) {\n  // Variable setter.\n  const argument0 =\n    generator.valueToCode(block, 'VALUE', Order.ASSIGNMENT) || '0';\n  const varName = generator.getVariableName(block.getFieldValue('VAR'));\n  return varName + ' = ' + argument0 + ';\\n';\n}\n", "/**\n * @license\n * Copyright 2014 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Dart code generator class, including helper methods for\n * generating Dart for blocks.\n */\n\n// Former goog.module ID: Blockly.Dart\n\nimport type {Block} from '../../core/block.js';\nimport {CodeGenerator} from '../../core/generator.js';\nimport {inputTypes} from '../../core/inputs/input_types.js';\nimport {Names, NameType} from '../../core/names.js';\nimport * as stringUtils from '../../core/utils/string.js';\nimport * as Variables from '../../core/variables.js';\nimport type {Workspace} from '../../core/workspace.js';\n\n/**\n * Order of operation ENUMs.\n * https://dart.dev/guides/language/language-tour#operators\n */\n// prettier-ignore\nexport enum Order {\n  ATOMIC = 0,         // 0 \"\" ...\n  UNARY_POSTFIX = 1,  // expr++ expr-- () [] . ?.\n  UNARY_PREFIX = 2,   // -expr !expr ~expr ++expr --expr\n  MULTIPLICATIVE = 3, // * / % ~/\n  ADDITIVE = 4,       // + -\n  SHIFT = 5,          // << >>\n  BITWISE_AND = 6,    // &\n  BITWISE_XOR = 7,    // ^\n  BITWISE_OR = 8,     // |\n  RELATIONAL = 9,     // >= > <= < as is is!\n  EQUALITY = 10,      // == !=\n  LOGICAL_AND = 11,   // &&\n  LOGICAL_OR = 12,    // ||\n  IF_NULL = 13,       // ??\n  CONDITIONAL = 14,   // expr ? expr: expr\n  CASCADE = 15,       // ..\n  ASSIGNMENT = 16,    // = *= /= ~/= %= += -= <<= >>= &= ^= |=\n  NONE = 99,          // (...)\n}\n\n/**\n * Dart code generator class.\n */\nexport class DartGenerator extends CodeGenerator {\n  /** @param name Name of the language the generator is for. */\n  constructor(name = 'Dart') {\n    super(name);\n    this.isInitialized = false;\n\n    // Copy Order values onto instance for backwards compatibility\n    // while ensuring they are not part of the publically-advertised\n    // API.\n    //\n    // TODO(#7085): deprecate these in due course.  (Could initially\n    // replace data properties with get accessors that call\n    // deprecate.warn().)\n    for (const key in Order) {\n      // Must assign Order[key] to a temporary to get the type guard to work;\n      // see https://github.com/microsoft/TypeScript/issues/10530.\n      const value = Order[key];\n      // Skip reverse-lookup entries in the enum.  Due to\n      // https://github.com/microsoft/TypeScript/issues/55713 this (as\n      // of TypeScript 5.5.2) actually narrows the type of value to\n      // never - but that still allows the following assignment to\n      // succeed.\n      if (typeof value === 'string') continue;\n      (this as unknown as Record<string, Order>)['ORDER_' + key] = value;\n    }\n\n    // List of illegal variable names.  This is not intended to be a\n    // security feature.  Blockly is 100% client-side, so bypassing\n    // this list is trivial.  This is intended to prevent users from\n    // accidentally clobbering a built-in object or function.\n    this.addReservedWords(\n      // https://www.dartlang.org/docs/spec/latest/dart-language-specification.pdf\n      // Section 16.1.1\n      'assert,break,case,catch,class,const,continue,default,do,else,enum,' +\n        'extends,false,final,finally,for,if,in,is,new,null,rethrow,return,' +\n        'super,switch,this,throw,true,try,var,void,while,with,' +\n        // https://api.dartlang.org/dart_core.html\n        'print,identityHashCode,identical,BidirectionalIterator,Comparable,' +\n        'double,Function,int,Invocation,Iterable,Iterator,List,Map,Match,num,' +\n        'Pattern,RegExp,Set,StackTrace,String,StringSink,Type,bool,DateTime,' +\n        'Deprecated,Duration,Expando,Null,Object,RuneIterator,Runes,Stopwatch,' +\n        'StringBuffer,Symbol,Uri,Comparator,AbstractClassInstantiationError,' +\n        'ArgumentError,AssertionError,CastError,ConcurrentModificationError,' +\n        'CyclicInitializationError,Error,Exception,FallThroughError,' +\n        'FormatException,IntegerDivisionByZeroException,NoSuchMethodError,' +\n        'NullThrownError,OutOfMemoryError,RangeError,StackOverflowError,' +\n        'StateError,TypeError,UnimplementedError,UnsupportedError',\n    );\n  }\n\n  /**\n   * Initialise the database of variable names.\n   *\n   * @param workspace Workspace to generate code from.\n   */\n  init(workspace: Workspace) {\n    super.init(workspace);\n\n    if (!this.nameDB_) {\n      this.nameDB_ = new Names(this.RESERVED_WORDS_);\n    } else {\n      this.nameDB_.reset();\n    }\n\n    this.nameDB_.setVariableMap(workspace.getVariableMap());\n    this.nameDB_.populateVariables(workspace);\n    this.nameDB_.populateProcedures(workspace);\n\n    const defvars = [];\n    // Add developer variables (not created or named by the user).\n    const devVarList = Variables.allDeveloperVariables(workspace);\n    for (let i = 0; i < devVarList.length; i++) {\n      defvars.push(\n        this.nameDB_.getName(devVarList[i], NameType.DEVELOPER_VARIABLE),\n      );\n    }\n\n    // Add user variables, but only ones that are being used.\n    const variables = Variables.allUsedVarModels(workspace);\n    for (let i = 0; i < variables.length; i++) {\n      defvars.push(\n        this.nameDB_.getName(variables[i].getId(), NameType.VARIABLE),\n      );\n    }\n\n    // Declare all of the variables.\n    if (defvars.length) {\n      this.definitions_['variables'] = 'var ' + defvars.join(', ') + ';';\n    }\n    this.isInitialized = true;\n  }\n\n  /**\n   * Prepend the generated code with import statements and variable definitions.\n   *\n   * @param code Generated code.\n   * @returns Completed code.\n   */\n  finish(code: string): string {\n    // Indent every line.\n    if (code) {\n      code = this.prefixLines(code, this.INDENT);\n    }\n    code = 'main() {\\n' + code + '}';\n\n    // Convert the definitions dictionary into a list.\n    const imports = [];\n    const definitions = [];\n    for (let name in this.definitions_) {\n      const def = this.definitions_[name];\n      if (def.match(/^import\\s/)) {\n        imports.push(def);\n      } else {\n        definitions.push(def);\n      }\n    }\n    // Call Blockly.CodeGenerator's finish.\n    code = super.finish(code);\n    this.isInitialized = false;\n\n    this.nameDB_!.reset();\n    const allDefs = imports.join('\\n') + '\\n\\n' + definitions.join('\\n\\n');\n    return allDefs.replace(/\\n\\n+/g, '\\n\\n').replace(/\\n*$/, '\\n\\n\\n') + code;\n  }\n\n  /**\n   * Naked values are top-level blocks with outputs that aren't plugged into\n   * anything.\n   *\n   * @param line Line of generated code.\n   * @returns Legal line of code.\n   */\n  scrubNakedValue(line: string): string {\n    return line + ';\\n';\n  }\n\n  /**\n   * Encode a string as a properly escaped Dart string, complete with quotes.\n   *\n   * @param string Text to encode.\n   * @returns Dart string.\n   */\n  quote_(string: string): string {\n    // Can't use goog.string.quote since $ must also be escaped.\n    string = string\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\n/g, '\\\\\\n')\n      .replace(/\\$/g, '\\\\$')\n      .replace(/'/g, \"\\\\'\");\n    return \"'\" + string + \"'\";\n  }\n\n  /**\n   * Encode a string as a properly escaped multiline Dart string, complete\n   * with quotes.\n   *\n   * @param string Text to encode.\n   * @returns Dart string.\n   */\n  multiline_quote_(string: string): string {\n    const lines = string.split(/\\n/g).map(this.quote_);\n    // Join with the following, plus a newline:\n    // + '\\n' +\n    return lines.join(\" + '\\\\n' + \\n\");\n  }\n\n  /**\n   * Common tasks for generating Dart from blocks.\n   * Handles comments for the specified block and any connected value blocks.\n   * Calls any statements following this block.\n   *\n   * @param block The current block.\n   * @param code The Dart code created for this block.\n   * @param thisOnly True to generate code for only this statement.\n   * @returns Dart code with comments and subsequent blocks added.\n   */\n  scrub_(block: Block, code: string, thisOnly = false): string {\n    let commentCode = '';\n    // Only collect comments for blocks that aren't inline.\n    if (!block.outputConnection || !block.outputConnection.targetConnection) {\n      // Collect comment for this block.\n      let comment = block.getCommentText();\n      if (comment) {\n        comment = stringUtils.wrap(comment, this.COMMENT_WRAP - 3);\n        if ((block as AnyDuringMigration).getProcedureDef) {\n          // Use documentation comment for function comments.\n          commentCode += this.prefixLines(comment + '\\n', '/// ');\n        } else {\n          commentCode += this.prefixLines(comment + '\\n', '// ');\n        }\n      }\n      // Collect comments for all value arguments.\n      // Don't collect comments for nested statements.\n      for (let i = 0; i < block.inputList.length; i++) {\n        if (block.inputList[i].type === inputTypes.VALUE) {\n          const childBlock = block.inputList[i].connection!.targetBlock();\n          if (childBlock) {\n            comment = this.allNestedComments(childBlock);\n            if (comment) {\n              commentCode += this.prefixLines(comment, '// ');\n            }\n          }\n        }\n      }\n    }\n    const nextBlock =\n      block.nextConnection && block.nextConnection.targetBlock();\n    const nextCode = thisOnly ? '' : this.blockToCode(nextBlock);\n    return commentCode + code + nextCode;\n  }\n\n  /**\n   * Generate code representing the specified value input, adjusted to take into\n   * account indexing (zero- or one-based) and optionally by a specified delta\n   * and/or by negation.\n   *\n   * @param block The block.\n   * @param atId The ID of the input block to get (and adjust) the value of.\n   * @param delta Value to add.\n   * @param negate Whether to negate the value.\n   * @param order The highest order acting on this value.\n   * @returns The adjusted value or code that evaluates to it.\n   */\n  getAdjusted(\n    block: Block,\n    atId: string,\n    delta = 0,\n    negate = false,\n    order = Order.NONE,\n  ): string {\n    if (block.workspace.options.oneBasedIndex) {\n      delta--;\n    }\n    const defaultAtIndex = block.workspace.options.oneBasedIndex ? '1' : '0';\n\n    let orderForInput = order;\n    if (delta) {\n      orderForInput = Order.ADDITIVE;\n    } else if (negate) {\n      orderForInput = Order.UNARY_PREFIX;\n    }\n\n    let at = this.valueToCode(block, atId, orderForInput) || defaultAtIndex;\n\n    // Easy case: no adjustments.\n    if (delta === 0 && !negate) {\n      return at;\n    }\n    // If the index is a naked number, adjust it right now.\n    if (stringUtils.isNumber(at)) {\n      at = String(Number(at) + delta);\n      if (negate) {\n        at = String(-Number(at));\n      }\n      return at;\n    }\n    // If the index is dynamic, adjust it in code.\n    if (delta > 0) {\n      at = `${at} + ${delta}`;\n    } else if (delta < 0) {\n      at = `${at} - ${-delta}`;\n    }\n    if (negate) {\n      at = delta ? `-(${at})` : `-${at}`;\n    }\n    if (Math.floor(order) >= Math.floor(orderForInput)) {\n      at = `(${at})`;\n    }\n    return at;\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Dart for dynamic variable blocks.\n */\n\n// Former goog.module ID: Blockly.Dart.variablesDynamic\n\n// generator is dynamically typed.\nexport {\n  variables_get as variables_get_dynamic,\n  variables_set as variables_set_dynamic,\n} from './variables.js';\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Instantiate a DartGenerator and populate it with the complete\n * set of block generator functions for Dart.  This is the entrypoint\n * for dart_compressed.js.\n */\n\n// Former goog.module ID: Blockly.Dart.all\n\nimport {DartGenerator} from './dart/dart_generator.js';\nimport * as lists from './dart/lists.js';\nimport * as logic from './dart/logic.js';\nimport * as loops from './dart/loops.js';\nimport * as math from './dart/math.js';\nimport * as procedures from './dart/procedures.js';\nimport * as text from './dart/text.js';\nimport * as variables from './dart/variables.js';\nimport * as variablesDynamic from './dart/variables_dynamic.js';\n\nexport * from './dart/dart_generator.js';\n\n/**\n * Dart code generator instance.\n * @type {!DartGenerator}\n */\nexport const dartGenerator = new DartGenerator();\n\n// Add reserved words.  This list should include all words mentioned\n// in RESERVED WORDS: comments in the imports above.\ndartGenerator.addReservedWords('Html,Math');\n\n// Install per-block-type generator functions:\nconst generators: typeof dartGenerator.forBlock = {\n  ...lists,\n  ...logic,\n  ...loops,\n  ...math,\n  ...procedures,\n  ...text,\n  ...variables,\n  ...variablesDynamic,\n};\nfor (const name in generators) {\n  dartGenerator.forBlock[name] = generators[name];\n}\n", "/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Lua for list blocks.\n */\n\n// Former goog.module ID: Blockly.Lua.lists\n\nimport type {CreateWithBlock} from '../../blocks/lists.js';\nimport type {Block} from '../../core/block.js';\nimport {NameType} from '../../core/names.js';\nimport type {LuaGenerator} from './lua_generator.js';\nimport {Order} from './lua_generator.js';\n\nexport function lists_create_empty(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Create an empty list.\n  return ['{}', Order.HIGH];\n}\n\nexport function lists_create_with(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  const createWithBlock = block as CreateWithBlock;\n  // Create a list with any number of elements of any type.\n  const elements = new Array(createWithBlock.itemCount_);\n  for (let i = 0; i < createWithBlock.itemCount_; i++) {\n    elements[i] =\n      generator.valueToCode(createWithBlock, 'ADD' + i, Order.NONE) || 'nil';\n  }\n  const code = '{' + elements.join(', ') + '}';\n  return [code, Order.HIGH];\n}\n\nexport function lists_repeat(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Create a list with one element repeated.\n  const functionName = generator.provideFunction_(\n    'create_list_repeated',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(item, count)\n  local t = {}\n  for i = 1, count do\n    table.insert(t, item)\n  end\n  return t\nend\n  `,\n  );\n  const element = generator.valueToCode(block, 'ITEM', Order.NONE) || 'nil';\n  const repeatCount = generator.valueToCode(block, 'NUM', Order.NONE) || '0';\n  const code = functionName + '(' + element + ', ' + repeatCount + ')';\n  return [code, Order.HIGH];\n}\n\nexport function lists_length(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // String or array length.\n  const list = generator.valueToCode(block, 'VALUE', Order.UNARY) || '{}';\n  return ['#' + list, Order.UNARY];\n}\n\nexport function lists_isEmpty(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Is the string null or array empty?\n  const list = generator.valueToCode(block, 'VALUE', Order.UNARY) || '{}';\n  const code = '#' + list + ' == 0';\n  return [code, Order.RELATIONAL];\n}\n\nexport function lists_indexOf(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Find an item in the list.\n  const item = generator.valueToCode(block, 'FIND', Order.NONE) || \"''\";\n  const list = generator.valueToCode(block, 'VALUE', Order.NONE) || '{}';\n  let functionName;\n  if (block.getFieldValue('END') === 'FIRST') {\n    functionName = generator.provideFunction_(\n      'first_index',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t, elem)\n  for k, v in ipairs(t) do\n    if v == elem then\n      return k\n    end\n  end\n  return 0\nend\n`,\n    );\n  } else {\n    functionName = generator.provideFunction_(\n      'last_index',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t, elem)\n  for i = #t, 1, -1 do\n    if t[i] == elem then\n      return i\n    end\n  end\n  return 0\nend\n`,\n    );\n  }\n  const code = functionName + '(' + list + ', ' + item + ')';\n  return [code, Order.HIGH];\n}\n\n/**\n * Returns an expression calculating the index into a list.\n *\n * @param listName Name of the list, used to calculate length.\n * @param where The method of indexing, selected by dropdown in Blockly\n * @param opt_at The optional offset when indexing from start/end.\n * @returns Index expression.\n */\nconst getListIndex = function (\n  listName: string,\n  where: string,\n  opt_at: string,\n): string {\n  if (where === 'FIRST') {\n    return '1';\n  } else if (where === 'FROM_END') {\n    return '#' + listName + ' + 1 - ' + opt_at;\n  } else if (where === 'LAST') {\n    return '#' + listName;\n  } else if (where === 'RANDOM') {\n    return 'math.random(#' + listName + ')';\n  } else {\n    return opt_at;\n  }\n};\n\nexport function lists_getIndex(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] | string {\n  // Get element at index.\n  // Note: Until January 2013 this block did not have MODE or WHERE inputs.\n  const mode = block.getFieldValue('MODE') || 'GET';\n  const where = block.getFieldValue('WHERE') || 'FROM_START';\n  const list = generator.valueToCode(block, 'VALUE', Order.HIGH) || '({})';\n\n  // If `list` would be evaluated more than once (which is the case for LAST,\n  // FROM_END, and RANDOM) and is non-trivial, make sure to access it only once.\n  if (\n    (where === 'LAST' || where === 'FROM_END' || where === 'RANDOM') &&\n    !list.match(/^\\w+$/)\n  ) {\n    // `list` is an expression, so we may not evaluate it more than once.\n    if (mode === 'REMOVE') {\n      // We can use multiple statements.\n      const atOrder = where === 'FROM_END' ? Order.ADDITIVE : Order.NONE;\n      let at = generator.valueToCode(block, 'AT', atOrder) || '1';\n      const listVar = generator.nameDB_!.getDistinctName(\n        'tmp_list',\n        NameType.VARIABLE,\n      );\n      at = getListIndex(listVar, where, at);\n      const code =\n        listVar +\n        ' = ' +\n        list +\n        '\\n' +\n        'table.remove(' +\n        listVar +\n        ', ' +\n        at +\n        ')\\n';\n      return code;\n    } else {\n      // We need to create a procedure to avoid reevaluating values.\n      const at = generator.valueToCode(block, 'AT', Order.NONE) || '1';\n      let functionName;\n      if (mode === 'GET') {\n        functionName = generator.provideFunction_(\n          'list_get_' + where.toLowerCase(),\n          [\n            'function ' +\n              generator.FUNCTION_NAME_PLACEHOLDER_ +\n              '(t' +\n              // The value for 'FROM_END' and'FROM_START' depends on `at` so\n              // we add it as a parameter.\n              (where === 'FROM_END' || where === 'FROM_START' ? ', at)' : ')'),\n            '  return t[' + getListIndex('t', where, 'at') + ']',\n            'end',\n          ],\n        );\n      } else {\n        // `mode` === 'GET_REMOVE'\n        functionName = generator.provideFunction_(\n          'list_remove_' + where.toLowerCase(),\n          [\n            'function ' +\n              generator.FUNCTION_NAME_PLACEHOLDER_ +\n              '(t' +\n              // The value for 'FROM_END' and'FROM_START' depends on `at` so\n              // we add it as a parameter.\n              (where === 'FROM_END' || where === 'FROM_START' ? ', at)' : ')'),\n            '  return table.remove(t, ' + getListIndex('t', where, 'at') + ')',\n            'end',\n          ],\n        );\n      }\n      const code =\n        functionName +\n        '(' +\n        list +\n        // The value for 'FROM_END' and 'FROM_START' depends on `at` so we\n        // pass it.\n        (where === 'FROM_END' || where === 'FROM_START' ? ', ' + at : '') +\n        ')';\n      return [code, Order.HIGH];\n    }\n  } else {\n    // Either `list` is a simple variable, or we only need to refer to `list`\n    // once.\n    const atOrder =\n      mode === 'GET' && where === 'FROM_END' ? Order.ADDITIVE : Order.NONE;\n    let at = generator.valueToCode(block, 'AT', atOrder) || '1';\n    at = getListIndex(list, where, at);\n    if (mode === 'GET') {\n      const code = list + '[' + at + ']';\n      return [code, Order.HIGH];\n    } else {\n      const code = 'table.remove(' + list + ', ' + at + ')';\n      if (mode === 'GET_REMOVE') {\n        return [code, Order.HIGH];\n      } else {\n        // `mode` === 'REMOVE'\n        return code + '\\n';\n      }\n    }\n  }\n}\n\nexport function lists_setIndex(block: Block, generator: LuaGenerator): string {\n  // Set element at index.\n  // Note: Until February 2013 this block did not have MODE or WHERE inputs.\n  let list = generator.valueToCode(block, 'LIST', Order.HIGH) || '{}';\n  const mode = block.getFieldValue('MODE') || 'SET';\n  const where = block.getFieldValue('WHERE') || 'FROM_START';\n  const at = generator.valueToCode(block, 'AT', Order.ADDITIVE) || '1';\n  const value = generator.valueToCode(block, 'TO', Order.NONE) || 'Nil';\n\n  let code = '';\n  // If `list` would be evaluated more than once (which is the case for LAST,\n  // FROM_END, and RANDOM) and is non-trivial, make sure to access it only once.\n  if (\n    (where === 'LAST' || where === 'FROM_END' || where === 'RANDOM') &&\n    !list.match(/^\\w+$/)\n  ) {\n    // `list` is an expression, so we may not evaluate it more than once.\n    // We can use multiple statements.\n    const listVar = generator.nameDB_!.getDistinctName(\n      'tmp_list',\n      NameType.VARIABLE,\n    );\n    code = listVar + ' = ' + list + '\\n';\n    list = listVar;\n  }\n  if (mode === 'SET') {\n    code += list + '[' + getListIndex(list, where, at) + '] = ' + value;\n  } else {\n    // `mode` === 'INSERT'\n    // LAST is a special case, because we want to insert\n    // *after* not *before*, the existing last element.\n    code +=\n      'table.insert(' +\n      list +\n      ', ' +\n      (getListIndex(list, where, at) + (where === 'LAST' ? ' + 1' : '')) +\n      ', ' +\n      value +\n      ')';\n  }\n  return code + '\\n';\n}\n\nexport function lists_getSublist(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Get sublist.\n  const list = generator.valueToCode(block, 'LIST', Order.NONE) || '{}';\n  const where1 = block.getFieldValue('WHERE1');\n  const where2 = block.getFieldValue('WHERE2');\n  const at1 = generator.valueToCode(block, 'AT1', Order.NONE) || '1';\n  const at2 = generator.valueToCode(block, 'AT2', Order.NONE) || '1';\n\n  // The value for 'FROM_END' and'FROM_START' depends on `at` so\n  // we add it as a parameter.\n  const at1Param =\n    where1 === 'FROM_END' || where1 === 'FROM_START' ? ', at1' : '';\n  const at2Param =\n    where2 === 'FROM_END' || where2 === 'FROM_START' ? ', at2' : '';\n  const functionName = generator.provideFunction_(\n    'list_sublist_' + where1.toLowerCase() + '_' + where2.toLowerCase(),\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(source${at1Param}${at2Param})\n  local t = {}\n  local start = ${getListIndex('source', where1, 'at1')}\n  local finish = ${getListIndex('source', where2, 'at2')}\n  for i = start, finish do\n    table.insert(t, source[i])\n  end\n  return t\nend\n`,\n  );\n  const code =\n    functionName +\n    '(' +\n    list +\n    // The value for 'FROM_END' and 'FROM_START' depends on `at` so we\n    // pass it.\n    (where1 === 'FROM_END' || where1 === 'FROM_START' ? ', ' + at1 : '') +\n    (where2 === 'FROM_END' || where2 === 'FROM_START' ? ', ' + at2 : '') +\n    ')';\n  return [code, Order.HIGH];\n}\n\nexport function lists_sort(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Block for sorting a list.\n  const list = generator.valueToCode(block, 'LIST', Order.NONE) || '{}';\n  const direction = block.getFieldValue('DIRECTION') === '1' ? 1 : -1;\n  const type = block.getFieldValue('TYPE');\n\n  const functionName = generator.provideFunction_(\n    'list_sort',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(list, typev, direction)\n  local t = {}\n  for n,v in pairs(list) do table.insert(t, v) end\n  local compareFuncs = {\n    NUMERIC = function(a, b)\n      return (tonumber(tostring(a)) or 0)\n          < (tonumber(tostring(b)) or 0) end,\n    TEXT = function(a, b)\n      return tostring(a) < tostring(b) end,\n    IGNORE_CASE = function(a, b)\n      return string.lower(tostring(a)) < string.lower(tostring(b)) end\n  }\n  local compareTemp = compareFuncs[typev]\n  local compare = compareTemp\n  if direction == -1\n  then compare = function(a, b) return compareTemp(b, a) end\n  end\n  table.sort(t, compare)\n  return t\nend\n`,\n  );\n\n  const code =\n    functionName + '(' + list + ',\"' + type + '\", ' + direction + ')';\n  return [code, Order.HIGH];\n}\n\nexport function lists_split(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Block for splitting text into a list, or joining a list into text.\n  let input = generator.valueToCode(block, 'INPUT', Order.NONE);\n  const delimiter = generator.valueToCode(block, 'DELIM', Order.NONE) || \"''\";\n  const mode = block.getFieldValue('MODE');\n  let functionName;\n  if (mode === 'SPLIT') {\n    if (!input) {\n      input = \"''\";\n    }\n    functionName = generator.provideFunction_(\n      'list_string_split',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(input, delim)\n  local t = {}\n  local pos = 1\n  while true do\n    next_delim = string.find(input, delim, pos)\n    if next_delim == nil then\n      table.insert(t, string.sub(input, pos))\n      break\n    else\n      table.insert(t, string.sub(input, pos, next_delim-1))\n      pos = next_delim + #delim\n    end\n  end\n  return t\nend\n`,\n    );\n  } else if (mode === 'JOIN') {\n    if (!input) {\n      input = '{}';\n    }\n    functionName = 'table.concat';\n  } else {\n    throw Error('Unknown mode: ' + mode);\n  }\n  const code = functionName + '(' + input + ', ' + delimiter + ')';\n  return [code, Order.HIGH];\n}\n\nexport function lists_reverse(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Block for reversing a list.\n  const list = generator.valueToCode(block, 'LIST', Order.NONE) || '{}';\n  const functionName = generator.provideFunction_(\n    'list_reverse',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(input)\n  local reversed = {}\n  for i = #input, 1, -1 do\n    table.insert(reversed, input[i])\n  end\n  return reversed\nend\n`,\n  );\n  const code = functionName + '(' + list + ')';\n  return [code, Order.HIGH];\n}\n", "/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Lua for logic blocks.\n */\n\n// Former goog.module ID: Blockly.Lua.logic\n\nimport type {Block} from '../../core/block.js';\nimport type {LuaGenerator} from './lua_generator.js';\nimport {Order} from './lua_generator.js';\n\nexport function controls_if(block: Block, generator: LuaGenerator): string {\n  // If/elseif/else condition.\n  let n = 0;\n  let code = '';\n  if (generator.STATEMENT_PREFIX) {\n    // Automatic prefix insertion is switched off for this block.  Add manually.\n    code += generator.injectId(generator.STATEMENT_PREFIX, block);\n  }\n  do {\n    const conditionCode =\n      generator.valueToCode(block, 'IF' + n, Order.NONE) || 'false';\n    let branchCode = generator.statementToCode(block, 'DO' + n);\n    if (generator.STATEMENT_SUFFIX) {\n      branchCode =\n        generator.prefixLines(\n          generator.injectId(generator.STATEMENT_SUFFIX, block),\n          generator.INDENT,\n        ) + branchCode;\n    }\n    code +=\n      (n > 0 ? 'else' : '') + 'if ' + conditionCode + ' then\\n' + branchCode;\n    n++;\n  } while (block.getInput('IF' + n));\n\n  if (block.getInput('ELSE') || generator.STATEMENT_SUFFIX) {\n    let branchCode = block.getInput('ELSE')\n      ? generator.statementToCode(block, 'ELSE')\n      : '';\n    if (generator.STATEMENT_SUFFIX) {\n      branchCode =\n        generator.prefixLines(\n          generator.injectId(generator.STATEMENT_SUFFIX, block),\n          generator.INDENT,\n        ) + branchCode;\n    }\n    code += 'else\\n' + branchCode;\n  }\n  return code + 'end\\n';\n}\n\nexport const controls_ifelse = controls_if;\n\nexport function logic_compare(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Comparison operator.\n  const OPERATORS = {\n    'EQ': '==',\n    'NEQ': '~=',\n    'LT': '<',\n    'LTE': '<=',\n    'GT': '>',\n    'GTE': '>=',\n  };\n  type OperatorOption = keyof typeof OPERATORS;\n  const operator = OPERATORS[block.getFieldValue('OP') as OperatorOption];\n  const argument0 = generator.valueToCode(block, 'A', Order.RELATIONAL) || '0';\n  const argument1 = generator.valueToCode(block, 'B', Order.RELATIONAL) || '0';\n  const code = argument0 + ' ' + operator + ' ' + argument1;\n  return [code, Order.RELATIONAL];\n}\n\nexport function logic_operation(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Operations 'and', 'or'.\n  const operator = block.getFieldValue('OP') === 'AND' ? 'and' : 'or';\n  const order = operator === 'and' ? Order.AND : Order.OR;\n  let argument0 = generator.valueToCode(block, 'A', order);\n  let argument1 = generator.valueToCode(block, 'B', order);\n  if (!argument0 && !argument1) {\n    // If there are no arguments, then the return value is false.\n    argument0 = 'false';\n    argument1 = 'false';\n  } else {\n    // Single missing arguments have no effect on the return value.\n    const defaultArgument = operator === 'and' ? 'true' : 'false';\n    if (!argument0) {\n      argument0 = defaultArgument;\n    }\n    if (!argument1) {\n      argument1 = defaultArgument;\n    }\n  }\n  const code = argument0 + ' ' + operator + ' ' + argument1;\n  return [code, order];\n}\n\nexport function logic_negate(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Negation.\n  const argument0 = generator.valueToCode(block, 'BOOL', Order.UNARY) || 'true';\n  const code = 'not ' + argument0;\n  return [code, Order.UNARY];\n}\n\nexport function logic_boolean(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Boolean values true and false.\n  const code = block.getFieldValue('BOOL') === 'TRUE' ? 'true' : 'false';\n  return [code, Order.ATOMIC];\n}\n\nexport function logic_null(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Null data type.\n  return ['nil', Order.ATOMIC];\n}\n\nexport function logic_ternary(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Ternary operator.\n  const value_if = generator.valueToCode(block, 'IF', Order.AND) || 'false';\n  const value_then = generator.valueToCode(block, 'THEN', Order.AND) || 'nil';\n  const value_else = generator.valueToCode(block, 'ELSE', Order.OR) || 'nil';\n  const code = value_if + ' and ' + value_then + ' or ' + value_else;\n  return [code, Order.OR];\n}\n", "/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Lua for loop blocks.\n */\n\n// Former goog.module ID: Blockly.Lua.loops\n\nimport type {ControlFlowInLoopBlock} from '../../blocks/loops.js';\nimport type {Block} from '../../core/block.js';\nimport {NameType} from '../../core/names.js';\nimport * as stringUtils from '../../core/utils/string.js';\nimport type {LuaGenerator} from './lua_generator.js';\nimport {Order} from './lua_generator.js';\n\n/**\n * This is the text used to implement a <pre>continue</pre>.\n * It is also used to recognise <pre>continue</pre>s in generated code so that\n * the appropriate label can be put at the end of the loop body.\n */\nconst CONTINUE_STATEMENT = 'goto continue\\n';\n\n/**\n * If the loop body contains a \"goto continue\" statement, add a continue label\n * to the loop body. Slightly inefficient, as continue labels will be generated\n * in all outer loops, but this is safer than duplicating the logic of\n * blockToCode.\n *\n * @param branch Generated code of the loop body\n * @param indent Whitespace by which to indent a continue statement.\n * @returns Generated label or '' if unnecessary\n */\nfunction addContinueLabel(branch: string, indent: string): string {\n  if (branch.includes(CONTINUE_STATEMENT)) {\n    // False positives are possible (e.g. a string literal), but are harmless.\n    return branch + indent + '::continue::\\n';\n  } else {\n    return branch;\n  }\n}\n\nexport function controls_repeat_ext(\n  block: Block,\n  generator: LuaGenerator,\n): string {\n  // Repeat n times.\n  let repeats;\n  if (block.getField('TIMES')) {\n    // Internal number.\n    repeats = String(Number(block.getFieldValue('TIMES')));\n  } else {\n    // External number.\n    repeats = generator.valueToCode(block, 'TIMES', Order.NONE) || '0';\n  }\n  if (stringUtils.isNumber(repeats)) {\n    repeats = parseInt(repeats, 10);\n  } else {\n    repeats = 'math.floor(' + repeats + ')';\n  }\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  branch = addContinueLabel(branch, generator.INDENT);\n  const loopVar = generator.nameDB_!.getDistinctName(\n    'count',\n    NameType.VARIABLE,\n  );\n  const code =\n    'for ' + loopVar + ' = 1, ' + repeats + ' do\\n' + branch + 'end\\n';\n  return code;\n}\n\nexport const controls_repeat = controls_repeat_ext;\n\nexport function controls_whileUntil(\n  block: Block,\n  generator: LuaGenerator,\n): string {\n  // Do while/until loop.\n  const until = block.getFieldValue('MODE') === 'UNTIL';\n  let argument0 =\n    generator.valueToCode(block, 'BOOL', until ? Order.UNARY : Order.NONE) ||\n    'false';\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  branch = addContinueLabel(branch, generator.INDENT);\n  if (until) {\n    argument0 = 'not ' + argument0;\n  }\n  return 'while ' + argument0 + ' do\\n' + branch + 'end\\n';\n}\n\nexport function controls_for(block: Block, generator: LuaGenerator): string {\n  // For loop.\n  const variable0 = generator.getVariableName(block.getFieldValue('VAR'));\n  const startVar = generator.valueToCode(block, 'FROM', Order.NONE) || '0';\n  const endVar = generator.valueToCode(block, 'TO', Order.NONE) || '0';\n  const increment = generator.valueToCode(block, 'BY', Order.NONE) || '1';\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  branch = addContinueLabel(branch, generator.INDENT);\n  let code = '';\n  let incValue;\n  if (\n    stringUtils.isNumber(startVar) &&\n    stringUtils.isNumber(endVar) &&\n    stringUtils.isNumber(increment)\n  ) {\n    // All arguments are simple numbers.\n    const up = Number(startVar) <= Number(endVar);\n    const step = Math.abs(Number(increment));\n    incValue = (up ? '' : '-') + step;\n  } else {\n    code = '';\n    // Determine loop direction at start, in case one of the bounds\n    // changes during loop execution.\n    incValue = generator.nameDB_!.getDistinctName(\n      variable0 + '_inc',\n      NameType.VARIABLE,\n    );\n    code += incValue + ' = ';\n    if (stringUtils.isNumber(increment)) {\n      code += Math.abs(increment as unknown as number) + '\\n';\n    } else {\n      code += 'math.abs(' + increment + ')\\n';\n    }\n    code += 'if (' + startVar + ') > (' + endVar + ') then\\n';\n    code += generator.INDENT + incValue + ' = -' + incValue + '\\n';\n    code += 'end\\n';\n  }\n  code +=\n    'for ' + variable0 + ' = ' + startVar + ', ' + endVar + ', ' + incValue;\n  code += ' do\\n' + branch + 'end\\n';\n  return code;\n}\n\nexport function controls_forEach(\n  block: Block,\n  generator: LuaGenerator,\n): string {\n  // For each loop.\n  const variable0 = generator.getVariableName(block.getFieldValue('VAR'));\n  const argument0 = generator.valueToCode(block, 'LIST', Order.NONE) || '{}';\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  branch = addContinueLabel(branch, generator.INDENT);\n  const code =\n    'for _, ' +\n    variable0 +\n    ' in ipairs(' +\n    argument0 +\n    ') do \\n' +\n    branch +\n    'end\\n';\n  return code;\n}\n\nexport function controls_flow_statements(\n  block: Block,\n  generator: LuaGenerator,\n): string {\n  // Flow statements: continue, break.\n  let xfix = '';\n  if (generator.STATEMENT_PREFIX) {\n    // Automatic prefix insertion is switched off for this block.  Add manually.\n    xfix += generator.injectId(generator.STATEMENT_PREFIX, block);\n  }\n  if (generator.STATEMENT_SUFFIX) {\n    // Inject any statement suffix here since the regular one at the end\n    // will not get executed if the break/continue is triggered.\n    xfix += generator.injectId(generator.STATEMENT_SUFFIX, block);\n  }\n  if (generator.STATEMENT_PREFIX) {\n    const loop = (block as ControlFlowInLoopBlock).getSurroundLoop();\n    if (loop && !loop.suppressPrefixSuffix) {\n      // Inject loop's statement prefix here since the regular one at the end\n      // of the loop will not get executed if 'continue' is triggered.\n      // In the case of 'break', a prefix is needed due to the loop's suffix.\n      xfix += generator.injectId(generator.STATEMENT_PREFIX, loop);\n    }\n  }\n  switch (block.getFieldValue('FLOW')) {\n    case 'BREAK':\n      return xfix + 'break\\n';\n    case 'CONTINUE':\n      return xfix + CONTINUE_STATEMENT;\n  }\n  throw Error('Unknown flow statement.');\n}\n", "/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Lua for math blocks.\n */\n\n// Former goog.module ID: Blockly.Lua.math\n\nimport type {Block} from '../../core/block.js';\nimport type {LuaGenerator} from './lua_generator.js';\nimport {Order} from './lua_generator.js';\n\nexport function math_number(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Numeric value.\n  const code = Number(block.getFieldValue('NUM'));\n  const order = code < 0 ? Order.UNARY : Order.ATOMIC;\n  return [String(code), order];\n}\n\nexport function math_arithmetic(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Basic arithmetic operators, and power.\n  const OPERATORS: Record<string, [string, Order]> = {\n    'ADD': [' + ', Order.ADDITIVE],\n    'MINUS': [' - ', Order.ADDITIVE],\n    'MULTIPLY': [' * ', Order.MULTIPLICATIVE],\n    'DIVIDE': [' / ', Order.MULTIPLICATIVE],\n    'POWER': [' ^ ', Order.EXPONENTIATION],\n  };\n  type OperatorOption = keyof typeof OPERATORS;\n  const tuple = OPERATORS[block.getFieldValue('OP') as OperatorOption];\n  const operator = tuple[0];\n  const order = tuple[1];\n  const argument0 = generator.valueToCode(block, 'A', order) || '0';\n  const argument1 = generator.valueToCode(block, 'B', order) || '0';\n  const code = argument0 + operator + argument1;\n  return [code, order];\n}\n\nexport function math_single(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Math operators with single operand.\n  const operator = block.getFieldValue('OP');\n  let arg;\n  if (operator === 'NEG') {\n    // Negation is a special case given its different operator precedence.\n    arg = generator.valueToCode(block, 'NUM', Order.UNARY) || '0';\n    return ['-' + arg, Order.UNARY];\n  }\n  if (operator === 'POW10') {\n    arg = generator.valueToCode(block, 'NUM', Order.EXPONENTIATION) || '0';\n    return ['10 ^ ' + arg, Order.EXPONENTIATION];\n  }\n  if (operator === 'ROUND') {\n    arg = generator.valueToCode(block, 'NUM', Order.ADDITIVE) || '0';\n  } else {\n    arg = generator.valueToCode(block, 'NUM', Order.NONE) || '0';\n  }\n\n  let code;\n  switch (operator) {\n    case 'ABS':\n      code = 'math.abs(' + arg + ')';\n      break;\n    case 'ROOT':\n      code = 'math.sqrt(' + arg + ')';\n      break;\n    case 'LN':\n      code = 'math.log(' + arg + ')';\n      break;\n    case 'LOG10':\n      code = 'math.log(' + arg + ', 10)';\n      break;\n    case 'EXP':\n      code = 'math.exp(' + arg + ')';\n      break;\n    case 'ROUND':\n      // This rounds up.  Blockly does not specify rounding direction.\n      code = 'math.floor(' + arg + ' + .5)';\n      break;\n    case 'ROUNDUP':\n      code = 'math.ceil(' + arg + ')';\n      break;\n    case 'ROUNDDOWN':\n      code = 'math.floor(' + arg + ')';\n      break;\n    case 'SIN':\n      code = 'math.sin(math.rad(' + arg + '))';\n      break;\n    case 'COS':\n      code = 'math.cos(math.rad(' + arg + '))';\n      break;\n    case 'TAN':\n      code = 'math.tan(math.rad(' + arg + '))';\n      break;\n    case 'ASIN':\n      code = 'math.deg(math.asin(' + arg + '))';\n      break;\n    case 'ACOS':\n      code = 'math.deg(math.acos(' + arg + '))';\n      break;\n    case 'ATAN':\n      code = 'math.deg(math.atan(' + arg + '))';\n      break;\n    default:\n      throw Error('Unknown math operator: ' + operator);\n  }\n  return [code, Order.HIGH];\n}\n\nexport function math_constant(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Constants: PI, E, the Golden Ratio, sqrt(2), 1/sqrt(2), INFINITY.\n  const CONSTANTS: Record<string, [string, Order]> = {\n    'PI': ['math.pi', Order.HIGH],\n    'E': ['math.exp(1)', Order.HIGH],\n    'GOLDEN_RATIO': ['(1 + math.sqrt(5)) / 2', Order.MULTIPLICATIVE],\n    'SQRT2': ['math.sqrt(2)', Order.HIGH],\n    'SQRT1_2': ['math.sqrt(1 / 2)', Order.HIGH],\n    'INFINITY': ['math.huge', Order.HIGH],\n  };\n  return CONSTANTS[block.getFieldValue('CONSTANT')];\n}\n\nexport function math_number_property(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Check if a number is even, odd, prime, whole, positive, or negative\n  // or if it is divisible by certain number. Returns true or false.\n  const PROPERTIES: Record<string, [string | null, Order, Order]> = {\n    'EVEN': [' % 2 == 0', Order.MULTIPLICATIVE, Order.RELATIONAL],\n    'ODD': [' % 2 == 1', Order.MULTIPLICATIVE, Order.RELATIONAL],\n    'WHOLE': [' % 1 == 0', Order.MULTIPLICATIVE, Order.RELATIONAL],\n    'POSITIVE': [' > 0', Order.RELATIONAL, Order.RELATIONAL],\n    'NEGATIVE': [' < 0', Order.RELATIONAL, Order.RELATIONAL],\n    'DIVISIBLE_BY': [null, Order.MULTIPLICATIVE, Order.RELATIONAL],\n    'PRIME': [null, Order.NONE, Order.HIGH],\n  };\n  const dropdownProperty = block.getFieldValue('PROPERTY');\n  const [suffix, inputOrder, outputOrder] = PROPERTIES[dropdownProperty];\n  const numberToCheck =\n    generator.valueToCode(block, 'NUMBER_TO_CHECK', inputOrder) || '0';\n  let code;\n  if (dropdownProperty === 'PRIME') {\n    // Prime is a special case as it is not a one-liner test.\n    const functionName = generator.provideFunction_(\n      'math_isPrime',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(n)\n  -- https://en.wikipedia.org/wiki/Primality_test#Naive_methods\n  if n == 2 or n == 3 then\n    return true\n  end\n  -- False if n is NaN, negative, is 1, or not whole.\n  -- And false if n is divisible by 2 or 3.\n  if not(n > 1) or n % 1 ~= 0 or n % 2 == 0 or n % 3 == 0 then\n    return false\n  end\n  -- Check all the numbers of form 6k +/- 1, up to sqrt(n).\n  for x = 6, math.sqrt(n) + 1.5, 6 do\n    if n % (x - 1) == 0 or n % (x + 1) == 0 then\n      return false\n    end\n  end\n  return true\nend\n`,\n    );\n    code = functionName + '(' + numberToCheck + ')';\n  } else if (dropdownProperty === 'DIVISIBLE_BY') {\n    const divisor =\n      generator.valueToCode(block, 'DIVISOR', Order.MULTIPLICATIVE) || '0';\n    // If 'divisor' is some code that evals to 0, generator will produce a nan.\n    // Let's produce nil if we can determine this at compile-time.\n    if (divisor === '0') {\n      return ['nil', Order.ATOMIC];\n    }\n    // The normal trick to implement ?: with and/or doesn't work here:\n    //   divisor == 0 and nil or number_to_check % divisor == 0\n    // because nil is false, so allow a runtime failure. :-(\n    code = numberToCheck + ' % ' + divisor + ' == 0';\n  } else {\n    code = numberToCheck + suffix;\n  }\n  return [code, outputOrder];\n}\n\nexport function math_change(block: Block, generator: LuaGenerator): string {\n  // Add to a variable in place.\n  const argument0 =\n    generator.valueToCode(block, 'DELTA', Order.ADDITIVE) || '0';\n  const varName = generator.getVariableName(block.getFieldValue('VAR'));\n  return varName + ' = ' + varName + ' + ' + argument0 + '\\n';\n}\n\n// Rounding functions have a single operand.\nexport const math_round = math_single;\n// Trigonometry functions have a single operand.\nexport const math_trig = math_single;\n\nexport function math_on_list(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Math functions for lists.\n  const func = block.getFieldValue('OP');\n  const list = generator.valueToCode(block, 'LIST', Order.NONE) || '{}';\n  let functionName;\n\n  // Functions needed in more than one case.\n  function provideSum() {\n    return generator.provideFunction_(\n      'math_sum',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t)\n  local result = 0\n  for _, v in ipairs(t) do\n    result = result + v\n  end\n  return result\nend\n`,\n    );\n  }\n\n  switch (func) {\n    case 'SUM':\n      functionName = provideSum();\n      break;\n\n    case 'MIN':\n      // Returns 0 for the empty list.\n      functionName = generator.provideFunction_(\n        'math_min',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t)\n  if #t == 0 then\n    return 0\n  end\n  local result = math.huge\n  for _, v in ipairs(t) do\n    if v < result then\n      result = v\n    end\n  end\n  return result\nend\n`,\n      );\n      break;\n\n    case 'AVERAGE':\n      // Returns 0 for the empty list.\n      functionName = generator.provideFunction_(\n        'math_average',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t)\n  if #t == 0 then\n    return 0\n  end\n  return ${provideSum()}(t) / #t\nend\n`,\n      );\n      break;\n\n    case 'MAX':\n      // Returns 0 for the empty list.\n      functionName = generator.provideFunction_(\n        'math_max',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t)\n  if #t == 0 then\n    return 0\n  end\n  local result = -math.huge\n  for _, v in ipairs(t) do\n    if v > result then\n      result = v\n    end\n  end\n  return result\nend\n`,\n      );\n      break;\n\n    case 'MEDIAN':\n      // This operation excludes non-numbers.\n      functionName = generator.provideFunction_(\n        'math_median',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t)\n  -- Source: http://lua-users.org/wiki/SimpleStats\n  if #t == 0 then\n    return 0\n  end\n  local temp = {}\n  for _, v in ipairs(t) do\n    if type(v) == 'number' then\n      table.insert(temp, v)\n    end\n  end\n  table.sort(temp)\n  if #temp % 2 == 0 then\n    return (temp[#temp / 2] + temp[(#temp / 2) + 1]) / 2\n  else\n    return temp[math.ceil(#temp / 2)]\n  end\nend\n`,\n      );\n      break;\n\n    case 'MODE':\n      // As a list of numbers can contain more than one mode,\n      // the returned result is provided as an array.\n      // The generator version includes non-numbers.\n      functionName = generator.provideFunction_(\n        'math_modes',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t)\n  -- Source: http://lua-users.org/wiki/SimpleStats\n  local counts = {}\n  for _, v in ipairs(t) do\n    if counts[v] == nil then\n      counts[v] = 1\n    else\n      counts[v] = counts[v] + 1\n    end\n  end\n  local biggestCount = 0\n  for _, v  in pairs(counts) do\n    if v > biggestCount then\n      biggestCount = v\n    end\n  end\n  local temp = {}\n  for k, v in pairs(counts) do\n    if v == biggestCount then\n      table.insert(temp, k)\n    end\n  end\n  return temp\nend\n`,\n      );\n      break;\n\n    case 'STD_DEV':\n      functionName = generator.provideFunction_(\n        'math_standard_deviation',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t)\n  local m\n  local vm\n  local total = 0\n  local count = 0\n  local result\n  m = #t == 0 and 0 or ${provideSum()}(t) / #t\n  for _, v in ipairs(t) do\n    if type(v) == 'number' then\n      vm = v - m\n      total = total + (vm * vm)\n      count = count + 1\n    end\n  end\n  result = math.sqrt(total / (count-1))\n  return result\nend\n`,\n      );\n      break;\n\n    case 'RANDOM':\n      functionName = generator.provideFunction_(\n        'math_random_list',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t)\n  if #t == 0 then\n    return nil\n  end\n  return t[math.random(#t)]\nend\n`,\n      );\n      break;\n\n    default:\n      throw Error('Unknown operator: ' + func);\n  }\n  return [functionName + '(' + list + ')', Order.HIGH];\n}\n\nexport function math_modulo(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Remainder computation.\n  const argument0 =\n    generator.valueToCode(block, 'DIVIDEND', Order.MULTIPLICATIVE) || '0';\n  const argument1 =\n    generator.valueToCode(block, 'DIVISOR', Order.MULTIPLICATIVE) || '0';\n  const code = argument0 + ' % ' + argument1;\n  return [code, Order.MULTIPLICATIVE];\n}\n\nexport function math_constrain(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Constrain a number between two limits.\n  const argument0 = generator.valueToCode(block, 'VALUE', Order.NONE) || '0';\n  const argument1 =\n    generator.valueToCode(block, 'LOW', Order.NONE) || '-math.huge';\n  const argument2 =\n    generator.valueToCode(block, 'HIGH', Order.NONE) || 'math.huge';\n  const code =\n    'math.min(math.max(' +\n    argument0 +\n    ', ' +\n    argument1 +\n    '), ' +\n    argument2 +\n    ')';\n  return [code, Order.HIGH];\n}\n\nexport function math_random_int(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Random integer between [X] and [Y].\n  const argument0 = generator.valueToCode(block, 'FROM', Order.NONE) || '0';\n  const argument1 = generator.valueToCode(block, 'TO', Order.NONE) || '0';\n  const code = 'math.random(' + argument0 + ', ' + argument1 + ')';\n  return [code, Order.HIGH];\n}\n\nexport function math_random_float(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Random fraction between 0 and 1.\n  return ['math.random()', Order.HIGH];\n}\n\nexport function math_atan2(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Arctangent of point (X, Y) in degrees from -180 to 180.\n  const argument0 = generator.valueToCode(block, 'X', Order.NONE) || '0';\n  const argument1 = generator.valueToCode(block, 'Y', Order.NONE) || '0';\n  return [\n    'math.deg(math.atan2(' + argument1 + ', ' + argument0 + '))',\n    Order.HIGH,\n  ];\n}\n", "/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Lua for procedure blocks.\n */\n\n// Former goog.module ID: Blockly.Lua.procedures\n\nimport type {IfReturnBlock} from '../../blocks/procedures.js';\nimport type {Block} from '../../core/block.js';\nimport type {LuaGenerator} from './lua_generator.js';\nimport {Order} from './lua_generator.js';\n\nexport function procedures_defreturn(\n  block: Block,\n  generator: LuaGenerator,\n): null {\n  // Define a procedure with a return value.\n  const funcName = generator.getProcedureName(block.getFieldValue('NAME'));\n  let xfix1 = '';\n  if (generator.STATEMENT_PREFIX) {\n    xfix1 += generator.injectId(generator.STATEMENT_PREFIX, block);\n  }\n  if (generator.STATEMENT_SUFFIX) {\n    xfix1 += generator.injectId(generator.STATEMENT_SUFFIX, block);\n  }\n  if (xfix1) {\n    xfix1 = generator.prefixLines(xfix1, generator.INDENT);\n  }\n  let loopTrap = '';\n  if (generator.INFINITE_LOOP_TRAP) {\n    loopTrap = generator.prefixLines(\n      generator.injectId(generator.INFINITE_LOOP_TRAP, block),\n      generator.INDENT,\n    );\n  }\n  let branch = '';\n  if (block.getInput('STACK')) {\n    // The 'procedures_defreturn' block might not have a STACK input.\n    branch = generator.statementToCode(block, 'STACK');\n  }\n  let returnValue = '';\n  if (block.getInput('RETURN')) {\n    // The 'procedures_defnoreturn' block (which shares this code)\n    // does not have a RETURN input.\n    returnValue = generator.valueToCode(block, 'RETURN', Order.NONE) || '';\n  }\n  let xfix2 = '';\n  if (branch && returnValue) {\n    // After executing the function body, revisit this block for the return.\n    xfix2 = xfix1;\n  }\n  if (returnValue) {\n    returnValue = generator.INDENT + 'return ' + returnValue + '\\n';\n  } else if (!branch) {\n    branch = '';\n  }\n  const args = [];\n  const variables = block.getVars();\n  for (let i = 0; i < variables.length; i++) {\n    args[i] = generator.getVariableName(variables[i]);\n  }\n  let code =\n    'function ' +\n    funcName +\n    '(' +\n    args.join(', ') +\n    ')\\n' +\n    xfix1 +\n    loopTrap +\n    branch +\n    xfix2 +\n    returnValue +\n    'end\\n';\n  code = generator.scrub_(block, code);\n  // Add % so as not to collide with helper functions in definitions list.\n  // TODO(#7600): find better approach than casting to any to override\n  // CodeGenerator declaring .definitions protected.\n  (generator as AnyDuringMigration).definitions_['%' + funcName] = code;\n  return null;\n}\n\n// Defining a procedure without a return value uses the same generator as\n// a procedure with a return value.\nexport const procedures_defnoreturn = procedures_defreturn;\n\nexport function procedures_callreturn(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Call a procedure with a return value.\n  const funcName = generator.getProcedureName(block.getFieldValue('NAME'));\n  const args = [];\n  const variables = block.getVars();\n  for (let i = 0; i < variables.length; i++) {\n    args[i] = generator.valueToCode(block, 'ARG' + i, Order.NONE) || 'nil';\n  }\n  const code = funcName + '(' + args.join(', ') + ')';\n  return [code, Order.HIGH];\n}\n\nexport function procedures_callnoreturn(\n  block: Block,\n  generator: LuaGenerator,\n): string {\n  // Call a procedure with no return value.\n  // Generated code is for a function call as a statement is the same as a\n  // function call as a value, with the addition of line ending.\n  const tuple = generator.forBlock['procedures_callreturn'](\n    block,\n    generator,\n  ) as [string, number];\n  return tuple[0] + '\\n';\n}\n\nexport function procedures_ifreturn(\n  block: Block,\n  generator: LuaGenerator,\n): string {\n  // Conditionally return value from a procedure.\n  const condition =\n    generator.valueToCode(block, 'CONDITION', Order.NONE) || 'false';\n  let code = 'if ' + condition + ' then\\n';\n  if (generator.STATEMENT_SUFFIX) {\n    // Inject any statement suffix here since the regular one at the end\n    // will not get executed if the return is triggered.\n    code += generator.prefixLines(\n      generator.injectId(generator.STATEMENT_SUFFIX, block),\n      generator.INDENT,\n    );\n  }\n  if ((block as IfReturnBlock).hasReturnValue_) {\n    const value = generator.valueToCode(block, 'VALUE', Order.NONE) || 'nil';\n    code += generator.INDENT + 'return ' + value + '\\n';\n  } else {\n    code += generator.INDENT + 'return\\n';\n  }\n  code += 'end\\n';\n  return code;\n}\n", "/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Lua for text blocks.\n */\n\n// Former goog.module ID: Blockly.Lua.texts\n\nimport type {JoinMutatorBlock} from '../../blocks/text.js';\nimport type {Block} from '../../core/block.js';\nimport type {LuaGenerator} from './lua_generator.js';\nimport {Order} from './lua_generator.js';\n\nexport function text(block: Block, generator: LuaGenerator): [string, Order] {\n  // Text value.\n  const code = generator.quote_(block.getFieldValue('TEXT'));\n  return [code, Order.ATOMIC];\n}\n\nexport function text_join(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  const joinBlock = block as JoinMutatorBlock;\n  // Create a string made up of any number of elements of any type.\n  if (joinBlock.itemCount_ === 0) {\n    return [\"''\", Order.ATOMIC];\n  } else if (joinBlock.itemCount_ === 1) {\n    const element = generator.valueToCode(block, 'ADD0', Order.NONE) || \"''\";\n    const code = 'tostring(' + element + ')';\n    return [code, Order.HIGH];\n  } else if (joinBlock.itemCount_ === 2) {\n    const element0 =\n      generator.valueToCode(block, 'ADD0', Order.CONCATENATION) || \"''\";\n    const element1 =\n      generator.valueToCode(block, 'ADD1', Order.CONCATENATION) || \"''\";\n    const code = element0 + ' .. ' + element1;\n    return [code, Order.CONCATENATION];\n  } else {\n    const elements = [];\n    for (let i = 0; i < joinBlock.itemCount_; i++) {\n      elements[i] = generator.valueToCode(block, 'ADD' + i, Order.NONE) || \"''\";\n    }\n    const code = 'table.concat({' + elements.join(', ') + '})';\n    return [code, Order.HIGH];\n  }\n}\n\nexport function text_append(block: Block, generator: LuaGenerator): string {\n  // Append to a variable in place.\n  const varName = generator.getVariableName(block.getFieldValue('VAR'));\n  const value =\n    generator.valueToCode(block, 'TEXT', Order.CONCATENATION) || \"''\";\n  return varName + ' = ' + varName + ' .. ' + value + '\\n';\n}\n\nexport function text_length(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // String or array length.\n  const text = generator.valueToCode(block, 'VALUE', Order.UNARY) || \"''\";\n  return ['#' + text, Order.UNARY];\n}\n\nexport function text_isEmpty(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Is the string null or array empty?\n  const text = generator.valueToCode(block, 'VALUE', Order.UNARY) || \"''\";\n  return ['#' + text + ' == 0', Order.RELATIONAL];\n}\n\nexport function text_indexOf(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Search the text for a substring.\n  const substring = generator.valueToCode(block, 'FIND', Order.NONE) || \"''\";\n  const text = generator.valueToCode(block, 'VALUE', Order.NONE) || \"''\";\n  let functionName;\n  if (block.getFieldValue('END') === 'FIRST') {\n    functionName = generator.provideFunction_(\n      'firstIndexOf',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(str, substr)\n  local i = string.find(str, substr, 1, true)\n  if i == nil then\n    return 0\n  end\n  return i\nend\n`,\n    );\n  } else {\n    functionName = generator.provideFunction_(\n      'lastIndexOf',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(str, substr)\n  local i = string.find(string.reverse(str), string.reverse(substr), 1, true)\n  if i then\n    return #str + 2 - i - #substr\n  end\n  return 0\nend\n`,\n    );\n  }\n  const code = functionName + '(' + text + ', ' + substring + ')';\n  return [code, Order.HIGH];\n}\n\nexport function text_charAt(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Get letter at index.\n  // Note: Until January 2013 this block did not have the WHERE input.\n  const where = block.getFieldValue('WHERE') || 'FROM_START';\n  const text = generator.valueToCode(block, 'VALUE', Order.NONE) || \"''\";\n  let code;\n  if (where === 'RANDOM') {\n    const functionName = generator.provideFunction_(\n      'text_random_letter',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(str)\n  local index = math.random(string.len(str))\n  return string.sub(str, index, index)\nend\n`,\n    );\n    code = functionName + '(' + text + ')';\n  } else {\n    let start;\n    if (where === 'FIRST') {\n      start = '1';\n    } else if (where === 'LAST') {\n      start = '-1';\n    } else {\n      const atOrder = where === 'FROM_END' ? Order.UNARY : Order.NONE;\n      const at = generator.valueToCode(block, 'AT', atOrder) || '1';\n      if (where === 'FROM_START') {\n        start = at;\n      } else if (where === 'FROM_END') {\n        start = '-' + at;\n      } else {\n        throw Error('Unhandled option (text_charAt).');\n      }\n    }\n    if (start.match(/^-?\\w*$/)) {\n      code = 'string.sub(' + text + ', ' + start + ', ' + start + ')';\n    } else {\n      // use function to avoid reevaluation\n      const functionName = generator.provideFunction_(\n        'text_char_at',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(str, index)\n  return string.sub(str, index, index)\nend\n`,\n      );\n      code = functionName + '(' + text + ', ' + start + ')';\n    }\n  }\n  return [code, Order.HIGH];\n}\n\nexport function text_getSubstring(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Get substring.\n  const text = generator.valueToCode(block, 'STRING', Order.NONE) || \"''\";\n\n  // Get start index.\n  const where1 = block.getFieldValue('WHERE1');\n  const at1Order = where1 === 'FROM_END' ? Order.UNARY : Order.NONE;\n  const at1 = generator.valueToCode(block, 'AT1', at1Order) || '1';\n  let start;\n  if (where1 === 'FIRST') {\n    start = 1;\n  } else if (where1 === 'FROM_START') {\n    start = at1;\n  } else if (where1 === 'FROM_END') {\n    start = '-' + at1;\n  } else {\n    throw Error('Unhandled option (text_getSubstring)');\n  }\n\n  // Get end index.\n  const where2 = block.getFieldValue('WHERE2');\n  const at2Order = where2 === 'FROM_END' ? Order.UNARY : Order.NONE;\n  const at2 = generator.valueToCode(block, 'AT2', at2Order) || '1';\n  let end;\n  if (where2 === 'LAST') {\n    end = -1;\n  } else if (where2 === 'FROM_START') {\n    end = at2;\n  } else if (where2 === 'FROM_END') {\n    end = '-' + at2;\n  } else {\n    throw Error('Unhandled option (text_getSubstring)');\n  }\n  const code = 'string.sub(' + text + ', ' + start + ', ' + end + ')';\n  return [code, Order.HIGH];\n}\n\nexport function text_changeCase(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Change capitalization.\n  const operator = block.getFieldValue('CASE');\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  let functionName;\n  if (operator === 'UPPERCASE') {\n    functionName = 'string.upper';\n  } else if (operator === 'LOWERCASE') {\n    functionName = 'string.lower';\n  } else if (operator === 'TITLECASE') {\n    // There are shorter versions at\n    // http://lua-users.org/wiki/SciteTitleCase\n    // that do not preserve whitespace.\n    functionName = generator.provideFunction_(\n      'text_titlecase',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(str)\n  local buf = {}\n  local inWord = false\n  for i = 1, #str do\n    local c = string.sub(str, i, i)\n    if inWord then\n      table.insert(buf, string.lower(c))\n      if string.find(c, \"%s\") then\n        inWord = false\n      end\n    else\n      table.insert(buf, string.upper(c))\n      inWord = true\n    end\n  end\n  return table.concat(buf)\nend\n`,\n    );\n  }\n  const code = functionName + '(' + text + ')';\n  return [code, Order.HIGH];\n}\n\nexport function text_trim(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Trim spaces.\n  const OPERATORS = {LEFT: '^%s*(,-)', RIGHT: '(.-)%s*$', BOTH: '^%s*(.-)%s*$'};\n  type OperatorOption = keyof typeof OPERATORS;\n  const operator = OPERATORS[block.getFieldValue('MODE') as OperatorOption];\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const code = 'string.gsub(' + text + ', \"' + operator + '\", \"%1\")';\n  return [code, Order.HIGH];\n}\n\nexport function text_print(block: Block, generator: LuaGenerator): string {\n  // Print statement.\n  const msg = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  return 'print(' + msg + ')\\n';\n}\n\nexport function text_prompt_ext(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Prompt function.\n  let msg;\n  if (block.getField('TEXT')) {\n    // Internal message.\n    msg = generator.quote_(block.getFieldValue('TEXT'));\n  } else {\n    // External message.\n    msg = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  }\n\n  const functionName = generator.provideFunction_(\n    'text_prompt',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(msg)\n  io.write(msg)\n  io.flush()\n  return io.read()\nend\n`,\n  );\n  let code = functionName + '(' + msg + ')';\n\n  const toNumber = block.getFieldValue('TYPE') === 'NUMBER';\n  if (toNumber) {\n    code = 'tonumber(' + code + ', 10)';\n  }\n  return [code, Order.HIGH];\n}\n\nexport const text_prompt = text_prompt_ext;\n\nexport function text_count(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const sub = generator.valueToCode(block, 'SUB', Order.NONE) || \"''\";\n  const functionName = generator.provideFunction_(\n    'text_count',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(haystack, needle)\n  if #needle == 0 then\n    return #haystack + 1\n  end\n  local i = 1\n  local count = 0\n  while true do\n    i = string.find(haystack, needle, i, true)\n    if i == nil then\n      break\n    end\n    count = count + 1\n    i = i + #needle\n  end\n  return count\nend\n`,\n  );\n  const code = functionName + '(' + text + ', ' + sub + ')';\n  return [code, Order.HIGH];\n}\n\nexport function text_replace(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const from = generator.valueToCode(block, 'FROM', Order.NONE) || \"''\";\n  const to = generator.valueToCode(block, 'TO', Order.NONE) || \"''\";\n  const functionName = generator.provideFunction_(\n    'text_replace',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(haystack, needle, replacement)\n  local buf = {}\n  local i = 1\n  while i <= #haystack do\n    if string.sub(haystack, i, i + #needle - 1) == needle then\n      for j = 1, #replacement do\n        table.insert(buf, string.sub(replacement, j, j))\n      end\n      i = i + #needle\n    else\n      table.insert(buf, string.sub(haystack, i, i))\n      i = i + 1\n    end\n  end\n  return table.concat(buf)\nend\n`,\n  );\n  const code = functionName + '(' + text + ', ' + from + ', ' + to + ')';\n  return [code, Order.HIGH];\n}\n\nexport function text_reverse(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const code = 'string.reverse(' + text + ')';\n  return [code, Order.HIGH];\n}\n", "/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Lua for variable blocks.\n */\n\n// Former goog.module ID: Blockly.Lua.variables\n\nimport type {Block} from '../../core/block.js';\nimport type {LuaGenerator} from './lua_generator.js';\nimport {Order} from './lua_generator.js';\n\nexport function variables_get(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Variable getter.\n  const code = generator.getVariableName(block.getFieldValue('VAR'));\n  return [code, Order.ATOMIC];\n}\n\nexport function variables_set(block: Block, generator: LuaGenerator): string {\n  // Variable setter.\n  const argument0 = generator.valueToCode(block, 'VALUE', Order.NONE) || '0';\n  const varName = generator.getVariableName(block.getFieldValue('VAR'));\n  return varName + ' = ' + argument0 + '\\n';\n}\n", "/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Lua code generator class, including helper methods for\n * generating Lua for blocks.\n *\n * Based on Ellen Spertus's blocky-lua project.\n */\n\n// Former goog.module ID: Blockly.Lua\n\nimport type {Block} from '../../core/block.js';\nimport {CodeGenerator} from '../../core/generator.js';\nimport {inputTypes} from '../../core/inputs/input_types.js';\nimport {Names} from '../../core/names.js';\nimport * as stringUtils from '../../core/utils/string.js';\nimport type {Workspace} from '../../core/workspace.js';\n\n/**\n * Order of operation ENUMs.\n * http://www.lua.org/manual/5.3/manual.html#3.4.8\n */\n// prettier-ignore\nexport enum Order {\n  ATOMIC = 0,    // literals\n  // The next level was not explicit in documentation and inferred by Ellen.\n  HIGH = 1,            // Function calls, tables[]\n  EXPONENTIATION = 2,  // ^\n  UNARY = 3,           // not # - ~\n  MULTIPLICATIVE = 4,  // * / %\n  ADDITIVE = 5,        // + -\n  CONCATENATION = 6,   // ..\n  RELATIONAL = 7,      // < > <=  >= ~= ==\n  AND = 8,             // and\n  OR = 9,              // or\n  NONE = 99,\n}\n\n/**\n * Lua code generator class.\n *\n * Note: Lua is not supporting zero-indexing since the language itself is\n * one-indexed, so the generator does not repoct the oneBasedIndex configuration\n * option used for lists and text.\n */\nexport class LuaGenerator extends CodeGenerator {\n  constructor(name = 'Lua') {\n    super(name);\n    this.isInitialized = false;\n\n    // Copy Order values onto instance for backwards compatibility\n    // while ensuring they are not part of the publically-advertised\n    // API.\n    //\n    // TODO(#7085): deprecate these in due course.  (Could initially\n    // replace data properties with get accessors that call\n    // deprecate.warn().)\n    for (const key in Order) {\n      // Must assign Order[key] to a temporary to get the type guard to work;\n      // see https://github.com/microsoft/TypeScript/issues/10530.\n      const value = Order[key];\n      // Skip reverse-lookup entries in the enum.  Due to\n      // https://github.com/microsoft/TypeScript/issues/55713 this (as\n      // of TypeScript 5.5.2) actually narrows the type of value to\n      // never - but that still allows the following assignment to\n      // succeed.\n      if (typeof value === 'string') continue;\n      (this as unknown as Record<string, Order>)['ORDER_' + key] = value;\n    }\n\n    // List of illegal variable names.  This is not intended to be a\n    // security feature.  Blockly is 100% client-side, so bypassing\n    // this list is trivial.  This is intended to prevent users from\n    // accidentally clobbering a built-in object or function.\n    this.addReservedWords(\n      // Special character\n      '_,' +\n        // From theoriginalbit's script:\n        // https://github.com/espertus/blockly-lua/issues/6\n        '__inext,assert,bit,colors,colours,coroutine,disk,dofile,error,fs,' +\n        'fetfenv,getmetatable,gps,help,io,ipairs,keys,loadfile,loadstring,math,' +\n        'native,next,os,paintutils,pairs,parallel,pcall,peripheral,print,' +\n        'printError,rawequal,rawget,rawset,read,rednet,redstone,rs,select,' +\n        'setfenv,setmetatable,sleep,string,table,term,textutils,tonumber,' +\n        'tostring,turtle,type,unpack,vector,write,xpcall,_VERSION,__indext,' +\n        // Not included in the script, probably because it wasn't enabled:\n        'HTTP,' +\n        // Keywords (http://www.lua.org/pil/1.3.html).\n        'and,break,do,else,elseif,end,false,for,function,if,in,local,nil,not,' +\n        'or,repeat,return,then,true,until,while,' +\n        // Metamethods (http://www.lua.org/manual/5.2/manual.html).\n        'add,sub,mul,div,mod,pow,unm,concat,len,eq,lt,le,index,newindex,call,' +\n        // Basic functions (http://www.lua.org/manual/5.2/manual.html,\n        // section 6.1).\n        'assert,collectgarbage,dofile,error,_G,getmetatable,inpairs,load,' +\n        'loadfile,next,pairs,pcall,print,rawequal,rawget,rawlen,rawset,select,' +\n        'setmetatable,tonumber,tostring,type,_VERSION,xpcall,' +\n        // Modules (http://www.lua.org/manual/5.2/manual.html, section 6.3).\n        'require,package,string,table,math,bit32,io,file,os,debug',\n    );\n  }\n\n  /**\n   * Initialise the database of variable names.\n   *\n   * @param workspace Workspace to generate code from.\n   */\n  init(workspace: Workspace) {\n    // Call Blockly.CodeGenerator's init.\n    super.init(workspace);\n\n    if (!this.nameDB_) {\n      this.nameDB_ = new Names(this.RESERVED_WORDS_);\n    } else {\n      this.nameDB_.reset();\n    }\n    this.nameDB_.setVariableMap(workspace.getVariableMap());\n    this.nameDB_.populateVariables(workspace);\n    this.nameDB_.populateProcedures(workspace);\n\n    this.isInitialized = true;\n  }\n\n  /**\n   * Prepend the generated code with the variable definitions.\n   *\n   * @param code Generated code.\n   * @returns Completed code.\n   */\n  finish(code: string): string {\n    // Convert the definitions dictionary into a list.\n    const definitions = Object.values(this.definitions_);\n    // Call Blockly.CodeGenerator's finish.\n    code = super.finish(code);\n    this.isInitialized = false;\n\n    this.nameDB_!.reset();\n    return definitions.join('\\n\\n') + '\\n\\n\\n' + code;\n  }\n\n  /**\n   * Naked values are top-level blocks with outputs that aren't plugged into\n   * anything. In Lua, an expression is not a legal statement, so we must assign\n   * the value to the (conventionally ignored) _.\n   * http://lua-users.org/wiki/ExpressionsAsStatements\n   *\n   * @param line Line of generated code.\n   * @return Legal line of code.\n   */\n  scrubNakedValue(line: string): string {\n    return 'local _ = ' + line + '\\n';\n  }\n\n  /**\n   * Encode a string as a properly escaped Lua string, complete with\n   * quotes.\n   *\n   * @param string Text to encode.\n   * @returns Lua string.\n   */\n  quote_(string: string): string {\n    string = string\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\n/g, '\\\\\\n')\n      .replace(/'/g, \"\\\\'\");\n    return \"'\" + string + \"'\";\n  }\n\n  /**\n   * Encode a string as a properly escaped multiline Lua string, complete with\n   * quotes.\n   *\n   * @param string Text to encode.\n   * @returns Lua string.\n   */\n  multiline_quote_(string: string): string {\n    const lines = string.split(/\\n/g).map(this.quote_);\n    // Join with the following, plus a newline:\n    // .. '\\n' ..\n    return lines.join(\" .. '\\\\n' ..\\n\");\n  }\n\n  /**\n   * Common tasks for generating Lua from blocks.\n   * Handles comments for the specified block and any connected value blocks.\n   * Calls any statements following this block.\n   * @param block The current block.\n   * @param code The Lua code created for this block.\n   * @param thisOnly True to generate code for only this statement.\n   * @returns Lua code with comments and subsequent blocks added.\n   */\n  scrub_(block: Block, code: string, thisOnly = false): string {\n    let commentCode = '';\n    // Only collect comments for blocks that aren't inline.\n    if (!block.outputConnection || !block.outputConnection.targetConnection) {\n      // Collect comment for this block.\n      let comment = block.getCommentText();\n      if (comment) {\n        comment = stringUtils.wrap(comment, this.COMMENT_WRAP - 3);\n        commentCode += this.prefixLines(comment, '-- ') + '\\n';\n      }\n      // Collect comments for all value arguments.\n      // Don't collect comments for nested statements.\n      for (let i = 0; i < block.inputList.length; i++) {\n        if (block.inputList[i].type === inputTypes.VALUE) {\n          const childBlock = block.inputList[i].connection!.targetBlock();\n          if (childBlock) {\n            comment = this.allNestedComments(childBlock);\n            if (comment) {\n              commentCode += this.prefixLines(comment, '-- ');\n            }\n          }\n        }\n      }\n    }\n    const nextBlock =\n      block.nextConnection && block.nextConnection.targetBlock();\n    const nextCode = thisOnly ? '' : this.blockToCode(nextBlock);\n    return commentCode + code + nextCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Lua for dynamic variable blocks.\n */\n\n// Former goog.module ID: Blockly.Lua.variablesDynamic\n\n// Lua is dynamically typed.\nexport {\n  variables_get as variables_get_dynamic,\n  variables_set as variables_set_dynamic,\n} from './variables.js';\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Complete helper functions for generating Lua for\n *     blocks.  This is the entrypoint for lua_compressed.js.\n */\n\n// Former goog.module ID: Blockly.Lua.all\n\nimport * as lists from './lua/lists.js';\nimport * as logic from './lua/logic.js';\nimport * as loops from './lua/loops.js';\nimport {LuaGenerator} from './lua/lua_generator.js';\nimport * as math from './lua/math.js';\nimport * as procedures from './lua/procedures.js';\nimport * as text from './lua/text.js';\nimport * as variables from './lua/variables.js';\nimport * as variablesDynamic from './lua/variables_dynamic.js';\n\nexport * from './lua/lua_generator.js';\n\n/**\n * Lua code generator instance.\n */\nexport const luaGenerator = new LuaGenerator();\n\n// Install per-block-type generator functions:\nconst generators: typeof luaGenerator.forBlock = {\n  ...lists,\n  ...logic,\n  ...loops,\n  ...math,\n  ...procedures,\n  ...text,\n  ...variables,\n  ...variablesDynamic,\n};\nfor (const name in generators) {\n  luaGenerator.forBlock[name] = generators[name];\n}\n", "/**\n * @license\n * Copyright 2015 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating PHP for list blocks.\n */\n\n/**\n * Lists in PHP are known to break when non-variables are passed into blocks\n * that require a list. PHP, unlike other languages, passes arrays as reference\n * value instead of value so we are unable to support it to the extent we can\n * for the other languages.\n * For example, a ternary operator with two arrays will return the array by\n * value and that cannot be passed into any of the built-in array functions for\n * PHP (because only variables can be passed by reference).\n * ex:  end(true ? list1 : list2)\n */\n\n// Former goog.module ID: Blockly.generator.lists\n\nimport type {CreateWithBlock} from '../../blocks/lists.js';\nimport type {Block} from '../../core/block.js';\nimport {NameType} from '../../core/names.js';\nimport * as stringUtils from '../../core/utils/string.js';\nimport type {PhpGenerator} from './php_generator.js';\nimport {Order} from './php_generator.js';\n\nexport function lists_create_empty(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Create an empty list.\n  return ['array()', Order.FUNCTION_CALL];\n}\n\nexport function lists_create_with(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Create a list with any number of elements of any type.\n  const createWithBlock = block as CreateWithBlock;\n  const elements = new Array(createWithBlock.itemCount_);\n  for (let i = 0; i < createWithBlock.itemCount_; i++) {\n    elements[i] = generator.valueToCode(block, 'ADD' + i, Order.NONE) || 'null';\n  }\n  const code = 'array(' + elements.join(', ') + ')';\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function lists_repeat(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Create a list with one element repeated.\n  const functionName = generator.provideFunction_(\n    'lists_repeat',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}($value, $count) {\n  $array = array();\n  for ($index = 0; $index < $count; $index++) {\n    $array[] = $value;\n  }\n  return $array;\n}\n`,\n  );\n  const element = generator.valueToCode(block, 'ITEM', Order.NONE) || 'null';\n  const repeatCount = generator.valueToCode(block, 'NUM', Order.NONE) || '0';\n  const code = functionName + '(' + element + ', ' + repeatCount + ')';\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function lists_length(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // String or array length.\n  const functionName = generator.provideFunction_(\n    'length',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}($value) {\n  if (is_string($value)) {\n    return strlen($value);\n  } else {\n    return count($value);\n  }\n}\n`,\n  );\n  const list = generator.valueToCode(block, 'VALUE', Order.NONE) || \"''\";\n  return [functionName + '(' + list + ')', Order.FUNCTION_CALL];\n}\n\nexport function lists_isEmpty(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Is the string null or array empty?\n  const argument0 =\n    generator.valueToCode(block, 'VALUE', Order.FUNCTION_CALL) || 'array()';\n  return ['empty(' + argument0 + ')', Order.FUNCTION_CALL];\n}\n\nexport function lists_indexOf(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Find an item in the list.\n  const argument0 = generator.valueToCode(block, 'FIND', Order.NONE) || \"''\";\n  const argument1 = generator.valueToCode(block, 'VALUE', Order.MEMBER) || '[]';\n  let errorIndex = ' -1';\n  let indexAdjustment = '';\n  if (block.workspace.options.oneBasedIndex) {\n    errorIndex = ' 0';\n    indexAdjustment = ' + 1';\n  }\n  let functionName;\n  if (block.getFieldValue('END') === 'FIRST') {\n    // indexOf\n    functionName = generator.provideFunction_(\n      'indexOf',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}($haystack, $needle) {\n  for ($index = 0; $index < count($haystack); $index++) {\n    if ($haystack[$index] == $needle) return $index${indexAdjustment};\n  }\n  return ${errorIndex};\n}\n`,\n    );\n  } else {\n    // lastIndexOf\n    functionName = generator.provideFunction_(\n      'lastIndexOf',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}($haystack, $needle) {\n  $last = ${errorIndex};\n  for ($index = 0; $index < count($haystack); $index++) {\n    if ($haystack[$index] == $needle) $last = $index${indexAdjustment};\n  }\n  return $last;\n}\n`,\n    );\n  }\n\n  const code = functionName + '(' + argument1 + ', ' + argument0 + ')';\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function lists_getIndex(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] | string {\n  // Get element at index.\n  const mode = block.getFieldValue('MODE') || 'GET';\n  const where = block.getFieldValue('WHERE') || 'FROM_START';\n  switch (where) {\n    case 'FIRST':\n      if (mode === 'GET') {\n        const list =\n          generator.valueToCode(block, 'VALUE', Order.MEMBER) || 'array()';\n        const code = list + '[0]';\n        return [code, Order.MEMBER];\n      } else if (mode === 'GET_REMOVE') {\n        const list =\n          generator.valueToCode(block, 'VALUE', Order.NONE) || 'array()';\n        const code = 'array_shift(' + list + ')';\n        return [code, Order.FUNCTION_CALL];\n      } else if (mode === 'REMOVE') {\n        const list =\n          generator.valueToCode(block, 'VALUE', Order.NONE) || 'array()';\n        return 'array_shift(' + list + ');\\n';\n      }\n      break;\n    case 'LAST':\n      if (mode === 'GET') {\n        const list =\n          generator.valueToCode(block, 'VALUE', Order.NONE) || 'array()';\n        const code = 'end(' + list + ')';\n        return [code, Order.FUNCTION_CALL];\n      } else if (mode === 'GET_REMOVE') {\n        const list =\n          generator.valueToCode(block, 'VALUE', Order.NONE) || 'array()';\n        const code = 'array_pop(' + list + ')';\n        return [code, Order.FUNCTION_CALL];\n      } else if (mode === 'REMOVE') {\n        const list =\n          generator.valueToCode(block, 'VALUE', Order.NONE) || 'array()';\n        return 'array_pop(' + list + ');\\n';\n      }\n      break;\n    case 'FROM_START': {\n      const at = generator.getAdjusted(block, 'AT');\n      if (mode === 'GET') {\n        const list =\n          generator.valueToCode(block, 'VALUE', Order.MEMBER) || 'array()';\n        const code = list + '[' + at + ']';\n        return [code, Order.MEMBER];\n      } else if (mode === 'GET_REMOVE') {\n        const list =\n          generator.valueToCode(block, 'VALUE', Order.NONE) || 'array()';\n        const code = 'array_splice(' + list + ', ' + at + ', 1)[0]';\n        return [code, Order.FUNCTION_CALL];\n      } else if (mode === 'REMOVE') {\n        const list =\n          generator.valueToCode(block, 'VALUE', Order.NONE) || 'array()';\n        return 'array_splice(' + list + ', ' + at + ', 1);\\n';\n      }\n      break;\n    }\n    case 'FROM_END':\n      if (mode === 'GET') {\n        const list =\n          generator.valueToCode(block, 'VALUE', Order.NONE) || 'array()';\n        const at = generator.getAdjusted(block, 'AT', 1, true);\n        const code = 'array_slice(' + list + ', ' + at + ', 1)[0]';\n        return [code, Order.FUNCTION_CALL];\n      } else if (mode === 'GET_REMOVE' || mode === 'REMOVE') {\n        const list =\n          generator.valueToCode(block, 'VALUE', Order.NONE) || 'array()';\n        const at = generator.getAdjusted(\n          block,\n          'AT',\n          1,\n          false,\n          Order.SUBTRACTION,\n        );\n        const code =\n          'array_splice(' + list + ', count(' + list + ') - ' + at + ', 1)[0]';\n        if (mode === 'GET_REMOVE') {\n          return [code, Order.FUNCTION_CALL];\n        } else if (mode === 'REMOVE') {\n          return code + ';\\n';\n        }\n      }\n      break;\n    case 'RANDOM': {\n      const list =\n        generator.valueToCode(block, 'VALUE', Order.NONE) || 'array()';\n      if (mode === 'GET') {\n        const functionName = generator.provideFunction_(\n          'lists_get_random_item',\n          `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}($list) {\n  return $list[rand(0,count($list)-1)];\n}\n`,\n        );\n        const code = functionName + '(' + list + ')';\n        return [code, Order.FUNCTION_CALL];\n      } else if (mode === 'GET_REMOVE') {\n        const functionName = generator.provideFunction_(\n          'lists_get_remove_random_item',\n          `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(&$list) {\n  $x = rand(0,count($list)-1);\n  unset($list[$x]);\n  return array_values($list);\n}\n`,\n        );\n        const code = functionName + '(' + list + ')';\n        return [code, Order.FUNCTION_CALL];\n      } else if (mode === 'REMOVE') {\n        const functionName = generator.provideFunction_(\n          'lists_remove_random_item',\n          `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(&$list) {\n  unset($list[rand(0,count($list)-1)]);\n}\n`,\n        );\n        return functionName + '(' + list + ');\\n';\n      }\n      break;\n    }\n  }\n  throw Error('Unhandled combination (lists_getIndex).');\n}\n\nexport function lists_setIndex(block: Block, generator: PhpGenerator) {\n  // Set element at index.\n  // Note: Until February 2013 this block did not have MODE or WHERE inputs.\n  const mode = block.getFieldValue('MODE') || 'GET';\n  const where = block.getFieldValue('WHERE') || 'FROM_START';\n  const value = generator.valueToCode(block, 'TO', Order.ASSIGNMENT) || 'null';\n  // Cache non-trivial values to variables to prevent repeated look-ups.\n  // Closure, which accesses and modifies 'list'.\n  let cachedList: string;\n  function cacheList() {\n    if (cachedList.match(/^\\$\\w+$/)) {\n      return '';\n    }\n    const listVar = generator.nameDB_!.getDistinctName(\n      'tmp_list',\n      NameType.VARIABLE,\n    );\n    const code = listVar + ' = &' + cachedList + ';\\n';\n    cachedList = listVar;\n    return code;\n  }\n  switch (where) {\n    case 'FIRST':\n      if (mode === 'SET') {\n        const list =\n          generator.valueToCode(block, 'LIST', Order.MEMBER) || 'array()';\n        return list + '[0] = ' + value + ';\\n';\n      } else if (mode === 'INSERT') {\n        const list =\n          generator.valueToCode(block, 'LIST', Order.NONE) || 'array()';\n        return 'array_unshift(' + list + ', ' + value + ');\\n';\n      }\n      break;\n    case 'LAST': {\n      const list =\n        generator.valueToCode(block, 'LIST', Order.NONE) || 'array()';\n      if (mode === 'SET') {\n        const functionName = generator.provideFunction_(\n          'lists_set_last_item',\n          `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(&$list, $value) {\n  $list[count($list) - 1] = $value;\n}\n`,\n        );\n        return functionName + '(' + list + ', ' + value + ');\\n';\n      } else if (mode === 'INSERT') {\n        return 'array_push(' + list + ', ' + value + ');\\n';\n      }\n      break;\n    }\n    case 'FROM_START': {\n      const at = generator.getAdjusted(block, 'AT');\n      if (mode === 'SET') {\n        const list =\n          generator.valueToCode(block, 'LIST', Order.MEMBER) || 'array()';\n        return list + '[' + at + '] = ' + value + ';\\n';\n      } else if (mode === 'INSERT') {\n        const list =\n          generator.valueToCode(block, 'LIST', Order.NONE) || 'array()';\n        return 'array_splice(' + list + ', ' + at + ', 0, ' + value + ');\\n';\n      }\n      break;\n    }\n    case 'FROM_END': {\n      const list =\n        generator.valueToCode(block, 'LIST', Order.NONE) || 'array()';\n      const at = generator.getAdjusted(block, 'AT', 1);\n      if (mode === 'SET') {\n        const functionName = generator.provideFunction_(\n          'lists_set_from_end',\n          `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(&$list, $at, $value) {\n  $list[count($list) - $at] = $value;\n}\n`,\n        );\n        return functionName + '(' + list + ', ' + at + ', ' + value + ');\\n';\n      } else if (mode === 'INSERT') {\n        const functionName = generator.provideFunction_(\n          'lists_insert_from_end',\n          `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(&$list, $at, $value) {\n  return array_splice($list, count($list) - $at, 0, $value);\n}\n`,\n        );\n        return functionName + '(' + list + ', ' + at + ', ' + value + ');\\n';\n      }\n      break;\n    }\n    case 'RANDOM':\n      cachedList =\n        generator.valueToCode(block, 'LIST', Order.REFERENCE) || 'array()';\n      let code = cacheList();\n      const list = cachedList;\n      const xVar = generator.nameDB_!.getDistinctName(\n        'tmp_x',\n        NameType.VARIABLE,\n      );\n      code += xVar + ' = rand(0, count(' + list + ')-1);\\n';\n      if (mode === 'SET') {\n        code += list + '[' + xVar + '] = ' + value + ';\\n';\n        return code;\n      } else if (mode === 'INSERT') {\n        code += 'array_splice(' + list + ', ' + xVar + ', 0, ' + value + ');\\n';\n        return code;\n      }\n      break;\n  }\n  throw Error('Unhandled combination (lists_setIndex).');\n}\n\nexport function lists_getSublist(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Get sublist.\n  const list = generator.valueToCode(block, 'LIST', Order.NONE) || 'array()';\n  const where1 = block.getFieldValue('WHERE1');\n  const where2 = block.getFieldValue('WHERE2');\n  let code;\n  if (where1 === 'FIRST' && where2 === 'LAST') {\n    code = list;\n  } else if (\n    list.match(/^\\$\\w+$/) ||\n    (where1 !== 'FROM_END' && where2 === 'FROM_START')\n  ) {\n    // If the list is a simple value or doesn't require a call for length, don't\n    // generate a helper function.\n    let at1;\n    switch (where1) {\n      case 'FROM_START':\n        at1 = generator.getAdjusted(block, 'AT1');\n        break;\n      case 'FROM_END':\n        at1 = generator.getAdjusted(block, 'AT1', 1, false, Order.SUBTRACTION);\n        at1 = 'count(' + list + ') - ' + at1;\n        break;\n      case 'FIRST':\n        at1 = '0';\n        break;\n      default:\n        throw Error('Unhandled option (lists_getSublist).');\n    }\n    let at2;\n    let length;\n    switch (where2) {\n      case 'FROM_START':\n        at2 = generator.getAdjusted(block, 'AT2', 0, false, Order.SUBTRACTION);\n        length = at2 + ' - ';\n        if (\n          stringUtils.isNumber(String(at1)) ||\n          String(at1).match(/^\\(.+\\)$/)\n        ) {\n          length += at1;\n        } else {\n          length += '(' + at1 + ')';\n        }\n        length += ' + 1';\n        break;\n      case 'FROM_END':\n        at2 = generator.getAdjusted(block, 'AT2', 0, false, Order.SUBTRACTION);\n        length = 'count(' + list + ') - ' + at2 + ' - ';\n        if (\n          stringUtils.isNumber(String(at1)) ||\n          String(at1).match(/^\\(.+\\)$/)\n        ) {\n          length += at1;\n        } else {\n          length += '(' + at1 + ')';\n        }\n        break;\n      case 'LAST':\n        length = 'count(' + list + ') - ';\n        if (\n          stringUtils.isNumber(String(at1)) ||\n          String(at1).match(/^\\(.+\\)$/)\n        ) {\n          length += at1;\n        } else {\n          length += '(' + at1 + ')';\n        }\n        break;\n      default:\n        throw Error('Unhandled option (lists_getSublist).');\n    }\n    code = 'array_slice(' + list + ', ' + at1 + ', ' + length + ')';\n  } else {\n    const at1 = generator.getAdjusted(block, 'AT1');\n    const at2 = generator.getAdjusted(block, 'AT2');\n    const functionName = generator.provideFunction_(\n      'lists_get_sublist',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}($list, $where1, $at1, $where2, $at2) {\n  if ($where1 == 'FROM_END') {\n    $at1 = count($list) - 1 - $at1;\n  } else if ($where1 == 'FIRST') {\n    $at1 = 0;\n  } else if ($where1 != 'FROM_START') {\n    throw new Exception('Unhandled option (lists_get_sublist).');\n  }\n  $length = 0;\n  if ($where2 == 'FROM_START') {\n    $length = $at2 - $at1 + 1;\n  } else if ($where2 == 'FROM_END') {\n    $length = count($list) - $at1 - $at2;\n  } else if ($where2 == 'LAST') {\n    $length = count($list) - $at1;\n  } else {\n    throw new Exception('Unhandled option (lists_get_sublist).');\n  }\n  return array_slice($list, $at1, $length);\n}\n`,\n    );\n    code =\n      functionName +\n      '(' +\n      list +\n      \", '\" +\n      where1 +\n      \"', \" +\n      at1 +\n      \", '\" +\n      where2 +\n      \"', \" +\n      at2 +\n      ')';\n  }\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function lists_sort(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Block for sorting a list.\n  const listCode =\n    generator.valueToCode(block, 'LIST', Order.NONE) || 'array()';\n  const direction = block.getFieldValue('DIRECTION') === '1' ? 1 : -1;\n  const type = block.getFieldValue('TYPE');\n  const functionName = generator.provideFunction_(\n    'lists_sort',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}($list, $type, $direction) {\n  $sortCmpFuncs = array(\n    'NUMERIC' => 'strnatcasecmp',\n    'TEXT' => 'strcmp',\n    'IGNORE_CASE' => 'strcasecmp'\n  );\n  $sortCmp = $sortCmpFuncs[$type];\n  $list2 = $list;\n  usort($list2, $sortCmp);\n  if ($direction == -1) {\n    $list2 = array_reverse($list2);\n  }\n  return $list2;\n}\n`,\n  );\n  const sortCode =\n    functionName + '(' + listCode + ', \"' + type + '\", ' + direction + ')';\n  return [sortCode, Order.FUNCTION_CALL];\n}\n\nexport function lists_split(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Block for splitting text into a list, or joining a list into text.\n  let value_input = generator.valueToCode(block, 'INPUT', Order.NONE);\n  const value_delim = generator.valueToCode(block, 'DELIM', Order.NONE) || \"''\";\n  const mode = block.getFieldValue('MODE');\n  let functionName;\n  if (mode === 'SPLIT') {\n    if (!value_input) {\n      value_input = \"''\";\n    }\n    functionName = 'explode';\n  } else if (mode === 'JOIN') {\n    if (!value_input) {\n      value_input = 'array()';\n    }\n    functionName = 'implode';\n  } else {\n    throw Error('Unknown mode: ' + mode);\n  }\n  const code = functionName + '(' + value_delim + ', ' + value_input + ')';\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function lists_reverse(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Block for reversing a list.\n  const list = generator.valueToCode(block, 'LIST', Order.NONE) || '[]';\n  const code = 'array_reverse(' + list + ')';\n  return [code, Order.FUNCTION_CALL];\n}\n", "/**\n * @license\n * Copyright 2015 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating PHP for logic blocks.\n */\n\n// Former goog.module ID: Blockly.PHP.logic\n\nimport type {Block} from '../../core/block.js';\nimport type {PhpGenerator} from './php_generator.js';\nimport {Order} from './php_generator.js';\n\nexport function controls_if(block: Block, generator: PhpGenerator) {\n  // If/elseif/else condition.\n  let n = 0;\n  let code = '',\n    branchCode,\n    conditionCode;\n  if (generator.STATEMENT_PREFIX) {\n    // Automatic prefix insertion is switched off for this block.  Add manually.\n    code += generator.injectId(generator.STATEMENT_PREFIX, block);\n  }\n  do {\n    conditionCode =\n      generator.valueToCode(block, 'IF' + n, Order.NONE) || 'false';\n    branchCode = generator.statementToCode(block, 'DO' + n);\n    if (generator.STATEMENT_SUFFIX) {\n      branchCode =\n        generator.prefixLines(\n          generator.injectId(generator.STATEMENT_SUFFIX, block),\n          generator.INDENT,\n        ) + branchCode;\n    }\n    code +=\n      (n > 0 ? ' else ' : '') +\n      'if (' +\n      conditionCode +\n      ') {\\n' +\n      branchCode +\n      '}';\n    n++;\n  } while (block.getInput('IF' + n));\n\n  if (block.getInput('ELSE') || generator.STATEMENT_SUFFIX) {\n    branchCode = block.getInput('ELSE')\n      ? generator.statementToCode(block, 'ELSE')\n      : '';\n    if (generator.STATEMENT_SUFFIX) {\n      branchCode =\n        generator.prefixLines(\n          generator.injectId(generator.STATEMENT_SUFFIX, block),\n          generator.INDENT,\n        ) + branchCode;\n    }\n    code += ' else {\\n' + branchCode + '}';\n  }\n  return code + '\\n';\n}\n\nexport const controls_ifelse = controls_if;\n\nexport function logic_compare(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Comparison operator.\n  const OPERATORS = {\n    'EQ': '==',\n    'NEQ': '!=',\n    'LT': '<',\n    'LTE': '<=',\n    'GT': '>',\n    'GTE': '>=',\n  };\n  type OperatorOption = keyof typeof OPERATORS;\n  const operator = OPERATORS[block.getFieldValue('OP') as OperatorOption];\n  const order =\n    operator === '==' || operator === '!=' ? Order.EQUALITY : Order.RELATIONAL;\n  const argument0 = generator.valueToCode(block, 'A', order) || '0';\n  const argument1 = generator.valueToCode(block, 'B', order) || '0';\n  const code = argument0 + ' ' + operator + ' ' + argument1;\n  return [code, order];\n}\n\nexport function logic_operation(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Operations 'and', 'or'.\n  const operator = block.getFieldValue('OP') === 'AND' ? '&&' : '||';\n  const order = operator === '&&' ? Order.LOGICAL_AND : Order.LOGICAL_OR;\n  let argument0 = generator.valueToCode(block, 'A', order);\n  let argument1 = generator.valueToCode(block, 'B', order);\n  if (!argument0 && !argument1) {\n    // If there are no arguments, then the return value is false.\n    argument0 = 'false';\n    argument1 = 'false';\n  } else {\n    // Single missing arguments have no effect on the return value.\n    const defaultArgument = operator === '&&' ? 'true' : 'false';\n    if (!argument0) {\n      argument0 = defaultArgument;\n    }\n    if (!argument1) {\n      argument1 = defaultArgument;\n    }\n  }\n  const code = argument0 + ' ' + operator + ' ' + argument1;\n  return [code, order];\n}\n\nexport function logic_negate(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Negation.\n  const order = Order.LOGICAL_NOT;\n  const argument0 = generator.valueToCode(block, 'BOOL', order) || 'true';\n  const code = '!' + argument0;\n  return [code, order];\n}\n\nexport function logic_boolean(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Boolean values true and false.\n  const code = block.getFieldValue('BOOL') === 'TRUE' ? 'true' : 'false';\n  return [code, Order.ATOMIC];\n}\n\nexport function logic_null(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Null data type.\n  return ['null', Order.ATOMIC];\n}\n\nexport function logic_ternary(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Ternary operator.\n  const value_if =\n    generator.valueToCode(block, 'IF', Order.CONDITIONAL) || 'false';\n  const value_then =\n    generator.valueToCode(block, 'THEN', Order.CONDITIONAL) || 'null';\n  const value_else =\n    generator.valueToCode(block, 'ELSE', Order.CONDITIONAL) || 'null';\n  const code = value_if + ' ? ' + value_then + ' : ' + value_else;\n  return [code, Order.CONDITIONAL];\n}\n", "/**\n * @license\n * Copyright 2015 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating PHP for loop blocks.\n */\n\n// Former goog.module ID: Blockly.PHP.loops\n\nimport type {ControlFlowInLoopBlock} from '../../blocks/loops.js';\nimport type {Block} from '../../core/block.js';\nimport {NameType} from '../../core/names.js';\nimport * as stringUtils from '../../core/utils/string.js';\nimport type {PhpGenerator} from './php_generator.js';\nimport {Order} from './php_generator.js';\n\nexport function controls_repeat_ext(block: Block, generator: PhpGenerator) {\n  // Repeat n times.\n  let repeats;\n  if (block.getField('TIMES')) {\n    // Internal number.\n    repeats = String(Number(block.getFieldValue('TIMES')));\n  } else {\n    // External number.\n    repeats = generator.valueToCode(block, 'TIMES', Order.ASSIGNMENT) || '0';\n  }\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  let code = '';\n  const loopVar = generator.nameDB_!.getDistinctName(\n    'count',\n    NameType.VARIABLE,\n  );\n  let endVar = repeats;\n  if (!repeats.match(/^\\w+$/) && !stringUtils.isNumber(repeats)) {\n    endVar = generator.nameDB_!.getDistinctName(\n      'repeat_end',\n      NameType.VARIABLE,\n    );\n    code += endVar + ' = ' + repeats + ';\\n';\n  }\n  code +=\n    'for (' +\n    loopVar +\n    ' = 0; ' +\n    loopVar +\n    ' < ' +\n    endVar +\n    '; ' +\n    loopVar +\n    '++) {\\n' +\n    branch +\n    '}\\n';\n  return code;\n}\n\nexport const controls_repeat = controls_repeat_ext;\n\nexport function controls_whileUntil(block: Block, generator: PhpGenerator) {\n  // Do while/until loop.\n  const until = block.getFieldValue('MODE') === 'UNTIL';\n  let argument0 =\n    generator.valueToCode(\n      block,\n      'BOOL',\n      until ? Order.LOGICAL_NOT : Order.NONE,\n    ) || 'false';\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  if (until) {\n    argument0 = '!' + argument0;\n  }\n  return 'while (' + argument0 + ') {\\n' + branch + '}\\n';\n}\n\nexport function controls_for(block: Block, generator: PhpGenerator) {\n  // For loop.\n  const variable0 = generator.getVariableName(block.getFieldValue('VAR'));\n  const argument0 =\n    generator.valueToCode(block, 'FROM', Order.ASSIGNMENT) || '0';\n  const argument1 = generator.valueToCode(block, 'TO', Order.ASSIGNMENT) || '0';\n  const increment = generator.valueToCode(block, 'BY', Order.ASSIGNMENT) || '1';\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  let code;\n  if (\n    stringUtils.isNumber(argument0) &&\n    stringUtils.isNumber(argument1) &&\n    stringUtils.isNumber(increment)\n  ) {\n    // All arguments are simple numbers.\n    const up = Number(argument0) <= Number(argument1);\n    code =\n      'for (' +\n      variable0 +\n      ' = ' +\n      argument0 +\n      '; ' +\n      variable0 +\n      (up ? ' <= ' : ' >= ') +\n      argument1 +\n      '; ' +\n      variable0;\n    const step = Math.abs(Number(increment));\n    if (step === 1) {\n      code += up ? '++' : '--';\n    } else {\n      code += (up ? ' += ' : ' -= ') + step;\n    }\n    code += ') {\\n' + branch + '}\\n';\n  } else {\n    code = '';\n    // Cache non-trivial values to variables to prevent repeated look-ups.\n    let startVar = argument0;\n    if (!argument0.match(/^\\w+$/) && !stringUtils.isNumber(argument0)) {\n      startVar = generator.nameDB_!.getDistinctName(\n        variable0 + '_start',\n        NameType.VARIABLE,\n      );\n      code += startVar + ' = ' + argument0 + ';\\n';\n    }\n    let endVar = argument1;\n    if (!argument1.match(/^\\w+$/) && !stringUtils.isNumber(argument1)) {\n      endVar = generator.nameDB_!.getDistinctName(\n        variable0 + '_end',\n        NameType.VARIABLE,\n      );\n      code += endVar + ' = ' + argument1 + ';\\n';\n    }\n    // Determine loop direction at start, in case one of the bounds\n    // changes during loop execution.\n    const incVar = generator.nameDB_!.getDistinctName(\n      variable0 + '_inc',\n      NameType.VARIABLE,\n    );\n    code += incVar + ' = ';\n    if (stringUtils.isNumber(increment)) {\n      code += Math.abs(Number(increment)) + ';\\n';\n    } else {\n      code += 'abs(' + increment + ');\\n';\n    }\n    code += 'if (' + startVar + ' > ' + endVar + ') {\\n';\n    code += generator.INDENT + incVar + ' = -' + incVar + ';\\n';\n    code += '}\\n';\n    code +=\n      'for (' +\n      variable0 +\n      ' = ' +\n      startVar +\n      '; ' +\n      incVar +\n      ' >= 0 ? ' +\n      variable0 +\n      ' <= ' +\n      endVar +\n      ' : ' +\n      variable0 +\n      ' >= ' +\n      endVar +\n      '; ' +\n      variable0 +\n      ' += ' +\n      incVar +\n      ') {\\n' +\n      branch +\n      '}\\n';\n  }\n  return code;\n}\n\nexport function controls_forEach(block: Block, generator: PhpGenerator) {\n  // For each loop.\n  const variable0 = generator.getVariableName(block.getFieldValue('VAR'));\n  const argument0 =\n    generator.valueToCode(block, 'LIST', Order.ASSIGNMENT) || '[]';\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  let code = '';\n  code +=\n    'foreach (' + argument0 + ' as ' + variable0 + ') {\\n' + branch + '}\\n';\n  return code;\n}\n\nexport function controls_flow_statements(\n  block: Block,\n  generator: PhpGenerator,\n) {\n  // Flow statements: continue, break.\n  let xfix = '';\n  if (generator.STATEMENT_PREFIX) {\n    // Automatic prefix insertion is switched off for this block.  Add manually.\n    xfix += generator.injectId(generator.STATEMENT_PREFIX, block);\n  }\n  if (generator.STATEMENT_SUFFIX) {\n    // Inject any statement suffix here since the regular one at the end\n    // will not get executed if the break/continue is triggered.\n    xfix += generator.injectId(generator.STATEMENT_SUFFIX, block);\n  }\n  if (generator.STATEMENT_PREFIX) {\n    const loop = (block as ControlFlowInLoopBlock).getSurroundLoop();\n    if (loop && !loop.suppressPrefixSuffix) {\n      // Inject loop's statement prefix here since the regular one at the end\n      // of the loop will not get executed if 'continue' is triggered.\n      // In the case of 'break', a prefix is needed due to the loop's suffix.\n      xfix += generator.injectId(generator.STATEMENT_PREFIX, loop);\n    }\n  }\n  switch (block.getFieldValue('FLOW')) {\n    case 'BREAK':\n      return xfix + 'break;\\n';\n    case 'CONTINUE':\n      return xfix + 'continue;\\n';\n  }\n  throw Error('Unknown flow statement.');\n}\n", "/**\n * @license\n * Copyright 2015 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating PHP for math blocks.\n */\n\n// Former goog.module ID: Blockly.PHP.math\n\nimport type {Block} from '../../core/block.js';\nimport type {PhpGenerator} from './php_generator.js';\nimport {Order} from './php_generator.js';\n\nexport function math_number(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Numeric value.\n  let number = Number(block.getFieldValue('NUM'));\n  if (number === Infinity) {\n    return ['INF', Order.ATOMIC];\n  } else if (number === -Infinity) {\n    return ['-INF', Order.UNARY_NEGATION];\n  }\n  return [String(number), number >= 0 ? Order.ATOMIC : Order.UNARY_NEGATION];\n}\n\nexport function math_arithmetic(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Basic arithmetic operators, and power.\n  const OPERATORS: Record<string, [string, Order]> = {\n    'ADD': [' + ', Order.ADDITION],\n    'MINUS': [' - ', Order.SUBTRACTION],\n    'MULTIPLY': [' * ', Order.MULTIPLICATION],\n    'DIVIDE': [' / ', Order.DIVISION],\n    'POWER': [' ** ', Order.POWER],\n  };\n  type OperatorOption = keyof typeof OPERATORS;\n  const tuple = OPERATORS[block.getFieldValue('OP') as OperatorOption];\n  const operator = tuple[0];\n  const order = tuple[1];\n  const argument0 = generator.valueToCode(block, 'A', order) || '0';\n  const argument1 = generator.valueToCode(block, 'B', order) || '0';\n  const code = argument0 + operator + argument1;\n  return [code, order];\n}\n\nexport function math_single(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Math operators with single operand.\n  const operator = block.getFieldValue('OP');\n  let code;\n  let arg;\n  if (operator === 'NEG') {\n    // Negation is a special case given its different operator precedence.\n    arg = generator.valueToCode(block, 'NUM', Order.UNARY_NEGATION) || '0';\n    if (arg[0] === '-') {\n      // --3 is not legal in JS.\n      arg = ' ' + arg;\n    }\n    code = '-' + arg;\n    return [code, Order.UNARY_NEGATION];\n  }\n  if (operator === 'SIN' || operator === 'COS' || operator === 'TAN') {\n    arg = generator.valueToCode(block, 'NUM', Order.DIVISION) || '0';\n  } else {\n    arg = generator.valueToCode(block, 'NUM', Order.NONE) || '0';\n  }\n  // First, handle cases which generate values that don't need parentheses\n  // wrapping the code.\n  switch (operator) {\n    case 'ABS':\n      code = 'abs(' + arg + ')';\n      break;\n    case 'ROOT':\n      code = 'sqrt(' + arg + ')';\n      break;\n    case 'LN':\n      code = 'log(' + arg + ')';\n      break;\n    case 'EXP':\n      code = 'exp(' + arg + ')';\n      break;\n    case 'POW10':\n      code = 'pow(10,' + arg + ')';\n      break;\n    case 'ROUND':\n      code = 'round(' + arg + ')';\n      break;\n    case 'ROUNDUP':\n      code = 'ceil(' + arg + ')';\n      break;\n    case 'ROUNDDOWN':\n      code = 'floor(' + arg + ')';\n      break;\n    case 'SIN':\n      code = 'sin(' + arg + ' / 180 * pi())';\n      break;\n    case 'COS':\n      code = 'cos(' + arg + ' / 180 * pi())';\n      break;\n    case 'TAN':\n      code = 'tan(' + arg + ' / 180 * pi())';\n      break;\n  }\n  if (code) {\n    return [code, Order.FUNCTION_CALL];\n  }\n  // Second, handle cases which generate values that may need parentheses\n  // wrapping the code.\n  switch (operator) {\n    case 'LOG10':\n      code = 'log(' + arg + ') / log(10)';\n      break;\n    case 'ASIN':\n      code = 'asin(' + arg + ') / pi() * 180';\n      break;\n    case 'ACOS':\n      code = 'acos(' + arg + ') / pi() * 180';\n      break;\n    case 'ATAN':\n      code = 'atan(' + arg + ') / pi() * 180';\n      break;\n    default:\n      throw Error('Unknown math operator: ' + operator);\n  }\n  return [code, Order.DIVISION];\n}\n\nexport function math_constant(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Constants: PI, E, the Golden Ratio, sqrt(2), 1/sqrt(2), INFINITY.\n  const CONSTANTS: Record<string, [string, Order]> = {\n    'PI': ['M_PI', Order.ATOMIC],\n    'E': ['M_E', Order.ATOMIC],\n    'GOLDEN_RATIO': ['(1 + sqrt(5)) / 2', Order.DIVISION],\n    'SQRT2': ['M_SQRT2', Order.ATOMIC],\n    'SQRT1_2': ['M_SQRT1_2', Order.ATOMIC],\n    'INFINITY': ['INF', Order.ATOMIC],\n  };\n  type ConstantOption = keyof typeof CONSTANTS;\n  return CONSTANTS[block.getFieldValue('CONSTANT') as ConstantOption];\n}\n\nexport function math_number_property(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Check if a number is even, odd, prime, whole, positive, or negative\n  // or if it is divisible by certain number. Returns true or false.\n  const PROPERTIES: Record<\n    string,\n    [string, string, Order, Order] | [null, null, Order, Order]\n  > = {\n    'EVEN': ['', ' % 2 == 0', Order.MODULUS, Order.EQUALITY],\n    'ODD': ['', ' % 2 == 1', Order.MODULUS, Order.EQUALITY],\n    'WHOLE': ['is_int(', ')', Order.NONE, Order.FUNCTION_CALL],\n    'POSITIVE': ['', ' > 0', Order.RELATIONAL, Order.RELATIONAL],\n    'NEGATIVE': ['', ' < 0', Order.RELATIONAL, Order.RELATIONAL],\n    'DIVISIBLE_BY': [null, null, Order.MODULUS, Order.EQUALITY],\n    'PRIME': [null, null, Order.NONE, Order.FUNCTION_CALL],\n  };\n  type PropertyOption = keyof typeof PROPERTIES;\n  const dropdownProperty = block.getFieldValue('PROPERTY') as PropertyOption;\n  const [prefix, suffix, inputOrder, outputOrder] =\n    PROPERTIES[dropdownProperty];\n  const numberToCheck =\n    generator.valueToCode(block, 'NUMBER_TO_CHECK', inputOrder) || '0';\n  let code;\n  if (dropdownProperty === 'PRIME') {\n    // Prime is a special case as it is not a one-liner test.\n    const functionName = generator.provideFunction_(\n      'math_isPrime',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}($n) {\n  // https://en.wikipedia.org/wiki/Primality_test#Naive_methods\n  if ($n == 2 || $n == 3) {\n    return true;\n  }\n  // False if n is NaN, negative, is 1, or not whole.\n  // And false if n is divisible by 2 or 3.\n  if (!is_numeric($n) || $n <= 1 || $n % 1 != 0 || $n % 2 == 0 || $n % 3 == 0) {\n    return false;\n  }\n  // Check all the numbers of form 6k +/- 1, up to sqrt(n).\n  for ($x = 6; $x <= sqrt($n) + 1; $x += 6) {\n    if ($n % ($x - 1) == 0 || $n % ($x + 1) == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n`,\n    );\n    code = functionName + '(' + numberToCheck + ')';\n  } else if (dropdownProperty === 'DIVISIBLE_BY') {\n    const divisor =\n      generator.valueToCode(block, 'DIVISOR', Order.MODULUS) || '0';\n    if (divisor === '0') {\n      return ['false', Order.ATOMIC];\n    }\n    code = numberToCheck + ' % ' + divisor + ' == 0';\n  } else {\n    code = prefix + numberToCheck + suffix;\n  }\n  return [code, outputOrder];\n}\n\nexport function math_change(block: Block, generator: PhpGenerator) {\n  // Add to a variable in place.\n  const argument0 =\n    generator.valueToCode(block, 'DELTA', Order.ADDITION) || '0';\n  const varName = generator.getVariableName(block.getFieldValue('VAR'));\n  return varName + ' += ' + argument0 + ';\\n';\n}\n\n// Rounding functions have a single operand.\nexport const math_round = math_single;\n// Trigonometry functions have a single operand.\nexport const math_trig = math_single;\n\nexport function math_on_list(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Math functions for lists.\n  const func = block.getFieldValue('OP');\n  let list;\n  let code;\n  switch (func) {\n    case 'SUM':\n      list =\n        generator.valueToCode(block, 'LIST', Order.FUNCTION_CALL) || 'array()';\n      code = 'array_sum(' + list + ')';\n      break;\n    case 'MIN':\n      list =\n        generator.valueToCode(block, 'LIST', Order.FUNCTION_CALL) || 'array()';\n      code = 'min(' + list + ')';\n      break;\n    case 'MAX':\n      list =\n        generator.valueToCode(block, 'LIST', Order.FUNCTION_CALL) || 'array()';\n      code = 'max(' + list + ')';\n      break;\n    case 'AVERAGE': {\n      const functionName = generator.provideFunction_(\n        'math_mean',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}($myList) {\n  return array_sum($myList) / count($myList);\n}\n`,\n      );\n      list = generator.valueToCode(block, 'LIST', Order.NONE) || 'array()';\n      code = functionName + '(' + list + ')';\n      break;\n    }\n    case 'MEDIAN': {\n      const functionName = generator.provideFunction_(\n        'math_median',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}($arr) {\n  sort($arr,SORT_NUMERIC);\n  return (count($arr) % 2) ? $arr[floor(count($arr) / 2)] :\n      ($arr[floor(count($arr) / 2)] + $arr[floor(count($arr) / 2) - 1]) / 2;\n}\n`,\n      );\n      list = generator.valueToCode(block, 'LIST', Order.NONE) || '[]';\n      code = functionName + '(' + list + ')';\n      break;\n    }\n    case 'MODE': {\n      // As a list of numbers can contain more than one mode,\n      // the returned result is provided as an array.\n      // Mode of [3, 'x', 'x', 1, 1, 2, '3'] -> ['x', 1].\n      const functionName = generator.provideFunction_(\n        'math_modes',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}($values) {\n  if (empty($values)) return array();\n  $counts = array_count_values($values);\n  arsort($counts); // Sort counts in descending order\n  $modes = array_keys($counts, current($counts), true);\n  return $modes;\n}\n`,\n      );\n      list = generator.valueToCode(block, 'LIST', Order.NONE) || '[]';\n      code = functionName + '(' + list + ')';\n      break;\n    }\n    case 'STD_DEV': {\n      const functionName = generator.provideFunction_(\n        'math_standard_deviation',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}($numbers) {\n  $n = count($numbers);\n  if (!$n) return null;\n  $mean = array_sum($numbers) / count($numbers);\n  foreach($numbers as $key => $num) $devs[$key] = pow($num - $mean, 2);\n  return sqrt(array_sum($devs) / (count($devs) - 1));\n}\n`,\n      );\n      list = generator.valueToCode(block, 'LIST', Order.NONE) || '[]';\n      code = functionName + '(' + list + ')';\n      break;\n    }\n    case 'RANDOM': {\n      const functionName = generator.provideFunction_(\n        'math_random_list',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}($list) {\n  $x = rand(0, count($list)-1);\n  return $list[$x];\n}\n`,\n      );\n      list = generator.valueToCode(block, 'LIST', Order.NONE) || '[]';\n      code = functionName + '(' + list + ')';\n      break;\n    }\n    default:\n      throw Error('Unknown operator: ' + func);\n  }\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function math_modulo(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Remainder computation.\n  const argument0 =\n    generator.valueToCode(block, 'DIVIDEND', Order.MODULUS) || '0';\n  const argument1 =\n    generator.valueToCode(block, 'DIVISOR', Order.MODULUS) || '0';\n  const code = argument0 + ' % ' + argument1;\n  return [code, Order.MODULUS];\n}\n\nexport function math_constrain(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Constrain a number between two limits.\n  const argument0 = generator.valueToCode(block, 'VALUE', Order.NONE) || '0';\n  const argument1 = generator.valueToCode(block, 'LOW', Order.NONE) || '0';\n  const argument2 =\n    generator.valueToCode(block, 'HIGH', Order.NONE) || 'Infinity';\n  const code =\n    'min(max(' + argument0 + ', ' + argument1 + '), ' + argument2 + ')';\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function math_random_int(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Random integer between [X] and [Y].\n  const argument0 = generator.valueToCode(block, 'FROM', Order.NONE) || '0';\n  const argument1 = generator.valueToCode(block, 'TO', Order.NONE) || '0';\n  const functionName = generator.provideFunction_(\n    'math_random_int',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}($a, $b) {\n  if ($a > $b) {\n    return rand($b, $a);\n  }\n  return rand($a, $b);\n}\n`,\n  );\n  const code = functionName + '(' + argument0 + ', ' + argument1 + ')';\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function math_random_float(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Random fraction between 0 and 1.\n  return ['(float)rand()/(float)getrandmax()', Order.FUNCTION_CALL];\n}\n\nexport function math_atan2(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Arctangent of point (X, Y) in degrees from -180 to 180.\n  const argument0 = generator.valueToCode(block, 'X', Order.NONE) || '0';\n  const argument1 = generator.valueToCode(block, 'Y', Order.NONE) || '0';\n  return [\n    'atan2(' + argument1 + ', ' + argument0 + ') / pi() * 180',\n    Order.DIVISION,\n  ];\n}\n", "/**\n * @license\n * Copyright 2015 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating PHP for procedure blocks.\n */\n\n// Former goog.module ID: Blockly.PHP.procedures\n\nimport type {IfReturnBlock} from '../../blocks/procedures.js';\nimport type {Block} from '../../core/block.js';\nimport {NameType} from '../../core/names.js';\nimport * as Variables from '../../core/variables.js';\nimport type {PhpGenerator} from './php_generator.js';\nimport {Order} from './php_generator.js';\n\nexport function procedures_defreturn(block: Block, generator: PhpGenerator) {\n  // Define a procedure with a return value.\n  // First, add a 'global' statement for every variable that is not shadowed by\n  // a local parameter.\n  const globals = [];\n  const workspace = block.workspace;\n  const usedVariables = Variables.allUsedVarModels(workspace) || [];\n  for (const variable of usedVariables) {\n    const varName = variable.getName();\n    // getVars returns parameter names, not ids, for procedure blocks\n    if (!block.getVars().includes(varName)) {\n      globals.push(generator.getVariableName(varName));\n    }\n  }\n  // Add developer variables.\n  const devVarList = Variables.allDeveloperVariables(workspace);\n  for (let i = 0; i < devVarList.length; i++) {\n    globals.push(\n      generator.nameDB_!.getName(devVarList[i], NameType.DEVELOPER_VARIABLE),\n    );\n  }\n  const globalStr = globals.length\n    ? generator.INDENT + 'global ' + globals.join(', ') + ';\\n'\n    : '';\n\n  const funcName = generator.getProcedureName(block.getFieldValue('NAME'));\n  let xfix1 = '';\n  if (generator.STATEMENT_PREFIX) {\n    xfix1 += generator.injectId(generator.STATEMENT_PREFIX, block);\n  }\n  if (generator.STATEMENT_SUFFIX) {\n    xfix1 += generator.injectId(generator.STATEMENT_SUFFIX, block);\n  }\n  if (xfix1) {\n    xfix1 = generator.prefixLines(xfix1, generator.INDENT);\n  }\n  let loopTrap = '';\n  if (generator.INFINITE_LOOP_TRAP) {\n    loopTrap = generator.prefixLines(\n      generator.injectId(generator.INFINITE_LOOP_TRAP, block),\n      generator.INDENT,\n    );\n  }\n  let branch = '';\n  if (block.getInput('STACK')) {\n    // The 'procedures_defreturn' block might not have a STACK input.\n    branch = generator.statementToCode(block, 'STACK');\n  }\n  let returnValue = '';\n  if (block.getInput('RETURN')) {\n    // The 'procedures_defnoreturn' block (which shares this code)\n    // does not have a RETURN input.\n    returnValue = generator.valueToCode(block, 'RETURN', Order.NONE) || '';\n  }\n  let xfix2 = '';\n  if (branch && returnValue) {\n    // After executing the function body, revisit this block for the return.\n    xfix2 = xfix1;\n  }\n  if (returnValue) {\n    returnValue = generator.INDENT + 'return ' + returnValue + ';\\n';\n  }\n  const args = [];\n  const variables = block.getVars();\n  for (let i = 0; i < variables.length; i++) {\n    args[i] = generator.getVariableName(variables[i]);\n  }\n  let code =\n    'function ' +\n    funcName +\n    '(' +\n    args.join(', ') +\n    ') {\\n' +\n    globalStr +\n    xfix1 +\n    loopTrap +\n    branch +\n    xfix2 +\n    returnValue +\n    '}';\n  code = generator.scrub_(block, code);\n  // Add % so as not to collide with helper functions in definitions list.\n  // TODO(#7600): find better approach than casting to any to override\n  // CodeGenerator declaring .definitions protected.\n  (generator as AnyDuringMigration).definitions_['%' + funcName] = code;\n  return null;\n}\n\n// Defining a procedure without a return value uses the same generator as\n// a procedure with a return value.\nexport const procedures_defnoreturn = procedures_defreturn;\n\nexport function procedures_callreturn(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Call a procedure with a return value.\n  const funcName = generator.getProcedureName(block.getFieldValue('NAME'));\n  const args = [];\n  const variables = block.getVars();\n  for (let i = 0; i < variables.length; i++) {\n    args[i] = generator.valueToCode(block, 'ARG' + i, Order.NONE) || 'null';\n  }\n  const code = funcName + '(' + args.join(', ') + ')';\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function procedures_callnoreturn(block: Block, generator: PhpGenerator) {\n  // Call a procedure with no return value.\n  // Generated code is for a function call as a statement is the same as a\n  // function call as a value, with the addition of line ending.\n  const tuple = generator.forBlock['procedures_callreturn'](\n    block,\n    generator,\n  ) as [string, Order];\n  return tuple[0] + ';\\n';\n}\n\nexport function procedures_ifreturn(block: Block, generator: PhpGenerator) {\n  // Conditionally return value from a procedure.\n  const condition =\n    generator.valueToCode(block, 'CONDITION', Order.NONE) || 'false';\n  let code = 'if (' + condition + ') {\\n';\n  if (generator.STATEMENT_SUFFIX) {\n    // Inject any statement suffix here since the regular one at the end\n    // will not get executed if the return is triggered.\n    code += generator.prefixLines(\n      generator.injectId(generator.STATEMENT_SUFFIX, block),\n      generator.INDENT,\n    );\n  }\n  if ((block as IfReturnBlock).hasReturnValue_) {\n    const value = generator.valueToCode(block, 'VALUE', Order.NONE) || 'null';\n    code += generator.INDENT + 'return ' + value + ';\\n';\n  } else {\n    code += generator.INDENT + 'return;\\n';\n  }\n  code += '}\\n';\n  return code;\n}\n", "/**\n * @license\n * Copyright 2015 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating PHP for text blocks.\n */\n\n// Former goog.module ID: Blockly.PHP.texts\n\nimport type {JoinMutatorBlock} from '../../blocks/text.js';\nimport type {Block} from '../../core/block.js';\nimport type {PhpGenerator} from './php_generator.js';\nimport {Order} from './php_generator.js';\n\nexport function text(block: Block, generator: PhpGenerator): [string, Order] {\n  // Text value.\n  const code = generator.quote_(block.getFieldValue('TEXT'));\n  return [code, Order.ATOMIC];\n}\n\nexport function text_join(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Create a string made up of any number of elements of any type.\n  const joinBlock = block as JoinMutatorBlock;\n  if (joinBlock.itemCount_ === 0) {\n    return [\"''\", Order.ATOMIC];\n  } else if (joinBlock.itemCount_ === 1) {\n    const element = generator.valueToCode(block, 'ADD0', Order.NONE) || \"''\";\n    const code = element;\n    return [code, Order.NONE];\n  } else if (joinBlock.itemCount_ === 2) {\n    const element0 =\n      generator.valueToCode(block, 'ADD0', Order.STRING_CONCAT) || \"''\";\n    const element1 =\n      generator.valueToCode(block, 'ADD1', Order.STRING_CONCAT) || \"''\";\n    const code = element0 + ' . ' + element1;\n    return [code, Order.STRING_CONCAT];\n  } else {\n    const elements = new Array(joinBlock.itemCount_);\n    for (let i = 0; i < joinBlock.itemCount_; i++) {\n      elements[i] = generator.valueToCode(block, 'ADD' + i, Order.NONE) || \"''\";\n    }\n    const code = \"implode('', array(\" + elements.join(',') + '))';\n    return [code, Order.FUNCTION_CALL];\n  }\n}\n\nexport function text_append(block: Block, generator: PhpGenerator) {\n  // Append to a variable in place.\n  const varName = generator.getVariableName(block.getFieldValue('VAR'));\n  const value = generator.valueToCode(block, 'TEXT', Order.ASSIGNMENT) || \"''\";\n  return varName + ' .= ' + value + ';\\n';\n}\n\nexport function text_length(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // String or array length.\n  const functionName = generator.provideFunction_(\n    'length',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}($value) {\n  if (is_string($value)) {\n    return strlen($value);\n  }\n  return count($value);\n}\n`,\n  );\n  const text = generator.valueToCode(block, 'VALUE', Order.NONE) || \"''\";\n  return [functionName + '(' + text + ')', Order.FUNCTION_CALL];\n}\n\nexport function text_isEmpty(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Is the string null or array empty?\n  const text = generator.valueToCode(block, 'VALUE', Order.NONE) || \"''\";\n  return ['empty(' + text + ')', Order.FUNCTION_CALL];\n}\n\nexport function text_indexOf(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Search the text for a substring.\n  const operator =\n    block.getFieldValue('END') === 'FIRST' ? 'strpos' : 'strrpos';\n  const substring = generator.valueToCode(block, 'FIND', Order.NONE) || \"''\";\n  const text = generator.valueToCode(block, 'VALUE', Order.NONE) || \"''\";\n  let errorIndex = ' -1';\n  let indexAdjustment = '';\n  if (block.workspace.options.oneBasedIndex) {\n    errorIndex = ' 0';\n    indexAdjustment = ' + 1';\n  }\n  const functionName = generator.provideFunction_(\n    block.getFieldValue('END') === 'FIRST'\n      ? 'text_indexOf'\n      : 'text_lastIndexOf',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}($text, $search) {\n  $pos = ${operator}($text, $search);\n  return $pos === false ? ${errorIndex} : $pos${indexAdjustment};\n}\n`,\n  );\n  const code = functionName + '(' + text + ', ' + substring + ')';\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function text_charAt(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Get letter at index.\n  const where = block.getFieldValue('WHERE') || 'FROM_START';\n  const textOrder = where === 'RANDOM' ? Order.NONE : Order.NONE;\n  const text = generator.valueToCode(block, 'VALUE', textOrder) || \"''\";\n  switch (where) {\n    case 'FIRST': {\n      const code = 'substr(' + text + ', 0, 1)';\n      return [code, Order.FUNCTION_CALL];\n    }\n    case 'LAST': {\n      const code = 'substr(' + text + ', -1)';\n      return [code, Order.FUNCTION_CALL];\n    }\n    case 'FROM_START': {\n      const at = generator.getAdjusted(block, 'AT');\n      const code = 'substr(' + text + ', ' + at + ', 1)';\n      return [code, Order.FUNCTION_CALL];\n    }\n    case 'FROM_END': {\n      const at = generator.getAdjusted(block, 'AT', 1, true);\n      const code = 'substr(' + text + ', ' + at + ', 1)';\n      return [code, Order.FUNCTION_CALL];\n    }\n    case 'RANDOM': {\n      const functionName = generator.provideFunction_(\n        'text_random_letter',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}($text) {\n  return $text[rand(0, strlen($text) - 1)];\n}\n`,\n      );\n      const code = functionName + '(' + text + ')';\n      return [code, Order.FUNCTION_CALL];\n    }\n  }\n  throw Error('Unhandled option (text_charAt).');\n}\n\nexport function text_getSubstring(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Get substring.\n  const where1 = block.getFieldValue('WHERE1');\n  const where2 = block.getFieldValue('WHERE2');\n  const text = generator.valueToCode(block, 'STRING', Order.NONE) || \"''\";\n  if (where1 === 'FIRST' && where2 === 'LAST') {\n    const code = text;\n    return [code, Order.NONE];\n  } else {\n    const at1 = generator.getAdjusted(block, 'AT1');\n    const at2 = generator.getAdjusted(block, 'AT2');\n    const functionName = generator.provideFunction_(\n      'text_get_substring',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}($text, $where1, $at1, $where2, $at2) {\n  if ($where1 == 'FROM_END') {\n    $at1 = strlen($text) - 1 - $at1;\n  } else if ($where1 == 'FIRST') {\n    $at1 = 0;\n  } else if ($where1 != 'FROM_START') {\n    throw new Exception('Unhandled option (text_get_substring).');\n  }\n  $length = 0;\n  if ($where2 == 'FROM_START') {\n    $length = $at2 - $at1 + 1;\n  } else if ($where2 == 'FROM_END') {\n    $length = strlen($text) - $at1 - $at2;\n  } else if ($where2 == 'LAST') {\n    $length = strlen($text) - $at1;\n  } else {\n    throw new Exception('Unhandled option (text_get_substring).');\n  }\n  return substr($text, $at1, $length);\n}\n`,\n    );\n    const code =\n      functionName +\n      '(' +\n      text +\n      \", '\" +\n      where1 +\n      \"', \" +\n      at1 +\n      \", '\" +\n      where2 +\n      \"', \" +\n      at2 +\n      ')';\n    return [code, Order.FUNCTION_CALL];\n  }\n}\n\nexport function text_changeCase(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Change capitalization.\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  let code;\n  if (block.getFieldValue('CASE') === 'UPPERCASE') {\n    code = 'strtoupper(' + text + ')';\n  } else if (block.getFieldValue('CASE') === 'LOWERCASE') {\n    code = 'strtolower(' + text + ')';\n  } else if (block.getFieldValue('CASE') === 'TITLECASE') {\n    code = 'ucwords(strtolower(' + text + '))';\n  }\n  return [code as string, Order.FUNCTION_CALL];\n}\n\nexport function text_trim(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Trim spaces.\n  const OPERATORS = {'LEFT': 'ltrim', 'RIGHT': 'rtrim', 'BOTH': 'trim'};\n  type OperatorOption = keyof typeof OPERATORS;\n  const operator = OPERATORS[block.getFieldValue('MODE') as OperatorOption];\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  return [operator + '(' + text + ')', Order.FUNCTION_CALL];\n}\n\nexport function text_print(block: Block, generator: PhpGenerator) {\n  // Print statement.\n  const msg = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  return 'print(' + msg + ');\\n';\n}\n\nexport function text_prompt_ext(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Prompt function.\n  let msg;\n  if (block.getField('TEXT')) {\n    // Internal message.\n    msg = generator.quote_(block.getFieldValue('TEXT'));\n  } else {\n    // External message.\n    msg = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  }\n  let code = 'readline(' + msg + ')';\n  const toNumber = block.getFieldValue('TYPE') === 'NUMBER';\n  if (toNumber) {\n    code = 'floatval(' + code + ')';\n  }\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport const text_prompt = text_prompt_ext;\n\nexport function text_count(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const sub = generator.valueToCode(block, 'SUB', Order.NONE) || \"''\";\n  const code =\n    'strlen(' +\n    sub +\n    ') === 0' +\n    ' ? strlen(' +\n    text +\n    ') + 1' +\n    ' : substr_count(' +\n    text +\n    ', ' +\n    sub +\n    ')';\n  return [code, Order.CONDITIONAL];\n}\n\nexport function text_replace(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const from = generator.valueToCode(block, 'FROM', Order.NONE) || \"''\";\n  const to = generator.valueToCode(block, 'TO', Order.NONE) || \"''\";\n  const code = 'str_replace(' + from + ', ' + to + ', ' + text + ')';\n  return [code, Order.FUNCTION_CALL];\n}\n\nexport function text_reverse(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const code = 'strrev(' + text + ')';\n  return [code, Order.FUNCTION_CALL];\n}\n", "/**\n * @license\n * Copyright 2015 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating PHP for variable blocks.\n */\n\n// Former goog.module ID: Blockly.PHP.variables\n\nimport type {Block} from '../../core/block.js';\nimport type {PhpGenerator} from './php_generator.js';\nimport {Order} from './php_generator.js';\n\nexport function variables_get(\n  block: Block,\n  generator: PhpGenerator,\n): [string, Order] {\n  // Variable getter.\n  const code = generator.getVariableName(block.getFieldValue('VAR'));\n  return [code, Order.ATOMIC];\n}\n\nexport function variables_set(block: Block, generator: PhpGenerator) {\n  // Variable setter.\n  const argument0 =\n    generator.valueToCode(block, 'VALUE', Order.ASSIGNMENT) || '0';\n  const varName = generator.getVariableName(block.getFieldValue('VAR'));\n  return varName + ' = ' + argument0 + ';\\n';\n}\n", "/**\n * @license\n * Copyright 2015 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file PHP code generator class, including helper methods for\n * generating PHP for blocks.\n */\n\n// Former goog.module ID: Blockly.PHP\n\nimport type {Block} from '../../core/block.js';\nimport {CodeGenerator} from '../../core/generator.js';\nimport {inputTypes} from '../../core/inputs/input_types.js';\nimport {Names} from '../../core/names.js';\nimport * as stringUtils from '../../core/utils/string.js';\nimport type {Workspace} from '../../core/workspace.js';\n\n/**\n * Order of operation ENUMs.\n * http://php.net/manual/en/language.operators.precedence.php\n */\n// prettier-ignore\nexport enum Order {\n  ATOMIC = 0,             // 0 \"\" ...\n  CLONE = 1,              // clone\n  NEW = 1,                // new\n  MEMBER = 2.1,           // []\n  FUNCTION_CALL = 2.2,    // ()\n  POWER = 3,              // **\n  INCREMENT = 4,          // ++\n  DECREMENT = 4,          // --\n  BITWISE_NOT = 4,        // ~\n  CAST = 4,               // (int) (float) (string) (array) ...\n  SUPPRESS_ERROR = 4,     // @\n  INSTANCEOF = 5,         // instanceof\n  LOGICAL_NOT = 6,        // !\n  UNARY_PLUS = 7.1,       // +\n  UNARY_NEGATION = 7.2,   // -\n  MULTIPLICATION = 8.1,   // *\n  DIVISION = 8.2,         // /\n  MODULUS = 8.3,          // %\n  ADDITION = 9.1,         // +\n  SUBTRACTION = 9.2,      // -\n  STRING_CONCAT = 9.3,    // .\n  BITWISE_SHIFT = 10,     // << >>\n  RELATIONAL = 11,        // < <= > >=\n  EQUALITY = 12,          // == != === !== <> <=>\n  REFERENCE = 13,         // &\n  BITWISE_AND = 13,       // &\n  BITWISE_XOR = 14,       // ^\n  BITWISE_OR = 15,        // |\n  LOGICAL_AND = 16,       // &&\n  LOGICAL_OR = 17,        // ||\n  IF_NULL = 18,           // ??\n  CONDITIONAL = 19,       // ?:\n  ASSIGNMENT = 20,        // = += -= *= /= %= <<= >>= ...\n  LOGICAL_AND_WEAK = 21,  // and\n  LOGICAL_XOR = 22,       // xor\n  LOGICAL_OR_WEAK = 23,   // or\n  NONE = 99,              // (...)\n}\n\nexport class PhpGenerator extends CodeGenerator {\n  /** List of outer-inner pairings that do NOT require parentheses. */\n  ORDER_OVERRIDES: [Order, Order][] = [\n    // (foo()).bar() -> foo().bar()\n    // (foo())[0] -> foo()[0]\n    [Order.MEMBER, Order.FUNCTION_CALL],\n    // (foo[0])[1] -> foo[0][1]\n    // (foo.bar).baz -> foo.bar.baz\n    [Order.MEMBER, Order.MEMBER],\n    // !(!foo) -> !!foo\n    [Order.LOGICAL_NOT, Order.LOGICAL_NOT],\n    // a * (b * c) -> a * b * c\n    [Order.MULTIPLICATION, Order.MULTIPLICATION],\n    // a + (b + c) -> a + b + c\n    [Order.ADDITION, Order.ADDITION],\n    // a && (b && c) -> a && b && c\n    [Order.LOGICAL_AND, Order.LOGICAL_AND],\n    // a || (b || c) -> a || b || c\n    [Order.LOGICAL_OR, Order.LOGICAL_OR],\n  ];\n\n  /** @param name Name of the language the generator is for. */\n  constructor(name = 'PHP') {\n    super(name);\n    this.isInitialized = false;\n\n    // Copy Order values onto instance for backwards compatibility\n    // while ensuring they are not part of the publically-advertised\n    // API.\n    //\n    // TODO(#7085): deprecate these in due course.  (Could initially\n    // replace data properties with get accessors that call\n    // deprecate.warn().)\n    for (const key in Order) {\n      // Must assign Order[key] to a temporary to get the type guard to work;\n      // see https://github.com/microsoft/TypeScript/issues/10530.\n      const value = Order[key];\n      // Skip reverse-lookup entries in the enum.  Due to\n      // https://github.com/microsoft/TypeScript/issues/55713 this (as\n      // of TypeScript 5.5.2) actually narrows the type of value to\n      // never - but that still allows the following assignment to\n      // succeed.\n      if (typeof value === 'string') continue;\n      (this as unknown as Record<string, Order>)['ORDER_' + key] = value;\n    }\n\n    // List of illegal variable names.  This is not intended to be a\n    // security feature.  Blockly is 100% client-side, so bypassing\n    // this list is trivial.  This is intended to prevent users from\n    // accidentally clobbering a built-in object or function.\n    this.addReservedWords(\n      // http://php.net/manual/en/reserved.keywords.php\n      '__halt_compiler,abstract,and,array,as,break,callable,case,catch,class,' +\n        'clone,const,continue,declare,default,die,do,echo,else,elseif,empty,' +\n        'enddeclare,endfor,endforeach,endif,endswitch,endwhile,eval,exit,' +\n        'extends,final,for,foreach,function,global,goto,if,implements,include,' +\n        'include_once,instanceof,insteadof,interface,isset,list,namespace,new,' +\n        'or,print,private,protected,public,require,require_once,return,static,' +\n        'switch,throw,trait,try,unset,use,var,while,xor,' +\n        // http://php.net/manual/en/reserved.constants.php\n        'PHP_VERSION,PHP_MAJOR_VERSION,PHP_MINOR_VERSION,PHP_RELEASE_VERSION,' +\n        'PHP_VERSION_ID,PHP_EXTRA_VERSION,PHP_ZTS,PHP_DEBUG,PHP_MAXPATHLEN,' +\n        'PHP_OS,PHP_SAPI,PHP_EOL,PHP_INT_MAX,PHP_INT_SIZE,DEFAULT_INCLUDE_PATH,' +\n        'PEAR_INSTALL_DIR,PEAR_EXTENSION_DIR,PHP_EXTENSION_DIR,PHP_PREFIX,' +\n        'PHP_BINDIR,PHP_BINARY,PHP_MANDIR,PHP_LIBDIR,PHP_DATADIR,' +\n        'PHP_SYSCONFDIR,PHP_LOCALSTATEDIR,PHP_CONFIG_FILE_PATH,' +\n        'PHP_CONFIG_FILE_SCAN_DIR,PHP_SHLIB_SUFFIX,E_ERROR,E_WARNING,E_PARSE,' +\n        'E_NOTICE,E_CORE_ERROR,E_CORE_WARNING,E_COMPILE_ERROR,' +\n        'E_COMPILE_WARNING,E_USER_ERROR,E_USER_WARNING,E_USER_NOTICE,' +\n        'E_DEPRECATED,E_USER_DEPRECATED,E_ALL,E_STRICT,' +\n        '__COMPILER_HALT_OFFSET__,TRUE,FALSE,NULL,__CLASS__,__DIR__,__FILE__,' +\n        '__FUNCTION__,__LINE__,__METHOD__,__NAMESPACE__,__TRAIT__',\n    );\n  }\n\n  /**\n   * Initialise the database of variable names.\n   *\n   * @param workspace Workspace to generate code from.\n   */\n  init(workspace: Workspace) {\n    super.init(workspace);\n\n    if (!this.nameDB_) {\n      this.nameDB_ = new Names(this.RESERVED_WORDS_, '$');\n    } else {\n      this.nameDB_.reset();\n    }\n\n    this.nameDB_.setVariableMap(workspace.getVariableMap());\n    this.nameDB_.populateVariables(workspace);\n    this.nameDB_.populateProcedures(workspace);\n\n    this.isInitialized = true;\n  }\n\n  /**\n   * Prepend the generated code with the variable definitions.\n   *\n   * @param code Generated code.\n   * @returns Completed code.\n   */\n  finish(code: string): string {\n    // Convert the definitions dictionary into a list.\n    const definitions = Object.values(this.definitions_);\n    // Call Blockly.CodeGenerator's finish.\n    code = super.finish(code);\n    this.isInitialized = false;\n\n    this.nameDB_!.reset();\n    return definitions.join('\\n\\n') + '\\n\\n\\n' + code;\n  }\n\n  /**\n   * Naked values are top-level blocks with outputs that aren't plugged into\n   * anything.\n   *\n   * @param line Line of generated code.\n   * @returns Legal line of code.\n   */\n  scrubNakedValue(line: string): string {\n    return line + ';\\n';\n  }\n\n  /**\n   * Encode a string as a properly escaped PHP string, complete with\n   * quotes.\n   *\n   * @param string Text to encode.\n   * @returns PHP string.\n   */\n  quote_(string: string): string {\n    string = string\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\n/g, '\\\\\\n')\n      .replace(/'/g, \"\\\\'\");\n    return \"'\" + string + \"'\";\n  }\n\n  /**\n   * Encode a string as a properly escaped multiline PHP string, complete with\n   * quotes.\n   * @param string Text to encode.\n   * @returns PHP string.\n   */\n  multiline_quote_(string: string): string {\n    const lines = string.split(/\\n/g).map(this.quote_);\n    // Join with the following, plus a newline:\n    // . \"\\n\" .\n    // Newline escaping only works in double-quoted strings.\n    return lines.join(' . \"\\\\n\" .\\n');\n  }\n\n  /**\n   * Common tasks for generating PHP from blocks.\n   * Handles comments for the specified block and any connected value blocks.\n   * Calls any statements following this block.\n   *\n   * @param block The current block.\n   * @param code The PHP code created for this block.\n   * @param thisOnly True to generate code for only this statement.\n   * @returns PHP code with comments and subsequent blocks added.\n   */\n  scrub_(block: Block, code: string, thisOnly = false): string {\n    let commentCode = '';\n    // Only collect comments for blocks that aren't inline.\n    if (!block.outputConnection || !block.outputConnection.targetConnection) {\n      // Collect comment for this block.\n      let comment = block.getCommentText();\n      if (comment) {\n        comment = stringUtils.wrap(comment, this.COMMENT_WRAP - 3);\n        commentCode += this.prefixLines(comment, '// ') + '\\n';\n      }\n      // Collect comments for all value arguments.\n      // Don't collect comments for nested statements.\n      for (let i = 0; i < block.inputList.length; i++) {\n        if (block.inputList[i].type === inputTypes.VALUE) {\n          const childBlock = block.inputList[i].connection!.targetBlock();\n          if (childBlock) {\n            comment = this.allNestedComments(childBlock);\n            if (comment) {\n              commentCode += this.prefixLines(comment, '// ');\n            }\n          }\n        }\n      }\n    }\n    const nextBlock =\n      block.nextConnection && block.nextConnection.targetBlock();\n    const nextCode = thisOnly ? '' : this.blockToCode(nextBlock);\n    return commentCode + code + nextCode;\n  }\n\n  /**\n   * Generate code representing the specified value input, adjusted to take into\n   * account indexing (zero- or one-based) and optionally by a specified delta\n   * and/or by negation.\n   *\n   * @param block The block.\n   * @param atId The ID of the input block to get (and adjust) the value of.\n   * @param delta Value to add.\n   * @param negate Whether to negate the value.\n   * @param order The highest order acting on this value.\n   * @returns The adjusted value or code that evaluates to it.\n   */\n  getAdjusted(\n    block: Block,\n    atId: string,\n    delta = 0,\n    negate = false,\n    order = Order.NONE,\n  ): string {\n    if (block.workspace.options.oneBasedIndex) {\n      delta--;\n    }\n    let defaultAtIndex = block.workspace.options.oneBasedIndex ? '1' : '0';\n\n    let orderForInput = order;\n    if (delta > 0) {\n      orderForInput = Order.ADDITION;\n    } else if (delta < 0) {\n      orderForInput = Order.SUBTRACTION;\n    } else if (negate) {\n      orderForInput = Order.UNARY_NEGATION;\n    }\n\n    let at = this.valueToCode(block, atId, orderForInput) || defaultAtIndex;\n\n    // Easy case: no adjustments.\n    if (delta === 0 && !negate) {\n      return at;\n    }\n    // If the index is a naked number, adjust it right now.\n    if (stringUtils.isNumber(at)) {\n      at = String(Number(at) + delta);\n      if (negate) {\n        at = String(-Number(at));\n      }\n      return at;\n    }\n    // If the index is dynamic, adjust it in code.\n    if (delta > 0) {\n      at = `${at} + ${delta}`;\n    } else if (delta < 0) {\n      at = `${at} - ${-delta}`;\n    }\n    if (negate) {\n      at = delta ? `-(${at})` : `-${at}`;\n    }\n    if (Math.floor(order) >= Math.floor(orderForInput)) {\n      at = `(${at})`;\n    }\n    return at;\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating PHP for dynamic variable blocks.\n */\n\n// Former goog.module ID: Blockly.PHP.variablesDynamic\n\n// generator is dynamically typed.\nexport {\n  variables_get as variables_get_dynamic,\n  variables_set as variables_set_dynamic,\n} from './variables.js';\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Instantiate a PhpGenerator and populate it with the complete\n * set of block generator functions for PHP.  This is the entrypoint\n * for php_compressed.js.\n */\n\n// Former goog.module ID: Blockly.PHP.all\n\nimport * as lists from './php/lists.js';\nimport * as logic from './php/logic.js';\nimport * as loops from './php/loops.js';\nimport * as math from './php/math.js';\nimport {PhpGenerator} from './php/php_generator.js';\nimport * as procedures from './php/procedures.js';\nimport * as text from './php/text.js';\nimport * as variables from './php/variables.js';\nimport * as variablesDynamic from './php/variables_dynamic.js';\n\nexport * from './php/php_generator.js';\n\n/**\n * Php code generator instance.\n * @type {!PhpGenerator}\n */\nexport const phpGenerator = new PhpGenerator();\n\n// Install per-block-type generator functions:\nconst generators: typeof phpGenerator.forBlock = {\n  ...lists,\n  ...logic,\n  ...loops,\n  ...math,\n  ...procedures,\n  ...text,\n  ...variables,\n  ...variablesDynamic,\n};\nfor (const name in generators) {\n  phpGenerator.forBlock[name] = generators[name];\n}\n"],
  "mappings": "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",
  "names": ["lists_create_empty", "block", "generator", "Order", "ATOMIC", "lists_create_with", "elements", "Array", "itemCount_", "i", "valueToCode", "NONE", "join", "lists_repeat", "functionName", "provideFunction_", "FUNCTION_NAME_PLACEHOLDER_", "element", "repeatCount", "FUNCTION_CALL", "lists_length", "MEMBER", "lists_isEmpty", "LOGICAL_NOT", "lists_indexOf", "operator", "getFieldValue", "item", "code", "workspace", "options", "oneBasedIndex", "ADDITION", "lists_getIndex", "mode", "where", "list", "at", "getAdjusted", "Error", "lists_setIndex", "cacheList", "match", "listVar", "nameDB_", "getDistinctName", "NameType", "VARIABLE", "value", "ASSIGNMENT", "SUBTRACTION", "xVar", "lists_getSublist", "wherePascalCase", "where1", "where2", "at1", "at2", "getSubstringIndex", "lists_sort", "direction", "type", "getCompareFunctionName", "lists_split", "input", "delimiter", "lists_reverse", "controls_if", "n", "STATEMENT_PREFIX", "injectId", "conditionCode", "branchCode", "statementToCode", "STATEMENT_SUFFIX", "prefixLines", "INDENT", "getInput", "logic_compare", "OPERATORS", "order", "EQUALITY", "RELATIONAL", "argument0", "argument1", "logic_operation", "LOGICAL_AND", "LOGICAL_OR", "defaultArgument", "logic_negate", "logic_boolean", "logic_null", "logic_ternary", "value_if", "CONDITIONAL", "value_then", "value_else", "controls_repeat_ext", "repeats", "getField", "String", "Number", "branch", "addLoopTrap", "loopVar", "endVar", "isNumber", "controls_whileUntil", "until", "controls_for", "variable0", "getVariableName", "increment", "up", "step", "Math", "abs", "startVar", "incVar", "controls_forEach", "indexVar", "controls_flow_statements", "xfix", "loop", "getSurroundLoop", "suppressPrefixSuffix", "math_number", "number", "UNARY_NEGATION", "math_arithmetic", "tuple", "MULTIPLICATION", "DIVISION", "math_single", "arg", "math_constant", "CONSTANTS", "math_number_property", "PROPERTIES", "MODULUS", "dropdownProperty", "suffix", "inputOrder", "outputOrder", "numberToCheck", "divisor", "math_change", "varName", "math_on_list", "func", "math_modulo", "math_constrain", "argument2", "math_random_int", "math_random_float", "math_atan2", "procedures_defreturn", "funcName", "getProcedureName", "xfix1", "loopTrap", "INFINITE_LOOP_TRAP", "returnValue", "xfix2", "args", "variables", "getVars", "length", "scrub_", "definitions_", "procedures_callreturn", "procedures_callnoreturn", "forBlock", "procedures_ifreturn", "hasReturnValue_", "text", "quote_", "text_join", "forceString", "codeAndOrder", "element0", "element1", "text_append", "text_length", "text_isEmpty", "text_indexOf", "substring", "text_charAt", "text_getSubstring", "requiresLengthCall", "text_changeCase", "text_trim", "text_print", "text_prompt_ext", "text_count", "sub", "text_replace", "from", "to", "text_reverse", "variables_get", "variables_set", "NEW", "INCREMENT", "DECREMENT", "BITWISE_NOT", "UNARY_PLUS", "TYPEOF", "VOID", "DELETE", "AWAIT", "EXPONENTIATION", "BITWISE_SHIFT", "IN", "INSTANCEOF", "BITWISE_AND", "BITWISE_XOR", "BITWISE_OR", "YIELD", "COMMA", "JavascriptGenerator", "CodeGenerator", "constructor", "name", "ORDER_OVERRIDES", "isInitialized", "key", "addReservedWords", "Object", "getOwnPropertyNames", "globalThis", "init", "reset", "Names", "RESERVED_WORDS_", "setVariableMap", "getVariableMap", "populateVariables", "populateProcedures", "defvars", "devVarList", "allDeveloperVariables", "push", "getName", "DEVELOPER_VARIABLE", "allUsedVarModels", "getId", "finish", "definitions", "values", "scrubNakedValue", "line", "string", "replace", "multiline_quote_", "split", "map", "lines", "thisOnly", "commentCode", "outputConnection", "targetConnection", "comment", "getCommentText", "wrap", "COMMENT_WRAP", "inputList", "inputTypes", "VALUE", "childBlock", "connection", "targetBlock", "allNestedComments", "nextBlock", "nextConnection", "nextCode", "blockToCode", "atId", "delta", "negate", "defaultAtIndex", "orderForInput", "floor", "$jscomp$tmp$exports$module$name", "listName", "opt_at", "controls_ifelse", "controls_repeat", "math_round", "math_trig", "procedures_defnoreturn", "strRegExp", "test", "stringName", "text_prompt", "javascriptGenerator", "generators", "lists", "logic", "loops", "math", "procedures", "variablesDynamic", "lists_create_empty", "block", "generator", "Order", "ATOMIC", "lists_create_with", "elements", "Array", "itemCount_", "i", "valueToCode", "NONE", "join", "lists_repeat", "element", "UNARY_POSTFIX", "lists_length", "lists_isEmpty", "lists_indexOf", "operator", "getFieldValue", "item", "code", "workspace", "options", "oneBasedIndex", "ADDITIVE", "lists_getIndex", "cacheList", "listVar", "nameDB_", "getDistinctName", "NameType", "VARIABLE", "list", "mode", "where", "match", "at", "getAdjusted", "definitions_", "xVar", "provideFunction_", "FUNCTION_NAME_PLACEHOLDER_", "functionName", "Error", "lists_setIndex", "value", "ASSIGNMENT", "lists_getSublist", "where1", "where2", "at1", "at2", "lists_sort", "direction", "type", "sortFunctionName", "lists_split", "input", "delimiter", "lists_reverse", "controls_if", "n", "branchCode", "conditionCode", "STATEMENT_PREFIX", "injectId", "statementToCode", "STATEMENT_SUFFIX", "prefixLines", "INDENT", "getInput", "logic_compare", "OPERATORS", "order", "EQUALITY", "RELATIONAL", "argument0", "argument1", "logic_operation", "LOGICAL_AND", "LOGICAL_OR", "defaultArgument", "logic_negate", "UNARY_PREFIX", "logic_boolean", "logic_null", "logic_ternary", "value_if", "CONDITIONAL", "value_then", "value_else", "controls_repeat_ext", "repeats", "getField", "String", "Number", "branch", "addLoopTrap", "loopVar", "endVar", "isNumber", "controls_whileUntil", "until", "controls_for", "variable0", "getVariableName", "increment", "up", "step", "Math", "abs", "startVar", "incVar", "controls_forEach", "controls_flow_statements", "xfix", "loop", "getSurroundLoop", "suppressPrefixSuffix", "math_number", "number", "Infinity", "math_arithmetic", "tuple", "MULTIPLICATIVE", "math_single", "arg", "substring", "math_constant", "CONSTANTS", "constant", "math_number_property", "PROPERTIES", "dropdownProperty", "suffix", "inputOrder", "outputOrder", "numberToCheck", "divisor", "math_change", "varName", "math_on_list", "func", "math_modulo", "math_constrain", "argument2", "math_random_int", "math_random_float", "math_atan2", "procedures_defreturn", "funcName", "getProcedureName", "xfix1", "loopTrap", "INFINITE_LOOP_TRAP", "returnValue", "xfix2", "returnType", "args", "variables", "getVars", "length", "scrub_", "procedures_callreturn", "procedures_callnoreturn", "forBlock", "procedures_ifreturn", "hasReturnValue_", "text", "quote_", "text_join", "text_append", "text_length", "text_isEmpty", "text_indexOf", "text_charAt", "text_getSubstring", "requiresLengthCall", "text_changeCase", "text_trim", "text_print", "text_prompt_ext", "text_count", "sub", "text_replace", "from", "to", "text_reverse", "variables_get", "variables_set", "SHIFT", "BITWISE_AND", "BITWISE_XOR", "BITWISE_OR", "IF_NULL", "CASCADE", "DartGenerator", "CodeGenerator", "constructor", "name", "isInitialized", "key", "addReservedWords", "init", "reset", "Names", "RESERVED_WORDS_", "setVariableMap", "getVariableMap", "populateVariables", "populateProcedures", "defvars", "devVarList", "allDeveloperVariables", "push", "getName", "DEVELOPER_VARIABLE", "allUsedVarModels", "getId", "finish", "imports", "definitions", "def", "replace", "scrubNakedValue", "line", "string", "multiline_quote_", "split", "map", "lines", "thisOnly", "commentCode", "outputConnection", "targetConnection", "comment", "getCommentText", "wrap", "COMMENT_WRAP", "getProcedureDef", "inputList", "inputTypes", "VALUE", "childBlock", "connection", "targetBlock", "allNestedComments", "nextBlock", "nextConnection", "nextCode", "blockToCode", "atId", "delta", "negate", "defaultAtIndex", "orderForInput", "floor", "$jscomp$tmp$exports$module$name", "controls_ifelse", "controls_repeat", "math_round", "math_trig", "procedures_defnoreturn", "text_prompt", "dartGenerator", "generators", "lists", "logic", "loops", "math", "procedures", "variablesDynamic", "lists_create_empty", "block", "generator", "Order", "HIGH", "lists_create_with", "elements", "Array", "itemCount_", "i", "valueToCode", "NONE", "join", "lists_repeat", "functionName", "provideFunction_", "FUNCTION_NAME_PLACEHOLDER_", "element", "repeatCount", "lists_length", "UNARY", "lists_isEmpty", "RELATIONAL", "lists_indexOf", "item", "list", "getFieldValue", "lists_getIndex", "mode", "where", "match", "at", "ADDITIVE", "getListIndex", "code", "listVar", "nameDB_", "getDistinctName", "NameType", "VARIABLE", "toLowerCase", "lists_setIndex", "value", "lists_getSublist", "where1", "where2", "at1", "at2", "at1Param", "at2Param", "lists_sort", "direction", "type", "lists_split", "input", "delimiter", "Error", "lists_reverse", "controls_if", "n", "STATEMENT_PREFIX", "injectId", "conditionCode", "branchCode", "statementToCode", "STATEMENT_SUFFIX", "prefixLines", "INDENT", "getInput", "logic_compare", "operator", "OPERATORS", "argument0", "argument1", "logic_operation", "order", "AND", "OR", "defaultArgument", "logic_negate", "logic_boolean", "ATOMIC", "logic_null", "logic_ternary", "value_if", "value_then", "value_else", "addContinueLabel", "branch", "indent", "includes", "CONTINUE_STATEMENT", "controls_repeat_ext", "repeats", "getField", "String", "Number", "isNumber", "parseInt", "addLoopTrap", "loopVar", "controls_whileUntil", "until", "controls_for", "variable0", "getVariableName", "startVar", "endVar", "increment", "incValue", "Math", "abs", "step", "controls_forEach", "controls_flow_statements", "xfix", "loop", "getSurroundLoop", "suppressPrefixSuffix", "math_number", "math_arithmetic", "tuple", "MULTIPLICATIVE", "EXPONENTIATION", "math_single", "arg", "math_constant", "CONSTANTS", "math_number_property", "PROPERTIES", "dropdownProperty", "suffix", "inputOrder", "outputOrder", "numberToCheck", "divisor", "math_change", "varName", "math_on_list", "provideSum", "func", "math_modulo", "math_constrain", "argument2", "math_random_int", "math_random_float", "math_atan2", "procedures_defreturn", "funcName", "getProcedureName", "xfix1", "loopTrap", "INFINITE_LOOP_TRAP", "returnValue", "xfix2", "args", "variables", "getVars", "length", "scrub_", "definitions_", "procedures_callreturn", "procedures_callnoreturn", "forBlock", "procedures_ifreturn", "hasReturnValue_", "text", "quote_", "text_join", "element0", "CONCATENATION", "element1", "text_append", "text_length", "text_isEmpty", "text_indexOf", "substring", "text_charAt", "start", "text_getSubstring", "end", "text_changeCase", "text_trim", "LEFT", "RIGHT", "BOTH", "text_print", "text_prompt_ext", "msg", "text_count", "sub", "text_replace", "from", "to", "text_reverse", "variables_get", "variables_set", "LuaGenerator", "CodeGenerator", "constructor", "name", "isInitialized", "key", "addReservedWords", "init", "workspace", "reset", "Names", "RESERVED_WORDS_", "setVariableMap", "getVariableMap", "populateVariables", "populateProcedures", "finish", "definitions", "Object", "values", "scrubNakedValue", "line", "string", "replace", "multiline_quote_", "split", "map", "lines", "thisOnly", "commentCode", "outputConnection", "targetConnection", "comment", "getCommentText", "wrap", "COMMENT_WRAP", "inputList", "inputTypes", "VALUE", "childBlock", "connection", "targetBlock", "allNestedComments", "nextBlock", "nextConnection", "nextCode", "blockToCode", "$jscomp$tmp$exports$module$name", "listName", "opt_at", "controls_ifelse", "controls_repeat", "math_round", "math_trig", "procedures_defnoreturn", "text_prompt", "luaGenerator", "generators", "lists", "logic", "loops", "math", "procedures", "variablesDynamic", "lists_create_empty", "block", "generator", "Order", "FUNCTION_CALL", "lists_create_with", "elements", "Array", "itemCount_", "i", "valueToCode", "NONE", "join", "lists_repeat", "functionName", "provideFunction_", "FUNCTION_NAME_PLACEHOLDER_", "element", "repeatCount", "lists_length", "list", "lists_isEmpty", "lists_indexOf", "argument0", "argument1", "MEMBER", "errorIndex", "indexAdjustment", "workspace", "options", "oneBasedIndex", "getFieldValue", "lists_getIndex", "mode", "at", "getAdjusted", "SUBTRACTION", "code", "Error", "lists_setIndex", "where", "value", "ASSIGNMENT", "cachedList", "REFERENCE", "match", "listVar", "nameDB_", "getDistinctName", "NameType", "VARIABLE", "xVar", "lists_getSublist", "where1", "where2", "at1", "at2", "length", "isNumber", "String", "lists_sort", "listCode", "direction", "type", "lists_split", "value_input", "value_delim", "lists_reverse", "controls_if", "n", "branchCode", "conditionCode", "STATEMENT_PREFIX", "injectId", "statementToCode", "STATEMENT_SUFFIX", "prefixLines", "INDENT", "getInput", "logic_compare", "operator", "OPERATORS", "order", "EQUALITY", "RELATIONAL", "logic_operation", "LOGICAL_AND", "LOGICAL_OR", "defaultArgument", "logic_negate", "LOGICAL_NOT", "logic_boolean", "ATOMIC", "logic_null", "logic_ternary", "value_if", "CONDITIONAL", "value_then", "value_else", "controls_repeat_ext", "repeats", "getField", "Number", "branch", "addLoopTrap", "loopVar", "endVar", "controls_whileUntil", "until", "controls_for", "variable0", "getVariableName", "increment", "up", "step", "Math", "abs", "startVar", "incVar", "controls_forEach", "controls_flow_statements", "xfix", "loop", "getSurroundLoop", "suppressPrefixSuffix", "math_number", "number", "Infinity", "UNARY_NEGATION", "math_arithmetic", "tuple", "ADDITION", "MULTIPLICATION", "DIVISION", "POWER", "math_single", "arg", "math_constant", "CONSTANTS", "math_number_property", "PROPERTIES", "MODULUS", "dropdownProperty", "prefix", "suffix", "inputOrder", "outputOrder", "numberToCheck", "divisor", "math_change", "varName", "math_on_list", "func", "math_modulo", "math_constrain", "argument2", "math_random_int", "math_random_float", "math_atan2", "procedures_defreturn", "globals", "usedVariables", "allUsedVarModels", "variable", "getName", "getVars", "includes", "push", "devVarList", "allDeveloperVariables", "DEVELOPER_VARIABLE", "funcName", "getProcedureName", "xfix1", "loopTrap", "INFINITE_LOOP_TRAP", "returnValue", "xfix2", "args", "variables", "globalStr", "scrub_", "definitions_", "procedures_callreturn", "procedures_callnoreturn", "forBlock", "procedures_ifreturn", "hasReturnValue_", "text", "quote_", "text_join", "element0", "STRING_CONCAT", "element1", "text_append", "text_length", "text_isEmpty", "text_indexOf", "substring", "text_charAt", "text_getSubstring", "text_changeCase", "text_trim", "text_print", "text_prompt_ext", "text_count", "sub", "text_replace", "from", "to", "text_reverse", "variables_get", "variables_set", "CLONE", "NEW", "INCREMENT", "DECREMENT", "BITWISE_NOT", "CAST", "SUPPRESS_ERROR", "INSTANCEOF", "UNARY_PLUS", "BITWISE_SHIFT", "BITWISE_AND", "BITWISE_XOR", "BITWISE_OR", "IF_NULL", "LOGICAL_AND_WEAK", "LOGICAL_XOR", "LOGICAL_OR_WEAK", "PhpGenerator", "CodeGenerator", "constructor", "name", "ORDER_OVERRIDES", "isInitialized", "key", "addReservedWords", "init", "reset", "Names", "RESERVED_WORDS_", "setVariableMap", "getVariableMap", "populateVariables", "populateProcedures", "finish", "definitions", "Object", "values", "scrubNakedValue", "line", "string", "replace", "multiline_quote_", "split", "map", "lines", "thisOnly", "commentCode", "outputConnection", "targetConnection", "comment", "getCommentText", "wrap", "COMMENT_WRAP", "inputList", "inputTypes", "VALUE", "childBlock", "connection", "targetBlock", "allNestedComments", "nextBlock", "nextConnection", "nextCode", "blockToCode", "atId", "delta", "negate", "defaultAtIndex", "orderForInput", "floor", "$jscomp$tmp$exports$module$name", "controls_ifelse", "controls_repeat", "math_round", "math_trig", "procedures_defnoreturn", "text_prompt", "phpGenerator", "generators", "lists", "logic", "loops", "math", "procedures", "variablesDynamic"]
}
