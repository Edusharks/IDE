import {
  require_blockly_compressed
} from "./chunk-37NJYYKB.js";
import {
  __commonJS
} from "./chunk-PLDDJCW6.js";

// node_modules/@blockly/workspace-minimap/dist/index.js
var require_dist = __commonJS({
  "node_modules/@blockly/workspace-minimap/dist/index.js"(exports, module) {
    !(function(i, t) {
      if ("object" == typeof exports && "object" == typeof module) module.exports = t(require_blockly_compressed());
      else if ("function" == typeof define && define.amd) define(["blockly/core"], t);
      else {
        var e = "object" == typeof exports ? t(require_blockly_compressed()) : t(i.Blockly);
        for (var s in e) ("object" == typeof exports ? exports : i)[s] = e[s];
      }
    })(exports, (i) => (() => {
      "use strict";
      var t = { 370: (t2) => {
        t2.exports = i;
      } }, e = {};
      function s(i2) {
        var o2 = e[i2];
        if (void 0 !== o2) return o2.exports;
        var r2 = e[i2] = { exports: {} };
        return t[i2](r2, r2.exports, s), r2.exports;
      }
      s.d = (i2, t2) => {
        for (var e2 in t2) s.o(t2, e2) && !s.o(i2, e2) && Object.defineProperty(i2, e2, { enumerable: true, get: t2[e2] });
      }, s.o = (i2, t2) => Object.prototype.hasOwnProperty.call(i2, t2), s.r = (i2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(i2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(i2, "__esModule", { value: true });
      };
      var o = {};
      s.r(o), s.d(o, { Minimap: () => h, PositionedMinimap: () => l });
      var r = s(370);
      const n = /* @__PURE__ */ new Set([r.Events.VIEWPORT_CHANGE, r.Events.BLOCK_CHANGE, r.Events.BLOCK_CREATE, r.Events.BLOCK_DELETE, r.Events.BLOCK_DRAG, r.Events.BLOCK_MOVE]);
      class a {
        constructor(i2, t2) {
          this.primaryWorkspace = i2, this.minimapWorkspace = t2, this.svgGroup = null, this.rect = null, this.background = null, this.initialized = false, this.id = String(Math.random()).substring(2), this.onChangeWrapper = this.onChange.bind(this);
        }
        init() {
          this.svgGroup = r.utils.dom.createSvgElement(r.utils.Svg.G, { class: "blockly-focus-region" }, null);
          const i2 = r.utils.dom.createSvgElement(new r.utils.Svg("mask"), { id: "focusRegionMask" + this.id }, this.svgGroup);
          this.background = r.utils.dom.createSvgElement(r.utils.Svg.RECT, { x: 0, y: 0, width: "100%", height: "100%", mask: "url(#focusRegionMask" + this.id + ")" }, this.svgGroup), r.utils.dom.createSvgElement(r.utils.Svg.RECT, { x: 0, y: 0, width: "100%", height: "100%", fill: "white" }, i2), this.rect = r.utils.dom.createSvgElement(r.utils.Svg.RECT, { x: 0, y: 0, rx: 6, ry: 6, fill: "black" }, i2);
          const t2 = this.minimapWorkspace.getParentSvg();
          t2.firstChild ? t2.insertBefore(this.svgGroup, t2.firstChild) : t2.appendChild(this.svgGroup), window.addEventListener("resize", () => {
            this.update();
          }), window.addEventListener("load", () => {
            this.update();
          }), this.onChangeWrapper = this.onChange.bind(this), this.primaryWorkspace.addChangeListener(this.onChangeWrapper), this.update(), this.initialized = true;
        }
        dispose() {
          this.onChangeWrapper && (this.primaryWorkspace.removeChangeListener(this.onChangeWrapper), this.onChangeWrapper = () => null), this.svgGroup && r.utils.dom.removeNode(this.svgGroup), this.svgGroup = null, this.rect = null, this.background = null, this.initialized = false;
        }
        onChange(i2) {
          n.has(i2.type) && this.update();
        }
        update() {
          const i2 = this.primaryWorkspace.getMetricsManager(), t2 = this.minimapWorkspace.getMetricsManager(), e2 = i2.getViewMetrics(true), s2 = i2.getContentMetrics(true), o2 = t2.getContentMetrics(), r2 = t2.getSvgMetrics();
          if (0 === s2.width) return;
          const n2 = o2.width / t2.getContentMetrics(true).width, a2 = e2.width * n2, p2 = e2.height * n2;
          let h2 = (e2.left - s2.left) * n2, l2 = (e2.top - s2.top) * n2;
          if (h2 += (r2.width - o2.width) / 2, l2 += (r2.height - o2.height) / 2, !this.rect) throw new Error("The focus region must be initialized (`init`) before calling `update`");
          this.rect.setAttribute("transform", `translate(${h2},${l2})`), this.rect.setAttribute("width", a2.toString()), this.rect.setAttribute("height", p2.toString());
        }
        isEnabled() {
          return this.initialized;
        }
      }
      r.Css.register("\n.blockly-focus-region {\n  fill: #e6e6e6;\n}\n");
      const p = /* @__PURE__ */ new Set([r.Events.BLOCK_CHANGE, r.Events.BLOCK_CREATE, r.Events.BLOCK_DELETE, r.Events.BLOCK_DRAG, r.Events.BLOCK_MOVE]);
      class h {
        constructor(i2) {
          this.minimapWorkspace = null, this.focusRegion = null, this.onMouseMoveWrapper = null, this.onMouseDownWrapper = null, this.onMouseUpWrapper = null, this.minimapWrapper = null, this.primaryWorkspace = i2;
        }
        init() {
          var i2;
          const t2 = this.primaryWorkspace.getInjectionDiv().parentNode;
          if (!t2) throw new Error("The workspace must be injected into the page before the minimap can be initalized");
          this.minimapWrapper = document.createElement("div"), this.minimapWrapper.id = "minimapWrapper" + this.primaryWorkspace.id, this.minimapWrapper.className = "blockly-minimap", null == t2 || t2.appendChild(this.minimapWrapper), this.minimapWorkspace = r.inject(this.minimapWrapper.id, { rtl: this.primaryWorkspace.RTL, move: { scrollbars: true, drag: false, wheel: false }, zoom: { maxScale: 1 / 0, minScale: 0 }, readOnly: true, theme: this.primaryWorkspace.getTheme(), renderer: this.primaryWorkspace.options.renderer }), null === (i2 = this.minimapWorkspace.scrollbar) || void 0 === i2 || i2.setContainerVisible(false), this.primaryWorkspace.addChangeListener((i3) => {
            this.mirror(i3);
          }), window.addEventListener("resize", () => {
            this.minimapWorkspace && this.minimapWorkspace.zoomToFit();
          });
          const e2 = (i3) => this.onClickDown(i3);
          this.minimapWorkspace.svgGroup_.addEventListener("pointerdown", e2, true), this.onMouseDownWrapper = [[this.minimapWorkspace.svgGroup_, "pointerdown", e2]], this.onMouseUpWrapper = r.browserEvents.bind(t2, "mouseup", this, this.onClickUp), this.focusRegion = new a(this.primaryWorkspace, this.minimapWorkspace), this.enableFocusRegion();
        }
        dispose() {
          this.isFocusEnabled() && this.disableFocusRegion(), this.minimapWorkspace && this.minimapWorkspace.dispose(), r.utils.dom.removeNode(this.minimapWrapper), this.onMouseMoveWrapper && r.browserEvents.unbind(this.onMouseMoveWrapper), this.onMouseDownWrapper && r.browserEvents.unbind(this.onMouseDownWrapper), this.onMouseUpWrapper && r.browserEvents.unbind(this.onMouseUpWrapper);
        }
        mirror(i2) {
          if (!p.has(i2.type)) return;
          if (i2.type === r.Events.BLOCK_CREATE && "shadow" === i2.xml.tagName) return;
          const t2 = i2.toJson();
          this.minimapWorkspace && r.Events.fromJson(t2, this.minimapWorkspace).run(true), r.renderManagement.finishQueuedRenders().then(() => {
            this.minimapWorkspace && this.minimapWorkspace.zoomToFit();
          });
        }
        static minimapToPrimaryCoords(i2, t2, e2, s2) {
          e2 -= (t2.svgWidth - t2.contentWidth) / 2, s2 -= (t2.svgHeight - t2.contentHeight) / 2;
          const o2 = i2.contentWidth / t2.contentWidth;
          e2 *= o2, s2 *= o2;
          let r2 = -i2.contentLeft - e2, n2 = -i2.contentTop - s2;
          return r2 += i2.viewWidth / 2, n2 += i2.viewHeight / 2, [r2, n2];
        }
        primaryScroll(i2) {
          const t2 = this.primaryWorkspace.getMetrics();
          if (this.minimapWorkspace) {
            const e2 = this.minimapWorkspace.getMetrics();
            if (t2 && e2) {
              const [s2, o2] = h.minimapToPrimaryCoords(t2, e2, i2.offsetX, i2.offsetY);
              this.primaryWorkspace.scroll(s2, o2);
            }
          }
        }
        onClickDown(i2) {
          this.minimapWorkspace && (i2.stopImmediatePropagation(), this.onMouseMoveWrapper = r.browserEvents.bind(this.minimapWorkspace.svgGroup_, "mousemove", this, this.onMouseMove), this.primaryScroll(i2));
        }
        onClickUp() {
          this.onMouseMoveWrapper && (r.browserEvents.unbind(this.onMouseMoveWrapper), this.onMouseMoveWrapper = null);
        }
        onMouseMove(i2) {
          this.primaryScroll(i2);
        }
        enableFocusRegion() {
          this.focusRegion && this.focusRegion.init();
        }
        disableFocusRegion() {
          this.focusRegion && this.focusRegion.dispose();
        }
        isFocusEnabled() {
          return !!this.focusRegion && this.focusRegion.isEnabled();
        }
      }
      class l extends h {
        constructor(i2) {
          super(i2), this.id = "minimap", this.margin = 20, this.top = 0, this.left = 0, this.width = 225, this.height = 150;
        }
        init() {
          super.init(), this.primaryWorkspace.getComponentManager().addComponent({ component: this, weight: 3, capabilities: [r.ComponentManager.Capability.POSITIONABLE] }), this.primaryWorkspace.resize();
        }
        getBoundingRectangle() {
          return new r.utils.Rect(this.top, this.top + this.height, this.left, this.left + this.width);
        }
        position(i2, t2) {
          this.setSize(), this.setPosition(i2, t2), this.setAttributes();
        }
        setSize() {
          const i2 = this.primaryWorkspace.getMetrics().viewWidth;
          this.width = Math.max(200, i2 / 5), this.height = 2 * this.width / 3;
        }
        setPosition(i2, t2) {
          const e2 = this.primaryWorkspace, s2 = e2.scrollbar, o2 = s2 && s2.isVisible() && s2.canScrollVertically(), n2 = s2 && s2.isVisible() && s2.canScrollHorizontally();
          i2.toolboxMetrics.position === r.TOOLBOX_AT_LEFT || e2.horizontalLayout && !e2.RTL ? (this.left = i2.absoluteMetrics.left + i2.viewMetrics.width - this.width - this.margin, o2 && !e2.RTL && (this.left -= r.Scrollbar.scrollbarThickness)) : (this.left = this.margin, o2 && e2.RTL && (this.left += r.Scrollbar.scrollbarThickness));
          const a2 = i2.toolboxMetrics.position === r.TOOLBOX_AT_BOTTOM;
          a2 ? (this.top = i2.absoluteMetrics.top + i2.viewMetrics.height - this.height - this.margin, n2 && (this.top -= r.Scrollbar.scrollbarThickness)) : this.top = i2.absoluteMetrics.top + this.margin;
          let p2 = this.getBoundingRectangle();
          for (let i3 = 0; i3 < t2.length; i3++) p2.intersects(t2[i3]) && (this.top = a2 ? t2[i3].top - this.height - this.margin : t2[i3].bottom + this.margin, p2 = this.getBoundingRectangle(), i3 = -1);
        }
        setAttributes() {
          var i2;
          const t2 = null === (i2 = this.minimapWorkspace) || void 0 === i2 ? void 0 : i2.getInjectionDiv();
          if (!t2) return;
          if (null === (null == t2 ? void 0 : t2.parentElement)) return;
          const e2 = t2.parentElement.style;
          e2.zIndex = "2", e2.position = "absolute", e2.width = `${this.width}px`, e2.height = `${this.height}px`, e2.top = `${this.top}px`, e2.left = `${this.left}px`, this.minimapWorkspace && r.svgResize(this.minimapWorkspace);
        }
      }
      return r.Css.register("\n.blockly-minimap {\n  box-shadow: 2px 2px 10px grey;\n}\n"), o;
    })());
  }
});
export default require_dist();
/*! Bundled license information:

@blockly/workspace-minimap/dist/index.js:
  (*! For license information please see index.js.LICENSE.txt *)
*/
//# sourceMappingURL=@blockly_workspace-minimap.js.map
