{
  "version": 3,
  "sources": ["webpack://@blockly/plugin-cross-tab-copy-paste/webpack/universalModuleDefinition", "webpack://@blockly/plugin-cross-tab-copy-paste/external%20umd%20%7B%22root%22:%22Blockly%22,%22commonjs%22:%22blockly/core%22,%22commonjs2%22:%22blockly/core%22,%22amd%22:%22blockly/core%22%7D", "webpack://@blockly/plugin-cross-tab-copy-paste/webpack/bootstrap", "webpack://@blockly/plugin-cross-tab-copy-paste/webpack/runtime/compat%20get%20default%20export", "webpack://@blockly/plugin-cross-tab-copy-paste/webpack/runtime/define%20property%20getters", "webpack://@blockly/plugin-cross-tab-copy-paste/webpack/runtime/hasOwnProperty%20shorthand", "webpack://@blockly/plugin-cross-tab-copy-paste/webpack/runtime/make%20namespace%20object", "webpack://@blockly/plugin-cross-tab-copy-paste/src/index.ts"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__370__) => {\nreturn ", "module.exports = __WEBPACK_EXTERNAL_MODULE__370__;", "// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n", "// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};", "// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};", "__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))", "// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\ntype TypeErrorCallback = () => void;\n\n/**\n * Checks if the copy data represents that for a block.\n *\n * @param obj any ICopyData.\n * @returns if the ICopyData is a BlockCopyData.\n */\nfunction isBlockCopyData(\n  obj: Blockly.ICopyData,\n): obj is Blockly.clipboard.BlockCopyData {\n  return 'typeCounts' in obj;\n}\n\n/**\n * Determine if a focusable node can be copied.\n *\n * This will use the isCopyable method if the node implements it, otherwise\n * it will fall back to checking if the node is deletable and draggable not\n * considering the workspace's edit state.\n *\n * n.b. copied (with minor changes) from blockly/core/shortcut_items.\n *\n * @param focused The focused object.\n */\nfunction isCopyable(focused: Blockly.IFocusableNode): boolean {\n  if (\n    !Blockly.isCopyable(focused) ||\n    !Blockly.isDeletable(focused) ||\n    !Blockly.isDraggable(focused)\n  )\n    return false;\n  // The cast is necessary while the minimum version of Blockly required is < 12.2.0\n  // because that version is when `isCopyable` was introduced on the `ICopyable` interface.\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  if ((focused as any).isCopyable) {\n    return (focused as any).isCopyable();\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n  } else if (\n    focused instanceof Blockly.BlockSvg ||\n    focused instanceof Blockly.comments.RenderedWorkspaceComment\n  ) {\n    return focused.isOwnDeletable() && focused.isOwnMovable();\n  }\n  // This isn't a class Blockly knows about, so fall back to the stricter\n  // checks for deletable and movable.\n  return focused.isDeletable() && focused.isMovable();\n}\n\n/**\n * Determine if a focusable node can be cut.\n *\n * This will check if the node can be both copied and deleted in its current\n * workspace.\n *\n * n.b. copied from blockly/core/shortcut_items.\n *\n * @param focused The focused object.\n */\nfunction isCuttable(focused: Blockly.IFocusableNode): boolean {\n  return (\n    isCopyable(focused) && Blockly.isDeletable(focused) && focused.isDeletable()\n  );\n}\n\n/**\n * Return value for a context menu item's precondition.\n */\nenum ContextMenuState {\n  ENABLED = 'enabled',\n  DISABLED = 'disabled',\n  HIDDEN = 'hidden',\n}\n\n/**\n * A Blockly plugin that adds context menu items and keyboard shortcuts\n * to allow users to copy and paste copyable objects between tabs.\n */\nexport class CrossTabCopyPaste {\n  /** Key in which store copy data in the browser's local storage. */\n  localStorageKey = 'blocklyStash';\n\n  /**\n   * Initializes the cross tab copy paste plugin. If no options are selected\n   * then both context menu items and keyboard shortcuts are added.\n   *\n   * @param options\n   * @param options.shortcut Register cut (ctr + x), copy (ctr + c) and paste (ctr + v)\n   * in the shortcut.\n   * @param options.contextMenu Register copy and paste in the context menu.\n   * @param typeErrorCallback callback function to handle type errors\n   * @param localStorageKey custom key for local storage\n   */\n  init(\n    {contextMenu = true, shortcut = true} = {\n      contextMenu: true,\n      shortcut: true,\n    },\n    typeErrorCallback?: TypeErrorCallback,\n    localStorageKey?: string,\n  ) {\n    if (localStorageKey) this.localStorageKey = localStorageKey;\n    if (contextMenu) {\n      // Register the menus\n      this.blockCopyToStorageContextMenu();\n      this.blockPasteFromStorageContextMenu(typeErrorCallback);\n    }\n\n    if (shortcut) {\n      // Unregister the default KeyboardShortcuts\n      Blockly.ShortcutRegistry.registry.unregister(\n        Blockly.ShortcutItems.names.COPY,\n      );\n      Blockly.ShortcutRegistry.registry.unregister(\n        Blockly.ShortcutItems.names.CUT,\n      );\n      Blockly.ShortcutRegistry.registry.unregister(\n        Blockly.ShortcutItems.names.PASTE,\n      );\n      // Register the KeyboardShortcuts\n      this.blockCopyToStorageShortcut();\n      this.blockCutToStorageShortcut();\n      this.blockPasteFromStorageShortcut(typeErrorCallback);\n    }\n  }\n\n  /**\n   * Parses copy data from JSON in local storage, if it exists.\n   *\n   * @returns copy data parsed from local storage, or undefined\n   */\n  getCopyData(): Blockly.ICopyData | undefined {\n    const stored = localStorage.getItem(this.localStorageKey);\n    if (!stored) return undefined;\n    return JSON.parse(stored);\n  }\n\n  /**\n   * Copy precondition called by both keyboard shortcut and context menu item.\n   * Allows copying out of the flyout, as long as they could be pasted\n   * into the main workspace.\n   *\n   * @param scope scope for copy action.\n   * @param workspace explicit workspace for keyboard shortcuts,\n   * undefined to get the workspace from the focused node.\n   * @returns whether the option should be shown/hidden/disabled.\n   */\n  copyPrecondition(\n    scope: Blockly.ContextMenuRegistry.Scope,\n    workspace?: Blockly.Workspace,\n  ): ContextMenuState {\n    const focused = scope.focusedNode;\n    if (!focused) return ContextMenuState.HIDDEN;\n    if (!Blockly.isCopyable(focused)) return ContextMenuState.HIDDEN;\n\n    if (!workspace) workspace = focused.workspace;\n    if (!(workspace instanceof Blockly.WorkspaceSvg))\n      return ContextMenuState.HIDDEN;\n    const targetWorkspace = workspace.isFlyout\n      ? workspace.targetWorkspace\n      : workspace;\n    if (\n      !!focused &&\n      !!targetWorkspace &&\n      !targetWorkspace.isDragging() &&\n      !Blockly.getFocusManager().ephemeralFocusTaken() &&\n      isCopyable(focused)\n    )\n      return ContextMenuState.ENABLED;\n    return ContextMenuState.DISABLED;\n  }\n\n  /**\n   * Copy callback called by both keyboard shortcut and context menu item.\n   * Copies the copy data to local storage.\n   *\n   * @param scope scope for copy action.\n   * @param workspace workspace where shortcut or context menu was activated.\n   * @returns true if copy happened, false otherwise.\n   */\n  copyCallback(\n    scope: Blockly.ContextMenuRegistry.Scope,\n    workspace: Blockly.Workspace,\n  ): boolean {\n    const focused = scope.focusedNode;\n    if (!focused || !Blockly.isCopyable(focused) || !isCopyable(focused))\n      return false;\n\n    if (!(workspace instanceof Blockly.WorkspaceSvg)) return false;\n\n    const targetWorkspace = workspace.isFlyout\n      ? workspace.targetWorkspace\n      : workspace;\n    if (!targetWorkspace) return false;\n\n    if (!focused.workspace.isFlyout) {\n      targetWorkspace.hideChaff();\n    }\n    const copyData = focused.toCopyData();\n    if (!copyData) return false;\n    localStorage.setItem(this.localStorageKey, JSON.stringify(copyData));\n    return true;\n  }\n\n  /**\n   * Paste precondition called by both keyboard shortcut and context menu item.\n   *\n   * @param workspace workspace to paste in. should not be a flyout workspace.\n   * @returns true if paste happened, false otherwise.\n   */\n  pastePrecondition(workspace: Blockly.WorkspaceSvg): ContextMenuState {\n    const copyData = this.getCopyData();\n    if (!copyData) return ContextMenuState.DISABLED;\n    // If this is a block, make sure there's room for that type of block\n    if (\n      isBlockCopyData(copyData) &&\n      !workspace?.isCapacityAvailable(copyData.typeCounts)\n    )\n      return ContextMenuState.DISABLED;\n\n    if (\n      !!workspace &&\n      !workspace.isReadOnly() &&\n      !workspace.isDragging() &&\n      !Blockly.getFocusManager().ephemeralFocusTaken()\n    )\n      return ContextMenuState.ENABLED;\n    return ContextMenuState.DISABLED;\n  }\n\n  /**\n   * v12.0.0 of Blockly included the keyboard shortcut in Msg string, but\n   * it was removed in v12.2.0. This function can be removed when this plugin's\n   * minimum version of Blockly is >=12.2.0.\n   *\n   * @param labelText Blockly.Msg for the shortcut\n   * @returns trimmed label for the context menu item.\n   */\n  getContextMenuText(labelText: string): string {\n    // TODO: Once core is updated to remove the shortcut placeholders from the\n    // keyboard shortcut messages, remove this.\n    if (labelText.indexOf(')') === labelText.length - 1) {\n      labelText = labelText.split(' (')[0];\n    }\n    return labelText;\n  }\n\n  /**\n   * Adds a copy command to the context menu for copyable items.\n   */\n  blockCopyToStorageContextMenu() {\n    const copyToStorageOption: Blockly.ContextMenuRegistry.RegistryItem = {\n      displayText: () => {\n        if (Blockly.Msg['CROSS_TAB_COPY']) {\n          return Blockly.Msg['CROSS_TAB_COPY'];\n        }\n        return this.getContextMenuText(Blockly.Msg['COPY_SHORTCUT']);\n      },\n      preconditionFn: (scope: Blockly.ContextMenuRegistry.Scope) => {\n        return this.copyPrecondition(scope);\n      },\n      callback: (scope: Blockly.ContextMenuRegistry.Scope) => {\n        const focused = scope.focusedNode;\n        // Check Blockly.isCopyable to make sure focused.workspace exists\n        if (!focused || !Blockly.isCopyable(focused)) return false;\n\n        const workspace = focused.workspace;\n        return this.copyCallback(scope, workspace);\n      },\n      id: 'blockCopyToStorage',\n      weight: 0,\n    };\n    Blockly.ContextMenuRegistry.registry.register(copyToStorageOption);\n  }\n\n  /**\n   * Adds a paste command to the context menu for copyable items.\n   *\n   * @param typeErrorCallback callback function to handle type errors\n   */\n  blockPasteFromStorageContextMenu(typeErrorCallback?: TypeErrorCallback) {\n    const pasteFromStorageOption: Blockly.ContextMenuRegistry.RegistryItem = {\n      displayText: () => {\n        if (Blockly.Msg['CROSS_TAB_PASTE']) {\n          return Blockly.Msg['CROSS_TAB_PASTE'];\n        }\n        return this.getContextMenuText(Blockly.Msg['PASTE_SHORTCUT']);\n      },\n      preconditionFn: (scope) => {\n        // Only show paste option if menu was opened on a non-flyout workspace\n        if (\n          !(scope.focusedNode instanceof Blockly.WorkspaceSvg) ||\n          scope.focusedNode.isFlyout\n        )\n          return ContextMenuState.HIDDEN;\n        const workspace = scope.focusedNode;\n        return this.pastePrecondition(workspace);\n      },\n      callback: (scope, menuOpenEvent, menuSelectEvent, location) => {\n        const copyData = this.getCopyData();\n        if (!copyData) return false;\n        const workspace = scope.focusedNode;\n        // Paste option only available if menu was opened on a workspace\n        if (!(workspace instanceof Blockly.WorkspaceSvg)) return false;\n\n        const pasteLocation = Blockly.utils.svgMath.screenToWsCoordinates(\n          workspace,\n          location,\n        );\n        try {\n          return !!Blockly.clipboard.paste(copyData, workspace, pasteLocation);\n        } catch (e) {\n          if (e instanceof TypeError && typeErrorCallback) {\n            typeErrorCallback();\n          } else {\n            throw e;\n          }\n        }\n      },\n      id: 'blockPasteFromStorage',\n      weight: 0,\n    };\n    Blockly.ContextMenuRegistry.registry.register(pasteFromStorageOption);\n  }\n\n  /**\n   * Adds a keyboard shortcut that will store copy information for a copyable\n   * in localStorage.\n   */\n  blockCopyToStorageShortcut() {\n    const ctrlC = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.C,\n      [Blockly.utils.KeyCodes.CTRL],\n    );\n    const metaC = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.C,\n      [Blockly.utils.KeyCodes.META],\n    );\n    const copyShortcut: Blockly.ShortcutRegistry.KeyboardShortcut = {\n      name: Blockly.ShortcutItems.names.COPY,\n      keyCodes: [ctrlC, metaC],\n      preconditionFn: (workspace, scope) => {\n        const status = this.copyPrecondition(scope, workspace);\n        return status === ContextMenuState.ENABLED;\n      },\n      callback: (workspace, e, shortcut, scope) => {\n        // Prevent the default copy behavior,\n        // which may beep or otherwise indicate\n        // an error due to the lack of a selection.\n        e.preventDefault();\n        return this.copyCallback(scope, workspace);\n      },\n    };\n    Blockly.ShortcutRegistry.registry.register(copyShortcut);\n  }\n\n  /**\n   * Adds a keyboard shortcut that will store copy information for copyable\n   * items in local storage and delete the item.\n   */\n  blockCutToStorageShortcut() {\n    const ctrlX = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.X,\n      [Blockly.utils.KeyCodes.CTRL],\n    );\n    const metaX = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.X,\n      [Blockly.utils.KeyCodes.META],\n    );\n\n    const cutShortcut: Blockly.ShortcutRegistry.KeyboardShortcut = {\n      name: Blockly.ShortcutItems.names.CUT,\n      keyCodes: [ctrlX, metaX],\n      preconditionFn: (workspace, scope) => {\n        const focused = scope.focusedNode;\n        return (\n          !!focused &&\n          !workspace.isReadOnly() &&\n          !workspace.isDragging() &&\n          !Blockly.getFocusManager().ephemeralFocusTaken() &&\n          isCuttable(focused)\n        );\n      },\n      callback: (workspace, e, shortcut, scope) => {\n        // Prevent the default cut behavior,\n        // which may beep or otherwise indicate\n        // an error due to the lack of a selection.\n        e.preventDefault();\n\n        const focused = scope.focusedNode;\n        if (!focused || !isCuttable(focused) || !Blockly.isCopyable(focused)) {\n          return false;\n        }\n        const copyData = focused.toCopyData();\n        if (!copyData) return false;\n\n        if (focused instanceof Blockly.BlockSvg) {\n          focused.checkAndDelete();\n        } else if (Blockly.isDeletable(focused)) {\n          // Manually handle event grouping since only blocks handle that\n          // automatically.\n          const oldGroup = Blockly.Events.getGroup();\n          Blockly.Events.setGroup(true);\n          focused.dispose();\n          Blockly.Events.setGroup(oldGroup);\n        }\n\n        localStorage.setItem(this.localStorageKey, JSON.stringify(copyData));\n        return true;\n      },\n    };\n    Blockly.ShortcutRegistry.registry.register(cutShortcut);\n  }\n\n  /**\n   * Adds a keyboard shortcut that will paste the copyable stored in localStorage.\n   *\n   * @param typeErrorCallback\n   * callback function to handle type errors\n   */\n  blockPasteFromStorageShortcut(typeErrorCallback?: TypeErrorCallback) {\n    const ctrlV = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.V,\n      [Blockly.utils.KeyCodes.CTRL],\n    );\n    const metaV = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.V,\n      [Blockly.utils.KeyCodes.META],\n    );\n\n    const pasteShortcut: Blockly.ShortcutRegistry.KeyboardShortcut = {\n      name: Blockly.ShortcutItems.names.PASTE,\n      keyCodes: [ctrlV, metaV],\n      preconditionFn: (workspace) => {\n        const targetWorkspace = workspace.isFlyout\n          ? workspace.targetWorkspace\n          : workspace;\n\n        if (!targetWorkspace) return false;\n        const status = this.pastePrecondition(targetWorkspace);\n        return status === ContextMenuState.ENABLED;\n      },\n      callback: (workspace, e) => {\n        // Prevent the default copy behavior,\n        // which may beep or otherwise indicate\n        // an error due to the lack of a selection.\n        e.preventDefault();\n        const copyData = this.getCopyData();\n        if (!copyData) return false;\n\n        // If paste shortcut is called while flyout is open, paste in the\n        // main workspace instead.\n        const targetWorkspace = workspace.isFlyout\n          ? workspace.targetWorkspace\n          : workspace;\n        if (!targetWorkspace) return false;\n        try {\n          if (e instanceof PointerEvent) {\n            // The event that triggers a shortcut would conventionally be a KeyboardEvent.\n            // However, it may be a PointerEvent if a context menu item was used as a\n            // wrapper for this callback, in which case the new block(s) should be pasted\n            // at the mouse coordinates where the menu was opened, and this PointerEvent\n            // is where the menu was opened.\n            const mouseCoords = Blockly.utils.svgMath.screenToWsCoordinates(\n              targetWorkspace,\n              new Blockly.utils.Coordinate(e.clientX, e.clientY),\n            );\n            return !!Blockly.clipboard.paste(\n              copyData,\n              targetWorkspace,\n              mouseCoords,\n            );\n          }\n          // If we don't have location data about the original copyable, let the\n          // paster determine position.\n          return !!Blockly.clipboard.paste(copyData, targetWorkspace);\n        } catch (e) {\n          if (e instanceof TypeError && typeErrorCallback) {\n            typeErrorCallback();\n          } else {\n            throw e;\n          }\n        }\n        return true;\n      },\n    };\n    Blockly.ShortcutRegistry.registry.register(pasteShortcut);\n  }\n}\n"],
  "mappings": "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",
  "names": ["root", "factory", "exports", "module", "require", "define", "amd", "a", "i", "this", "__WEBPACK_EXTERNAL_MODULE__370__", "__webpack_module_cache__", "__webpack_require__", "moduleId", "cachedModule", "__webpack_modules__", "n", "getter", "__esModule", "e", "d", "definition", "key", "o", "Object", "defineProperty", "enumerable", "get", "obj", "prop", "prototype", "hasOwnProperty", "call", "r", "Symbol", "toStringTag", "value", "ContextMenuState", "isCopyable", "focused", "RenderedWorkspaceComment", "isOwnDeletable", "isOwnMovable", "isDeletable", "isMovable", "isCuttable", "CrossTabCopyPaste", "localStorageKey", "init", "contextMenu", "shortcut", "typeErrorCallback", "blockCopyToStorageContextMenu", "blockPasteFromStorageContextMenu", "registry", "unregister", "names", "COPY", "CUT", "PASTE", "blockCopyToStorageShortcut", "blockCutToStorageShortcut", "blockPasteFromStorageShortcut", "getCopyData", "stored", "localStorage", "getItem", "JSON", "parse", "scope", "workspace", "focusedNode", "HIDDEN", "targetWorkspace", "isFlyout", "isDragging", "ephemeralFocusTaken", "ENABLED", "DISABLED", "hideChaff", "copyData", "toCopyData", "setItem", "stringify", "isCapacityAvailable", "typeCounts", "isReadOnly", "labelText", "indexOf", "length", "split", "copyToStorageOption", "displayText", "getContextMenuText", "preconditionFn", "copyPrecondition", "callback", "copyCallback", "id", "weight", "register", "pasteFromStorageOption", "pastePrecondition", "menuOpenEvent", "menuSelectEvent", "location", "pasteLocation", "svgMath", "screenToWsCoordinates", "paste", "TypeError", "ctrlC", "createSerializedKey", "KeyCodes", "C", "CTRL", "metaC", "META", "copyShortcut", "name", "keyCodes", "preventDefault", "ctrlX", "X", "metaX", "cutShortcut", "checkAndDelete", "oldGroup", "getGroup", "setGroup", "dispose", "ctrlV", "V", "metaV", "pasteShortcut", "PointerEvent", "mouseCoords", "Coordinate", "clientX", "clientY"]
}
