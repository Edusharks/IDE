{
  "version": 3,
  "sources": ["webpack://@blockly/workspace-minimap/webpack/universalModuleDefinition", "webpack://@blockly/workspace-minimap/external%20umd%20%7B%22root%22:%22Blockly%22,%22commonjs%22:%22blockly/core%22,%22commonjs2%22:%22blockly/core%22,%22amd%22:%22blockly/core%22%7D", "webpack://@blockly/workspace-minimap/webpack/bootstrap", "webpack://@blockly/workspace-minimap/webpack/runtime/define%20property%20getters", "webpack://@blockly/workspace-minimap/webpack/runtime/hasOwnProperty%20shorthand", "webpack://@blockly/workspace-minimap/webpack/runtime/make%20namespace%20object", "webpack://@blockly/workspace-minimap/src/focus_region.ts", "webpack://@blockly/workspace-minimap/src/minimap.ts", "webpack://@blockly/workspace-minimap/src/positioned_minimap.ts"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__370__) => {\nreturn ", "module.exports = __WEBPACK_EXTERNAL_MODULE__370__;", "// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n", "// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};", "__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))", "// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A class that highlights the user's\n * viewport on the minimap.\n * @author cesarades@google.com (Cesar Ades)\n */\n\nimport * as Blockly from 'blockly/core';\n\nconst blockEvents = new Set<string>([\n  Blockly.Events.VIEWPORT_CHANGE,\n  Blockly.Events.BLOCK_CHANGE,\n  Blockly.Events.BLOCK_CREATE,\n  Blockly.Events.BLOCK_DELETE,\n  Blockly.Events.BLOCK_DRAG,\n  Blockly.Events.BLOCK_MOVE,\n]);\n\nconst borderRadius = 6;\n\n/**\n * A class that highlights the user's viewport on the minimap.\n */\nexport class FocusRegion {\n  private onChangeWrapper: (e: Blockly.Events.Abstract) => void;\n  private svgGroup: SVGElement | null = null;\n  private rect: SVGElement | null = null;\n  private background: SVGElement | null = null;\n  private id: string;\n  private initialized = false;\n\n  /**\n   * Constructor for the focus region.\n   *\n   * @param primaryWorkspace The primary workspaceSvg.\n   * @param minimapWorkspace The minimap workspaceSvg.\n   */\n  constructor(\n    private primaryWorkspace: Blockly.WorkspaceSvg,\n    private minimapWorkspace: Blockly.WorkspaceSvg,\n  ) {\n    this.id = String(Math.random()).substring(2);\n    this.onChangeWrapper = this.onChange.bind(this);\n  }\n\n  /**\n   * Initializes focus region.\n   */\n  init() {\n    // Make the svg group element.\n    this.svgGroup = Blockly.utils.dom.createSvgElement(\n      Blockly.utils.Svg.G,\n      {class: 'blockly-focus-region'},\n      null,\n    );\n\n    // Make the mask under the svg group.\n    const mask = Blockly.utils.dom.createSvgElement(\n      new Blockly.utils.Svg('mask'),\n      {id: 'focusRegionMask' + this.id},\n      this.svgGroup,\n    );\n\n    // Make the background under the svg group.\n    this.background = Blockly.utils.dom.createSvgElement(\n      Blockly.utils.Svg.RECT,\n      {\n        x: 0,\n        y: 0,\n        width: '100%',\n        height: '100%',\n        mask: 'url(#focusRegionMask' + this.id + ')',\n      },\n      this.svgGroup,\n    );\n\n    // Make the white layer under the svg mask.\n    Blockly.utils.dom.createSvgElement(\n      Blockly.utils.Svg.RECT,\n      {\n        x: 0,\n        y: 0,\n        width: '100%',\n        height: '100%',\n        fill: 'white',\n      },\n      mask,\n    );\n\n    // Make the black layer under the mask.\n    this.rect = Blockly.utils.dom.createSvgElement(\n      Blockly.utils.Svg.RECT,\n      {\n        x: 0,\n        y: 0,\n        rx: borderRadius,\n        ry: borderRadius,\n        fill: 'black',\n      },\n      mask,\n    );\n\n    // Add the svg group to the minimap.\n    const parentSvg = this.minimapWorkspace.getParentSvg();\n    if (parentSvg.firstChild) {\n      parentSvg.insertBefore(this.svgGroup, parentSvg.firstChild);\n    } else {\n      parentSvg.appendChild(this.svgGroup);\n    }\n\n    window.addEventListener('resize', () => void this.update());\n    window.addEventListener('load', () => void this.update());\n    this.onChangeWrapper = this.onChange.bind(this);\n    this.primaryWorkspace.addChangeListener(this.onChangeWrapper);\n\n    this.update();\n    this.initialized = true;\n  }\n\n  /**\n   * Disposes of the focus region.\n   * Unlinks from all DOM elements and remove all event listeners\n   * to prevent memory leaks.\n   */\n  dispose() {\n    if (this.onChangeWrapper) {\n      this.primaryWorkspace.removeChangeListener(this.onChangeWrapper);\n      this.onChangeWrapper = () => null;\n    }\n    if (this.svgGroup) {\n      Blockly.utils.dom.removeNode(this.svgGroup);\n    }\n    this.svgGroup = null;\n    this.rect = null;\n    this.background = null;\n    this.initialized = false;\n  }\n\n  /**\n   * Handles events triggered on the primary workspace.\n   *\n   * @param event The event.\n   */\n  private onChange(event: Blockly.Events.Abstract): void {\n    if (blockEvents.has(event.type)) {\n      this.update();\n    }\n  }\n\n  /**\n   * Positions and sizes the highlight on the minimap\n   * based on the primary workspace.\n   */\n  private update(): void {\n    // Get the metrics.\n    const primaryMetrics = this.primaryWorkspace.getMetricsManager();\n    const minimapMetrics = this.minimapWorkspace.getMetricsManager();\n\n    const primaryView = primaryMetrics.getViewMetrics(true);\n    const primaryContent = primaryMetrics.getContentMetrics(true);\n    const minimapContent = minimapMetrics.getContentMetrics();\n    const minimapSvg = minimapMetrics.getSvgMetrics();\n\n    // Return if there is no content.\n    if (primaryContent.width === 0) {\n      return;\n    }\n\n    // Get the workscape to pixel scale on the minimap.\n    const scale =\n      minimapContent.width / minimapMetrics.getContentMetrics(true).width;\n\n    // Get the viewport size on a minimap scale.\n    const width = primaryView.width * scale;\n    const height = primaryView.height * scale;\n\n    // Get the viewport position in relation to the content.\n    let left = (primaryView.left - primaryContent.left) * scale;\n    let top = (primaryView.top - primaryContent.top) * scale;\n\n    // Account for the padding outside the content on the minimap.\n    left += (minimapSvg.width - minimapContent.width) / 2;\n    top += (minimapSvg.height - minimapContent.height) / 2;\n\n    // Set the svg attributes.\n    if (!this.rect) {\n      throw new Error(\n        'The focus region must be initialized (`init`) before calling `update`',\n      );\n    } else {\n      this.rect.setAttribute('transform', `translate(${left},${top})`);\n      this.rect.setAttribute('width', width.toString());\n      this.rect.setAttribute('height', height.toString());\n    }\n  }\n\n  /**\n   * Returns whether focus region is initialized or not.\n   *\n   * @returns True if focus region is initialized else false.\n   */\n  isEnabled(): boolean {\n    return this.initialized;\n  }\n}\n\nBlockly.Css.register(`\n.blockly-focus-region {\n  fill: #e6e6e6;\n}\n`);\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A minimap is a miniature version of your blocks that\n * appears on top of your main workspace. This gives you an overview\n * of what your code looks like, and how it is organized.\n * @author cesarades@google.com (Cesar Ades)\n */\n\nimport * as Blockly from 'blockly/core';\nimport {FocusRegion} from './focus_region';\n\n// Events that should be send over to the minimap from the primary workspace\nconst blockEvents = new Set<string>([\n  Blockly.Events.BLOCK_CHANGE,\n  Blockly.Events.BLOCK_CREATE,\n  Blockly.Events.BLOCK_DELETE,\n  Blockly.Events.BLOCK_DRAG,\n  Blockly.Events.BLOCK_MOVE,\n]);\n\n/**\n * A minimap is a miniature version of your blocks that appears on\n * top of your main workspace. This gives you an overview of what\n * your code looks like, and how it is organized.\n */\nexport class Minimap {\n  protected primaryWorkspace: Blockly.WorkspaceSvg;\n  protected minimapWorkspace: Blockly.WorkspaceSvg | null = null;\n  protected focusRegion: FocusRegion | null = null;\n  protected onMouseMoveWrapper: Blockly.browserEvents.Data | null = null;\n  protected onMouseDownWrapper: Blockly.browserEvents.Data | null = null;\n  protected onMouseUpWrapper: Blockly.browserEvents.Data | null = null;\n  protected minimapWrapper: HTMLDivElement | null = null;\n\n  /**\n   * Constructor for a minimap.\n   *\n   * @param workspace The workspace to mirror.\n   */\n  constructor(workspace: Blockly.WorkspaceSvg) {\n    this.primaryWorkspace = workspace;\n  }\n\n  /**\n   * Initialize.\n   */\n  init(): void {\n    const primaryInjectParentDiv =\n      this.primaryWorkspace.getInjectionDiv().parentNode;\n\n    if (!primaryInjectParentDiv) {\n      throw new Error(\n        'The workspace must be injected into the page before the minimap can be initalized',\n      );\n    }\n\n    // Create a wrapper div for the minimap injection.\n    this.minimapWrapper = document.createElement('div');\n    this.minimapWrapper.id = 'minimapWrapper' + this.primaryWorkspace.id;\n    this.minimapWrapper.className = 'blockly-minimap';\n\n    // Make the wrapper a sibling to the primary injection div.\n    primaryInjectParentDiv?.appendChild(this.minimapWrapper);\n\n    // Inject the minimap workspace.\n    this.minimapWorkspace = Blockly.inject(this.minimapWrapper.id, {\n      // Inherit the layout of the primary workspace.\n      rtl: this.primaryWorkspace.RTL,\n      // Include the scrollbars so that internal scrolling is enabled and\n      // remove direct interaction with the minimap workspace.\n      move: {\n        scrollbars: true,\n        drag: false,\n        wheel: false,\n      },\n      // Remove the scale bounds of the minimap so that it can\n      // correctly zoomToFit.\n      zoom: {\n        maxScale: Infinity,\n        minScale: 0,\n      },\n      readOnly: true,\n      theme: this.primaryWorkspace.getTheme(),\n      renderer: this.primaryWorkspace.options.renderer,\n    });\n\n    this.minimapWorkspace.scrollbar?.setContainerVisible(false);\n    this.primaryWorkspace.addChangeListener((e) => void this.mirror(e));\n    window.addEventListener('resize', () => {\n      if (this.minimapWorkspace) {\n        this.minimapWorkspace.zoomToFit();\n      }\n    });\n\n    // The mousedown handler needs to take precedent over other mouse handlers\n    // in the workspace, such as the handler that opens comments, which means it\n    // needs to be attached in the capture phase. Blockly's built-in event\n    // binding does not let us use the capture phase so we reimplement it here.\n    const mouseDownFunc = (event: Event) =>\n      this.onClickDown(event as PointerEvent);\n    this.minimapWorkspace.svgGroup_.addEventListener(\n      'pointerdown',\n      mouseDownFunc,\n      /* usecapture */ true,\n    );\n    this.onMouseDownWrapper = [\n      [this.minimapWorkspace.svgGroup_, 'pointerdown', mouseDownFunc],\n    ];\n\n    // The mouseup binds to the parent container div instead of the minimap\n    // because if a drag begins on the minimap and ends outside of it the\n    // mousemove should still unbind.\n    this.onMouseUpWrapper = Blockly.browserEvents.bind(\n      primaryInjectParentDiv,\n      'mouseup',\n      this,\n      this.onClickUp,\n    );\n\n    // Initializes the focus region.\n    this.focusRegion = new FocusRegion(\n      this.primaryWorkspace,\n      this.minimapWorkspace,\n    );\n    this.enableFocusRegion();\n  }\n\n  /**\n   * Disposes the minimap.\n   * Unlinks from all DOM elements and remove all event listeners\n   * to prevent memory leaks.\n   */\n  dispose() {\n    if (this.isFocusEnabled()) {\n      this.disableFocusRegion();\n    }\n    if (this.minimapWorkspace) {\n      this.minimapWorkspace.dispose();\n    }\n    Blockly.utils.dom.removeNode(this.minimapWrapper);\n    if (this.onMouseMoveWrapper) {\n      Blockly.browserEvents.unbind(this.onMouseMoveWrapper);\n    }\n    if (this.onMouseDownWrapper) {\n      Blockly.browserEvents.unbind(this.onMouseDownWrapper);\n    }\n    if (this.onMouseUpWrapper) {\n      Blockly.browserEvents.unbind(this.onMouseUpWrapper);\n    }\n  }\n\n  /**\n   * Creates the mirroring between workspaces. Passes on all desired events\n   * to the minimap from the primary workspace.\n   *\n   * @param event The primary workspace event.\n   */\n  private mirror(event: Blockly.Events.Abstract): void {\n    if (!blockEvents.has(event.type)) {\n      return; // Filter out events.\n    }\n    if (\n      event.type === Blockly.Events.BLOCK_CREATE &&\n      /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n      (event as any).xml.tagName === 'shadow'\n    ) {\n      return; // Filter out shadow blocks.\n    }\n    // Run the event in the minimap.\n    const json = event.toJson();\n    if (this.minimapWorkspace) {\n      const duplicate = Blockly.Events.fromJson(json, this.minimapWorkspace);\n      duplicate.run(true);\n    }\n\n    // Resize and center the minimap.\n    // We need to wait for the event to finish rendering to do the zoom.\n    Blockly.renderManagement.finishQueuedRenders().then(() => {\n      if (this.minimapWorkspace) {\n        this.minimapWorkspace.zoomToFit();\n      }\n    });\n  }\n\n  /**\n   * Converts the coorindates from a mouse event on the minimap\n   * into scroll coordinates for the primary viewport.\n   *\n   * @param primaryMetrics The metrics from the primary workspace.\n   * @param minimapMetrics The metrics from the minimap workspace.\n   * @param offsetX The x offset of the mouse event.\n   * @param offsetY The y offset of the mouse event.\n   * @returns (x, y) primary workspace scroll coordinates.\n   */\n  static minimapToPrimaryCoords(\n    primaryMetrics: Blockly.utils.Metrics,\n    minimapMetrics: Blockly.utils.Metrics,\n    offsetX: number,\n    offsetY: number,\n  ): [number, number] {\n    // Gets the coordinate relative to the top left of the minimap content.\n    offsetX -= (minimapMetrics.svgWidth - minimapMetrics.contentWidth) / 2;\n    offsetY -= (minimapMetrics.svgHeight - minimapMetrics.contentHeight) / 2;\n\n    // Scales the coordinate to the primary workspace.\n    const scale = primaryMetrics.contentWidth / minimapMetrics.contentWidth;\n    offsetX *= scale;\n    offsetY *= scale;\n\n    // Gets the coordinate relative to the top left of the primary content.\n    let x = -primaryMetrics.contentLeft - offsetX;\n    let y = -primaryMetrics.contentTop - offsetY;\n\n    // Centers the coordinate in the primary viewport.\n    x += primaryMetrics.viewWidth / 2;\n    y += primaryMetrics.viewHeight / 2;\n\n    return [x, y];\n  }\n\n  /**\n   * Scrolls the primary workspace viewport based on a minimap event.\n   *\n   * @param event The minimap browser event.\n   */\n  private primaryScroll(event: PointerEvent): void {\n    const primaryMetrics = this.primaryWorkspace.getMetrics();\n    if (this.minimapWorkspace) {\n      const minimapMetrics = this.minimapWorkspace.getMetrics();\n      if (primaryMetrics && minimapMetrics) {\n        const [x, y] = Minimap.minimapToPrimaryCoords(\n          primaryMetrics,\n          minimapMetrics,\n          event.offsetX,\n          event.offsetY,\n        );\n        this.primaryWorkspace.scroll(x, y);\n      }\n    }\n  }\n\n  /**\n   * Updates the primary workspace viewport based on a click in the minimap.\n   *\n   * @param event The minimap browser event.\n   */\n  private onClickDown(event: PointerEvent): void {\n    if (this.minimapWorkspace) {\n      // Stop any other click event handlers in the workspace from handling\n      // this event.\n      event.stopImmediatePropagation();\n\n      this.onMouseMoveWrapper = Blockly.browserEvents.bind(\n        this.minimapWorkspace.svgGroup_,\n        'mousemove',\n        this,\n        this.onMouseMove,\n      );\n      this.primaryScroll(event);\n    }\n  }\n\n  /**\n   * Unbinds the minimap mousemove when the mouse is not clicked.\n   */\n  private onClickUp(): void {\n    if (this.onMouseMoveWrapper) {\n      Blockly.browserEvents.unbind(this.onMouseMoveWrapper);\n      this.onMouseMoveWrapper = null;\n    }\n  }\n\n  /**\n   * Updates the primary workspace viewport based on a drag in the minimap.\n   *\n   * @param event The minimap browser event.\n   */\n  private onMouseMove(event: PointerEvent): void {\n    this.primaryScroll(event);\n  }\n\n  /**\n   * Enables the focus region; A highlight of the viewport in the minimap.\n   */\n  enableFocusRegion(): void {\n    if (this.focusRegion) {\n      this.focusRegion.init();\n    }\n  }\n\n  /**\n   * Disables the focus region.\n   */\n  disableFocusRegion(): void {\n    if (this.focusRegion) {\n      this.focusRegion.dispose();\n    }\n  }\n\n  /**\n   * Returns whether the focus region is enabled.\n   *\n   * @returns True if the focus region is enabled.\n   */\n  isFocusEnabled(): boolean {\n    if (this.focusRegion) {\n      return this.focusRegion.isEnabled();\n    }\n    return false;\n  }\n}\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A positionable version of the minimap.\n * @author cesarades@google.com (Cesar Ades)\n */\n\nimport * as Blockly from 'blockly/core';\nimport {Minimap} from './minimap';\n\nconst minWidth = 200;\n\n/**\n * A positionable version of minimap that implements IPositionable.\n */\nexport class PositionedMinimap\n  extends Minimap\n  implements Blockly.IPositionable\n{\n  protected margin: number;\n  protected top: number;\n  protected left: number;\n  protected width: number;\n  protected height: number;\n  id: string;\n\n  /**\n   * Constructor for a positionable minimap.\n   *\n   * @param workspace The workspace to mirror.\n   */\n  constructor(workspace: Blockly.WorkspaceSvg) {\n    super(workspace);\n    this.id = 'minimap';\n    this.margin = 20;\n    this.top = 0;\n    this.left = 0;\n    this.width = 225;\n    this.height = 150;\n  }\n\n  /**\n   * Initialize.\n   */\n  init(): void {\n    super.init();\n    this.primaryWorkspace.getComponentManager().addComponent({\n      component: this,\n      weight: 3,\n      capabilities: [Blockly.ComponentManager.Capability.POSITIONABLE],\n    });\n    this.primaryWorkspace.resize();\n  }\n\n  /**\n   * Returns the bounding rectangle of the UI element in pixel units\n   * relative to the Blockly injection div.\n   *\n   * @returns The componentâ€™s bounding box.\n   */\n  getBoundingRectangle(): Blockly.utils.Rect {\n    return new Blockly.utils.Rect(\n      this.top,\n      this.top + this.height,\n      this.left,\n      this.left + this.width,\n    );\n  }\n\n  /**\n   * Positions the minimap.\n   *\n   * @param metrics The workspace metrics.\n   * @param savedPositions List of rectangles already on the workspace.\n   */\n  position(\n    metrics: Blockly.MetricsManager.UiMetrics,\n    savedPositions: Blockly.utils.Rect[],\n  ): void {\n    this.setSize();\n    this.setPosition(metrics, savedPositions);\n    this.setAttributes();\n  }\n\n  /**\n   * Sizes the minimap.\n   *\n   * @internal\n   */\n  setSize(): void {\n    const viewWidth = this.primaryWorkspace.getMetrics().viewWidth;\n    this.width = Math.max(minWidth, viewWidth / 5);\n    this.height = (this.width * 2) / 3;\n  }\n\n  /**\n   * Calculates the position of the minimap over the primary workspace.\n   *\n   * @param metrics The workspace metrics.\n   * @param savedPositions List of rectangles already on the workspace.\n   * @internal\n   */\n  setPosition(\n    metrics: Blockly.MetricsManager.UiMetrics,\n    savedPositions: Blockly.utils.Rect[],\n  ): void {\n    // Aliases.\n    const workspace = this.primaryWorkspace;\n    const scrollbars = workspace.scrollbar;\n\n    const hasVerticalScrollbars =\n      scrollbars && scrollbars.isVisible() && scrollbars.canScrollVertically();\n    const hasHorizontalScrollbars =\n      scrollbars &&\n      scrollbars.isVisible() &&\n      scrollbars.canScrollHorizontally();\n\n    if (\n      metrics.toolboxMetrics.position === Blockly.TOOLBOX_AT_LEFT ||\n      (workspace.horizontalLayout && !workspace.RTL)\n    ) {\n      // Right edge placement.\n      this.left =\n        metrics.absoluteMetrics.left +\n        metrics.viewMetrics.width -\n        this.width -\n        this.margin;\n      if (hasVerticalScrollbars && !workspace.RTL) {\n        this.left -= Blockly.Scrollbar.scrollbarThickness;\n      }\n    } else {\n      // Left edge placement.\n      this.left = this.margin;\n      if (hasVerticalScrollbars && workspace.RTL) {\n        this.left += Blockly.Scrollbar.scrollbarThickness;\n      }\n    }\n\n    const startAtBottom =\n      metrics.toolboxMetrics.position === Blockly.TOOLBOX_AT_BOTTOM;\n    if (startAtBottom) {\n      // Bottom edge placement.\n      this.top =\n        metrics.absoluteMetrics.top +\n        metrics.viewMetrics.height -\n        this.height -\n        this.margin;\n      if (hasHorizontalScrollbars) {\n        // The horizontal scrollbars are always positioned on the bottom.\n        this.top -= Blockly.Scrollbar.scrollbarThickness;\n      }\n    } else {\n      // Upper edge placement.\n      this.top = metrics.absoluteMetrics.top + this.margin;\n    }\n\n    // Check for collision and bump if needed.\n    let boundingRect = this.getBoundingRectangle();\n    for (let i = 0; i < savedPositions.length; i++) {\n      if (boundingRect.intersects(savedPositions[i])) {\n        if (startAtBottom) {\n          this.top = savedPositions[i].top - this.height - this.margin;\n        } else {\n          this.top = savedPositions[i].bottom + this.margin;\n        }\n        // Recheck other savedPositions.\n        boundingRect = this.getBoundingRectangle();\n        i = -1;\n      }\n    }\n  }\n\n  /**\n   * Sets the CSS attribute for the minimap.\n   */\n  private setAttributes(): void {\n    const injectDiv = this.minimapWorkspace?.getInjectionDiv();\n    if (!injectDiv) {\n      return;\n    }\n    if (injectDiv?.parentElement === null) {\n      return;\n    }\n    const style = injectDiv.parentElement.style;\n    style.zIndex = '2';\n    style.position = 'absolute';\n    style.width = `${this.width}px`;\n    style.height = `${this.height}px`;\n    style.top = `${this.top}px`;\n    style.left = `${this.left}px`;\n    if (this.minimapWorkspace) {\n      Blockly.svgResize(this.minimapWorkspace);\n    }\n  }\n}\n\nBlockly.Css.register(`\n.blockly-minimap {\n  box-shadow: 2px 2px 10px grey;\n}\n`);\n"],
  "mappings": "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",
  "names": ["root", "factory", "exports", "module", "require", "define", "amd", "a", "i", "this", "__WEBPACK_EXTERNAL_MODULE__370__", "__webpack_module_cache__", "__webpack_require__", "moduleId", "cachedModule", "__webpack_modules__", "d", "definition", "key", "o", "Object", "defineProperty", "enumerable", "get", "obj", "prop", "prototype", "hasOwnProperty", "call", "r", "Symbol", "toStringTag", "value", "blockEvents", "Set", "VIEWPORT_CHANGE", "BLOCK_CHANGE", "BLOCK_CREATE", "BLOCK_DELETE", "BLOCK_DRAG", "BLOCK_MOVE", "FocusRegion", "primaryWorkspace", "minimapWorkspace", "svgGroup", "rect", "background", "initialized", "id", "String", "Math", "random", "substring", "onChangeWrapper", "onChange", "bind", "init", "dom", "createSvgElement", "Svg", "G", "class", "mask", "RECT", "x", "y", "width", "height", "fill", "rx", "ry", "parentSvg", "getParentSvg", "firstChild", "insertBefore", "appendChild", "window", "addEventListener", "update", "addChangeListener", "dispose", "removeChangeListener", "removeNode", "event", "has", "type", "primaryMetrics", "getMetricsManager", "minimapMetrics", "primaryView", "getViewMetrics", "primaryContent", "getContentMetrics", "minimapContent", "minimapSvg", "getSvgMetrics", "scale", "left", "top", "Error", "setAttribute", "toString", "isEnabled", "register", "Minimap", "workspace", "focusRegion", "onMouseMoveWrapper", "onMouseDownWrapper", "onMouseUpWrapper", "minimapWrapper", "primaryInjectParentDiv", "getInjectionDiv", "parentNode", "document", "createElement", "className", "rtl", "RTL", "move", "scrollbars", "drag", "wheel", "zoom", "maxScale", "Infinity", "minScale", "readOnly", "theme", "getTheme", "renderer", "options", "scrollbar", "setContainerVisible", "e", "mirror", "zoomToFit", "mouseDownFunc", "onClickDown", "svgGroup_", "onClickUp", "enableFocusRegion", "isFocusEnabled", "disableFocusRegion", "unbind", "xml", "tagName", "json", "toJson", "fromJson", "run", "finishQueuedRenders", "then", "offsetX", "offsetY", "svgWidth", "contentWidth", "svgHeight", "contentHeight", "contentLeft", "contentTop", "viewWidth", "viewHeight", "getMetrics", "minimapToPrimaryCoords", "scroll", "stopImmediatePropagation", "onMouseMove", "primaryScroll", "PositionedMinimap", "super", "margin", "getComponentManager", "addComponent", "component", "weight", "capabilities", "Capability", "POSITIONABLE", "resize", "getBoundingRectangle", "Rect", "metrics", "savedPositions", "setSize", "setPosition", "setAttributes", "max", "hasVerticalScrollbars", "isVisible", "canScrollVertically", "hasHorizontalScrollbars", "canScrollHorizontally", "toolboxMetrics", "position", "horizontalLayout", "absoluteMetrics", "viewMetrics", "scrollbarThickness", "startAtBottom", "boundingRect", "length", "intersects", "bottom", "injectDiv", "parentElement", "style", "zIndex"]
}
