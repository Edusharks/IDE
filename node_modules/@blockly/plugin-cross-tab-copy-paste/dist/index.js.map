{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/plugin-cross-tab-copy-paste/webpack/universalModuleDefinition","webpack://@blockly/plugin-cross-tab-copy-paste/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/plugin-cross-tab-copy-paste/webpack/bootstrap","webpack://@blockly/plugin-cross-tab-copy-paste/webpack/runtime/compat get default export","webpack://@blockly/plugin-cross-tab-copy-paste/webpack/runtime/define property getters","webpack://@blockly/plugin-cross-tab-copy-paste/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/plugin-cross-tab-copy-paste/webpack/runtime/make namespace object","webpack://@blockly/plugin-cross-tab-copy-paste/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__370__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__370__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\ntype TypeErrorCallback = () => void;\n\n/**\n * Checks if the copy data represents that for a block.\n *\n * @param obj any ICopyData.\n * @returns if the ICopyData is a BlockCopyData.\n */\nfunction isBlockCopyData(\n  obj: Blockly.ICopyData,\n): obj is Blockly.clipboard.BlockCopyData {\n  return 'typeCounts' in obj;\n}\n\n/**\n * Determine if a focusable node can be copied.\n *\n * This will use the isCopyable method if the node implements it, otherwise\n * it will fall back to checking if the node is deletable and draggable not\n * considering the workspace's edit state.\n *\n * n.b. copied (with minor changes) from blockly/core/shortcut_items.\n *\n * @param focused The focused object.\n */\nfunction isCopyable(focused: Blockly.IFocusableNode): boolean {\n  if (\n    !Blockly.isCopyable(focused) ||\n    !Blockly.isDeletable(focused) ||\n    !Blockly.isDraggable(focused)\n  )\n    return false;\n  // The cast is necessary while the minimum version of Blockly required is < 12.2.0\n  // because that version is when `isCopyable` was introduced on the `ICopyable` interface.\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  if ((focused as any).isCopyable) {\n    return (focused as any).isCopyable();\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n  } else if (\n    focused instanceof Blockly.BlockSvg ||\n    focused instanceof Blockly.comments.RenderedWorkspaceComment\n  ) {\n    return focused.isOwnDeletable() && focused.isOwnMovable();\n  }\n  // This isn't a class Blockly knows about, so fall back to the stricter\n  // checks for deletable and movable.\n  return focused.isDeletable() && focused.isMovable();\n}\n\n/**\n * Determine if a focusable node can be cut.\n *\n * This will check if the node can be both copied and deleted in its current\n * workspace.\n *\n * n.b. copied from blockly/core/shortcut_items.\n *\n * @param focused The focused object.\n */\nfunction isCuttable(focused: Blockly.IFocusableNode): boolean {\n  return (\n    isCopyable(focused) && Blockly.isDeletable(focused) && focused.isDeletable()\n  );\n}\n\n/**\n * Return value for a context menu item's precondition.\n */\nenum ContextMenuState {\n  ENABLED = 'enabled',\n  DISABLED = 'disabled',\n  HIDDEN = 'hidden',\n}\n\n/**\n * A Blockly plugin that adds context menu items and keyboard shortcuts\n * to allow users to copy and paste copyable objects between tabs.\n */\nexport class CrossTabCopyPaste {\n  /** Key in which store copy data in the browser's local storage. */\n  localStorageKey = 'blocklyStash';\n\n  /**\n   * Initializes the cross tab copy paste plugin. If no options are selected\n   * then both context menu items and keyboard shortcuts are added.\n   *\n   * @param options\n   * @param options.shortcut Register cut (ctr + x), copy (ctr + c) and paste (ctr + v)\n   * in the shortcut.\n   * @param options.contextMenu Register copy and paste in the context menu.\n   * @param typeErrorCallback callback function to handle type errors\n   * @param localStorageKey custom key for local storage\n   */\n  init(\n    {contextMenu = true, shortcut = true} = {\n      contextMenu: true,\n      shortcut: true,\n    },\n    typeErrorCallback?: TypeErrorCallback,\n    localStorageKey?: string,\n  ) {\n    if (localStorageKey) this.localStorageKey = localStorageKey;\n    if (contextMenu) {\n      // Register the menus\n      this.blockCopyToStorageContextMenu();\n      this.blockPasteFromStorageContextMenu(typeErrorCallback);\n    }\n\n    if (shortcut) {\n      // Unregister the default KeyboardShortcuts\n      Blockly.ShortcutRegistry.registry.unregister(\n        Blockly.ShortcutItems.names.COPY,\n      );\n      Blockly.ShortcutRegistry.registry.unregister(\n        Blockly.ShortcutItems.names.CUT,\n      );\n      Blockly.ShortcutRegistry.registry.unregister(\n        Blockly.ShortcutItems.names.PASTE,\n      );\n      // Register the KeyboardShortcuts\n      this.blockCopyToStorageShortcut();\n      this.blockCutToStorageShortcut();\n      this.blockPasteFromStorageShortcut(typeErrorCallback);\n    }\n  }\n\n  /**\n   * Parses copy data from JSON in local storage, if it exists.\n   *\n   * @returns copy data parsed from local storage, or undefined\n   */\n  getCopyData(): Blockly.ICopyData | undefined {\n    const stored = localStorage.getItem(this.localStorageKey);\n    if (!stored) return undefined;\n    return JSON.parse(stored);\n  }\n\n  /**\n   * Copy precondition called by both keyboard shortcut and context menu item.\n   * Allows copying out of the flyout, as long as they could be pasted\n   * into the main workspace.\n   *\n   * @param scope scope for copy action.\n   * @param workspace explicit workspace for keyboard shortcuts,\n   * undefined to get the workspace from the focused node.\n   * @returns whether the option should be shown/hidden/disabled.\n   */\n  copyPrecondition(\n    scope: Blockly.ContextMenuRegistry.Scope,\n    workspace?: Blockly.Workspace,\n  ): ContextMenuState {\n    const focused = scope.focusedNode;\n    if (!focused) return ContextMenuState.HIDDEN;\n    if (!Blockly.isCopyable(focused)) return ContextMenuState.HIDDEN;\n\n    if (!workspace) workspace = focused.workspace;\n    if (!(workspace instanceof Blockly.WorkspaceSvg))\n      return ContextMenuState.HIDDEN;\n    const targetWorkspace = workspace.isFlyout\n      ? workspace.targetWorkspace\n      : workspace;\n    if (\n      !!focused &&\n      !!targetWorkspace &&\n      !targetWorkspace.isDragging() &&\n      !Blockly.getFocusManager().ephemeralFocusTaken() &&\n      isCopyable(focused)\n    )\n      return ContextMenuState.ENABLED;\n    return ContextMenuState.DISABLED;\n  }\n\n  /**\n   * Copy callback called by both keyboard shortcut and context menu item.\n   * Copies the copy data to local storage.\n   *\n   * @param scope scope for copy action.\n   * @param workspace workspace where shortcut or context menu was activated.\n   * @returns true if copy happened, false otherwise.\n   */\n  copyCallback(\n    scope: Blockly.ContextMenuRegistry.Scope,\n    workspace: Blockly.Workspace,\n  ): boolean {\n    const focused = scope.focusedNode;\n    if (!focused || !Blockly.isCopyable(focused) || !isCopyable(focused))\n      return false;\n\n    if (!(workspace instanceof Blockly.WorkspaceSvg)) return false;\n\n    const targetWorkspace = workspace.isFlyout\n      ? workspace.targetWorkspace\n      : workspace;\n    if (!targetWorkspace) return false;\n\n    if (!focused.workspace.isFlyout) {\n      targetWorkspace.hideChaff();\n    }\n    const copyData = focused.toCopyData();\n    if (!copyData) return false;\n    localStorage.setItem(this.localStorageKey, JSON.stringify(copyData));\n    return true;\n  }\n\n  /**\n   * Paste precondition called by both keyboard shortcut and context menu item.\n   *\n   * @param workspace workspace to paste in. should not be a flyout workspace.\n   * @returns true if paste happened, false otherwise.\n   */\n  pastePrecondition(workspace: Blockly.WorkspaceSvg): ContextMenuState {\n    const copyData = this.getCopyData();\n    if (!copyData) return ContextMenuState.DISABLED;\n    // If this is a block, make sure there's room for that type of block\n    if (\n      isBlockCopyData(copyData) &&\n      !workspace?.isCapacityAvailable(copyData.typeCounts)\n    )\n      return ContextMenuState.DISABLED;\n\n    if (\n      !!workspace &&\n      !workspace.isReadOnly() &&\n      !workspace.isDragging() &&\n      !Blockly.getFocusManager().ephemeralFocusTaken()\n    )\n      return ContextMenuState.ENABLED;\n    return ContextMenuState.DISABLED;\n  }\n\n  /**\n   * v12.0.0 of Blockly included the keyboard shortcut in Msg string, but\n   * it was removed in v12.2.0. This function can be removed when this plugin's\n   * minimum version of Blockly is >=12.2.0.\n   *\n   * @param labelText Blockly.Msg for the shortcut\n   * @returns trimmed label for the context menu item.\n   */\n  getContextMenuText(labelText: string): string {\n    // TODO: Once core is updated to remove the shortcut placeholders from the\n    // keyboard shortcut messages, remove this.\n    if (labelText.indexOf(')') === labelText.length - 1) {\n      labelText = labelText.split(' (')[0];\n    }\n    return labelText;\n  }\n\n  /**\n   * Adds a copy command to the context menu for copyable items.\n   */\n  blockCopyToStorageContextMenu() {\n    const copyToStorageOption: Blockly.ContextMenuRegistry.RegistryItem = {\n      displayText: () => {\n        if (Blockly.Msg['CROSS_TAB_COPY']) {\n          return Blockly.Msg['CROSS_TAB_COPY'];\n        }\n        return this.getContextMenuText(Blockly.Msg['COPY_SHORTCUT']);\n      },\n      preconditionFn: (scope: Blockly.ContextMenuRegistry.Scope) => {\n        return this.copyPrecondition(scope);\n      },\n      callback: (scope: Blockly.ContextMenuRegistry.Scope) => {\n        const focused = scope.focusedNode;\n        // Check Blockly.isCopyable to make sure focused.workspace exists\n        if (!focused || !Blockly.isCopyable(focused)) return false;\n\n        const workspace = focused.workspace;\n        return this.copyCallback(scope, workspace);\n      },\n      id: 'blockCopyToStorage',\n      weight: 0,\n    };\n    Blockly.ContextMenuRegistry.registry.register(copyToStorageOption);\n  }\n\n  /**\n   * Adds a paste command to the context menu for copyable items.\n   *\n   * @param typeErrorCallback callback function to handle type errors\n   */\n  blockPasteFromStorageContextMenu(typeErrorCallback?: TypeErrorCallback) {\n    const pasteFromStorageOption: Blockly.ContextMenuRegistry.RegistryItem = {\n      displayText: () => {\n        if (Blockly.Msg['CROSS_TAB_PASTE']) {\n          return Blockly.Msg['CROSS_TAB_PASTE'];\n        }\n        return this.getContextMenuText(Blockly.Msg['PASTE_SHORTCUT']);\n      },\n      preconditionFn: (scope) => {\n        // Only show paste option if menu was opened on a non-flyout workspace\n        if (\n          !(scope.focusedNode instanceof Blockly.WorkspaceSvg) ||\n          scope.focusedNode.isFlyout\n        )\n          return ContextMenuState.HIDDEN;\n        const workspace = scope.focusedNode;\n        return this.pastePrecondition(workspace);\n      },\n      callback: (scope, menuOpenEvent, menuSelectEvent, location) => {\n        const copyData = this.getCopyData();\n        if (!copyData) return false;\n        const workspace = scope.focusedNode;\n        // Paste option only available if menu was opened on a workspace\n        if (!(workspace instanceof Blockly.WorkspaceSvg)) return false;\n\n        const pasteLocation = Blockly.utils.svgMath.screenToWsCoordinates(\n          workspace,\n          location,\n        );\n        try {\n          return !!Blockly.clipboard.paste(copyData, workspace, pasteLocation);\n        } catch (e) {\n          if (e instanceof TypeError && typeErrorCallback) {\n            typeErrorCallback();\n          } else {\n            throw e;\n          }\n        }\n      },\n      id: 'blockPasteFromStorage',\n      weight: 0,\n    };\n    Blockly.ContextMenuRegistry.registry.register(pasteFromStorageOption);\n  }\n\n  /**\n   * Adds a keyboard shortcut that will store copy information for a copyable\n   * in localStorage.\n   */\n  blockCopyToStorageShortcut() {\n    const ctrlC = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.C,\n      [Blockly.utils.KeyCodes.CTRL],\n    );\n    const metaC = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.C,\n      [Blockly.utils.KeyCodes.META],\n    );\n    const copyShortcut: Blockly.ShortcutRegistry.KeyboardShortcut = {\n      name: Blockly.ShortcutItems.names.COPY,\n      keyCodes: [ctrlC, metaC],\n      preconditionFn: (workspace, scope) => {\n        const status = this.copyPrecondition(scope, workspace);\n        return status === ContextMenuState.ENABLED;\n      },\n      callback: (workspace, e, shortcut, scope) => {\n        // Prevent the default copy behavior,\n        // which may beep or otherwise indicate\n        // an error due to the lack of a selection.\n        e.preventDefault();\n        return this.copyCallback(scope, workspace);\n      },\n    };\n    Blockly.ShortcutRegistry.registry.register(copyShortcut);\n  }\n\n  /**\n   * Adds a keyboard shortcut that will store copy information for copyable\n   * items in local storage and delete the item.\n   */\n  blockCutToStorageShortcut() {\n    const ctrlX = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.X,\n      [Blockly.utils.KeyCodes.CTRL],\n    );\n    const metaX = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.X,\n      [Blockly.utils.KeyCodes.META],\n    );\n\n    const cutShortcut: Blockly.ShortcutRegistry.KeyboardShortcut = {\n      name: Blockly.ShortcutItems.names.CUT,\n      keyCodes: [ctrlX, metaX],\n      preconditionFn: (workspace, scope) => {\n        const focused = scope.focusedNode;\n        return (\n          !!focused &&\n          !workspace.isReadOnly() &&\n          !workspace.isDragging() &&\n          !Blockly.getFocusManager().ephemeralFocusTaken() &&\n          isCuttable(focused)\n        );\n      },\n      callback: (workspace, e, shortcut, scope) => {\n        // Prevent the default cut behavior,\n        // which may beep or otherwise indicate\n        // an error due to the lack of a selection.\n        e.preventDefault();\n\n        const focused = scope.focusedNode;\n        if (!focused || !isCuttable(focused) || !Blockly.isCopyable(focused)) {\n          return false;\n        }\n        const copyData = focused.toCopyData();\n        if (!copyData) return false;\n\n        if (focused instanceof Blockly.BlockSvg) {\n          focused.checkAndDelete();\n        } else if (Blockly.isDeletable(focused)) {\n          // Manually handle event grouping since only blocks handle that\n          // automatically.\n          const oldGroup = Blockly.Events.getGroup();\n          Blockly.Events.setGroup(true);\n          focused.dispose();\n          Blockly.Events.setGroup(oldGroup);\n        }\n\n        localStorage.setItem(this.localStorageKey, JSON.stringify(copyData));\n        return true;\n      },\n    };\n    Blockly.ShortcutRegistry.registry.register(cutShortcut);\n  }\n\n  /**\n   * Adds a keyboard shortcut that will paste the copyable stored in localStorage.\n   *\n   * @param typeErrorCallback\n   * callback function to handle type errors\n   */\n  blockPasteFromStorageShortcut(typeErrorCallback?: TypeErrorCallback) {\n    const ctrlV = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.V,\n      [Blockly.utils.KeyCodes.CTRL],\n    );\n    const metaV = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.V,\n      [Blockly.utils.KeyCodes.META],\n    );\n\n    const pasteShortcut: Blockly.ShortcutRegistry.KeyboardShortcut = {\n      name: Blockly.ShortcutItems.names.PASTE,\n      keyCodes: [ctrlV, metaV],\n      preconditionFn: (workspace) => {\n        const targetWorkspace = workspace.isFlyout\n          ? workspace.targetWorkspace\n          : workspace;\n\n        if (!targetWorkspace) return false;\n        const status = this.pastePrecondition(targetWorkspace);\n        return status === ContextMenuState.ENABLED;\n      },\n      callback: (workspace, e) => {\n        // Prevent the default copy behavior,\n        // which may beep or otherwise indicate\n        // an error due to the lack of a selection.\n        e.preventDefault();\n        const copyData = this.getCopyData();\n        if (!copyData) return false;\n\n        // If paste shortcut is called while flyout is open, paste in the\n        // main workspace instead.\n        const targetWorkspace = workspace.isFlyout\n          ? workspace.targetWorkspace\n          : workspace;\n        if (!targetWorkspace) return false;\n        try {\n          if (e instanceof PointerEvent) {\n            // The event that triggers a shortcut would conventionally be a KeyboardEvent.\n            // However, it may be a PointerEvent if a context menu item was used as a\n            // wrapper for this callback, in which case the new block(s) should be pasted\n            // at the mouse coordinates where the menu was opened, and this PointerEvent\n            // is where the menu was opened.\n            const mouseCoords = Blockly.utils.svgMath.screenToWsCoordinates(\n              targetWorkspace,\n              new Blockly.utils.Coordinate(e.clientX, e.clientY),\n            );\n            return !!Blockly.clipboard.paste(\n              copyData,\n              targetWorkspace,\n              mouseCoords,\n            );\n          }\n          // If we don't have location data about the original copyable, let the\n          // paster determine position.\n          return !!Blockly.clipboard.paste(copyData, targetWorkspace);\n        } catch (e) {\n          if (e instanceof TypeError && typeErrorCallback) {\n            typeErrorCallback();\n          } else {\n            throw e;\n          }\n        }\n        return true;\n      },\n    };\n    Blockly.ShortcutRegistry.registry.register(pasteShortcut);\n  }\n}\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__370__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","ContextMenuState","isCopyable","focused","RenderedWorkspaceComment","isOwnDeletable","isOwnMovable","isDeletable","isMovable","isCuttable","CrossTabCopyPaste","localStorageKey","init","contextMenu","shortcut","typeErrorCallback","blockCopyToStorageContextMenu","blockPasteFromStorageContextMenu","registry","unregister","names","COPY","CUT","PASTE","blockCopyToStorageShortcut","blockCutToStorageShortcut","blockPasteFromStorageShortcut","getCopyData","stored","localStorage","getItem","JSON","parse","copyPrecondition","scope","workspace","focusedNode","HIDDEN","targetWorkspace","isFlyout","isDragging","ephemeralFocusTaken","ENABLED","DISABLED","copyCallback","hideChaff","copyData","toCopyData","setItem","stringify","pastePrecondition","isCapacityAvailable","typeCounts","isReadOnly","getContextMenuText","labelText","indexOf","length","split","copyToStorageOption","displayText","preconditionFn","callback","id","weight","register","pasteFromStorageOption","menuOpenEvent","menuSelectEvent","location","pasteLocation","svgMath","screenToWsCoordinates","paste","e","TypeError","ctrlC","createSerializedKey","KeyCodes","C","CTRL","metaC","META","copyShortcut","name","keyCodes","preventDefault","ctrlX","X","metaX","cutShortcut","checkAndDelete","oldGroup","getGroup","setGroup","dispose","ctrlV","V","metaV","pasteShortcut","PointerEvent","mouseCoords","Coordinate","clientX","clientY"],"sourceRoot":""}