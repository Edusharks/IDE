{
  "version": 3,
  "sources": ["file:///mnt/vss/_work/1/s/dependencies/vscode/file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/worker/webWorkerBootstrap.ts", "file:///mnt/vss/_work/1/s/dependencies/vscode/vs/base/common/worker/webWorkerBootstrap.ts", "file:///mnt/vss/_work/1/s/dependencies/vscode/file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/editor.worker.start.ts", "file:///mnt/vss/_work/1/s/dependencies/vscode/vs/editor/editor.worker.start.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IWebWorkerServerRequestHandler, IWebWorkerServerRequestHandlerFactory, WebWorkerServer } from './webWorker.js';\n\ntype MessageEvent = {\n\tdata: unknown;\n};\n\ndeclare const globalThis: {\n\tpostMessage: (message: any) => void;\n\tonmessage: (event: MessageEvent) => void;\n};\n\nlet initialized = false;\n\nexport function initialize<T extends IWebWorkerServerRequestHandler>(factory: IWebWorkerServerRequestHandlerFactory<T>) {\n\tif (initialized) {\n\t\tthrow new Error('WebWorker already initialized!');\n\t}\n\tinitialized = true;\n\n\tconst webWorkerServer = new WebWorkerServer<T>(\n\t\tmsg => globalThis.postMessage(msg),\n\t\t(workerServer) => factory(workerServer)\n\t);\n\n\tglobalThis.onmessage = (e: MessageEvent) => {\n\t\twebWorkerServer.onmessage(e.data);\n\t};\n\n\treturn webWorkerServer;\n}\n\nexport function bootstrapWebWorker(factory: IWebWorkerServerRequestHandlerFactory<any>) {\n\tglobalThis.onmessage = (_e: MessageEvent) => {\n\t\t// Ignore first message in this case and initialize if not yet initialized\n\t\tif (!initialized) {\n\t\t\tinitialize(factory);\n\t\t}\n\t};\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IWebWorkerServerRequestHandler, IWebWorkerServerRequestHandlerFactory, WebWorkerServer } from './webWorker.js';\n\ntype MessageEvent = {\n\tdata: unknown;\n};\n\ndeclare const globalThis: {\n\tpostMessage: (message: any) => void;\n\tonmessage: (event: MessageEvent) => void;\n};\n\nlet initialized = false;\n\nexport function initialize<T extends IWebWorkerServerRequestHandler>(factory: IWebWorkerServerRequestHandlerFactory<T>) {\n\tif (initialized) {\n\t\tthrow new Error('WebWorker already initialized!');\n\t}\n\tinitialized = true;\n\n\tconst webWorkerServer = new WebWorkerServer<T>(\n\t\tmsg => globalThis.postMessage(msg),\n\t\t(workerServer) => factory(workerServer)\n\t);\n\n\tglobalThis.onmessage = (e: MessageEvent) => {\n\t\twebWorkerServer.onmessage(e.data);\n\t};\n\n\treturn webWorkerServer;\n}\n\nexport function bootstrapWebWorker(factory: IWebWorkerServerRequestHandlerFactory<any>) {\n\tglobalThis.onmessage = (_e: MessageEvent) => {\n\t\t// Ignore first message in this case and initialize if not yet initialized\n\t\tif (!initialized) {\n\t\t\tinitialize(factory);\n\t\t}\n\t};\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { initialize } from '../base/common/worker/webWorkerBootstrap.js';\nimport { EditorWorker, IWorkerContext } from './common/services/editorWebWorker.js';\nimport { EditorWorkerHost } from './common/services/editorWorkerHost.js';\n\n/**\n * Used by `monaco-editor` to hook up web worker rpc.\n * @skipMangle\n * @internal\n */\nexport function start<THost extends object, TClient extends object>(createClient: (ctx: IWorkerContext<THost>) => TClient): TClient {\n\tlet client: TClient | undefined;\n\tconst webWorkerServer = initialize((workerServer) => {\n\t\tconst editorWorkerHost = EditorWorkerHost.getChannel(workerServer);\n\n\t\tconst host = new Proxy({}, {\n\t\t\tget(target, prop, receiver) {\n\t\t\t\tif (prop === 'then') {\n\t\t\t\t\t// Don't forward the call when the proxy is returned in an async function and the runtime tries to .then it.\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif (typeof prop !== 'string') {\n\t\t\t\t\tthrow new Error(`Not supported`);\n\t\t\t\t}\n\t\t\t\treturn (...args: unknown[]) => {\n\t\t\t\t\treturn editorWorkerHost.$fhr(prop, args);\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tconst ctx: IWorkerContext<THost> = {\n\t\t\thost: host as THost,\n\t\t\tgetMirrorModels: () => {\n\t\t\t\treturn webWorkerServer.requestHandler.getModels();\n\t\t\t}\n\t\t};\n\n\t\tclient = createClient(ctx);\n\n\t\treturn new EditorWorker(client);\n\t});\n\n\treturn client!;\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { initialize } from '../base/common/worker/webWorkerBootstrap.js';\nimport { EditorWorker, IWorkerContext } from './common/services/editorWebWorker.js';\nimport { EditorWorkerHost } from './common/services/editorWorkerHost.js';\n\n/**\n * Used by `monaco-editor` to hook up web worker rpc.\n * @skipMangle\n * @internal\n */\nexport function start<THost extends object, TClient extends object>(createClient: (ctx: IWorkerContext<THost>) => TClient): TClient {\n\tlet client: TClient | undefined;\n\tconst webWorkerServer = initialize((workerServer) => {\n\t\tconst editorWorkerHost = EditorWorkerHost.getChannel(workerServer);\n\n\t\tconst host = new Proxy({}, {\n\t\t\tget(target, prop, receiver) {\n\t\t\t\tif (prop === 'then') {\n\t\t\t\t\t// Don't forward the call when the proxy is returned in an async function and the runtime tries to .then it.\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif (typeof prop !== 'string') {\n\t\t\t\t\tthrow new Error(`Not supported`);\n\t\t\t\t}\n\t\t\t\treturn (...args: unknown[]) => {\n\t\t\t\t\treturn editorWorkerHost.$fhr(prop, args);\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tconst ctx: IWorkerContext<THost> = {\n\t\t\thost: host as THost,\n\t\t\tgetMirrorModels: () => {\n\t\t\t\treturn webWorkerServer.requestHandler.getModels();\n\t\t\t}\n\t\t};\n\n\t\tclient = createClient(ctx);\n\n\t\treturn new EditorWorker(client);\n\t});\n\n\treturn client!;\n}\n"],
  "mappings": ";;;;;;;AAgBA,IAAI,cAAc;AAEZ,SAAU,WAAqD,SAAiD;AACrH,MAAI,aAAa;AAChB,UAAM,IAAI,MAAM,gCAAgC;EACjD;AACA,gBAAc;AAEd,QAAM,kBAAkB,IAAI,gBAC3B,SAAO,WAAW,YAAY,GAAG,GACjC,CAAC,iBAAiB,QAAQ,YAAY,CAAC;AAGxC,aAAW,YAAY,CAAC,MAAmB;AAC1C,oBAAgB,UAAU,EAAE,IAAI;EACjC;AAEA,SAAO;AACR;;;AEpBM,SAAU,MAAoD,cAAqD;AACxH,MAAI;AACJ,QAAM,kBAAkB,WAAW,CAAC,iBAAgB;AACnD,UAAM,mBAAmB,iBAAiB,WAAW,YAAY;AAEjE,UAAM,OAAO,IAAI,MAAM,CAAA,GAAI;MAC1B,IAAI,QAAQ,MAAM,UAAQ;AACzB,YAAI,SAAS,QAAQ;AAEpB,iBAAO;QACR;AACA,YAAI,OAAO,SAAS,UAAU;AAC7B,gBAAM,IAAI,MAAM,eAAe;QAChC;AACA,eAAO,IAAI,SAAmB;AAC7B,iBAAO,iBAAiB,KAAK,MAAM,IAAI;QACxC;MACD;KACA;AAED,UAAM,MAA6B;MAClC;MACA,iBAAiB,MAAK;AACrB,eAAO,gBAAgB,eAAe,UAAS;MAChD;;AAGD,aAAS,aAAa,GAAG;AAEzB,WAAO,IAAI,aAAa,MAAM;EAC/B,CAAC;AAED,SAAO;AACR;",
  "names": []
}
