{
  "version": 3,
  "sources": ["../../@blockly/plugin-scroll-options/src/ScrollMetricsManager.ts", "../../@blockly/plugin-scroll-options/src/utils.ts", "../../@blockly/plugin-scroll-options/src/AutoScroll.ts", "../../@blockly/plugin-scroll-options/src/AutoScrollable.ts", "../../@blockly/plugin-scroll-options/src/ScrollBlockDragger.ts", "../../@blockly/plugin-scroll-options/src/index.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * The MetricsManager reports various metrics about the workspace. This version\n * of the MetricsManager adds optional cacheing of the workspace content\n * metrics. Cached content metrics are useful if, for example, you are in the\n * middle of dragging a block, but want to get the bounds of the content area as\n * if you hadn't yet picked up the block.\n *\n * To use the cached value of the content metrics instead of calculating new\n * ones, set `useCachedContentMetrics` to true before calling `getMetrics`\n * false when the metrics can be recalculated again.\n */\nexport class ScrollMetricsManager extends Blockly.MetricsManager {\n  /**\n   * Whether to stop recalculating content metrics and used the cached value\n   * instead. Note that if there are no cached metrics, they will be\n   * recalculated even if this value is true.\n   */\n  useCachedContentMetrics = false;\n  /**\n   * Cached content metrics, if available.\n   */\n  contentMetrics: Blockly.MetricsManager.ContainerRegion | null = null;\n\n  /** @override */\n  getContentMetrics() {\n    if (this.useCachedContentMetrics && this.contentMetrics) {\n      return this.contentMetrics;\n    }\n\n    this.contentMetrics = super.getContentMetrics();\n    return this.contentMetrics;\n  }\n}\n\n/**\n * A MetricsManager that includes the ability to cache the content metrics.\n * Plugin authors may write their own MetricsManagers that do not necessarily\n * inherit from the ScrollMetricsManagers, e.g. to use multiple plugins together.\n * We can't assume the base class, but we can assert the MetricsManager provided\n * has the necessary property.\n */\nexport type CacheableMetricsManager = Blockly.IMetricsManager & {\n  useCachedContentMetrics: boolean;\n};\n\n/**\n * Checks if a MetricsManager supports cacheing content metrics.\n *\n * @param metricsManager\n */\nexport function isCacheable(\n  metricsManager: Blockly.IMetricsManager,\n): metricsManager is CacheableMetricsManager {\n  return (\n    (metricsManager as CacheableMetricsManager).useCachedContentMetrics !==\n    undefined\n  );\n}\n", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Gets the current location of the workspace considering\n * when there's no drag surface.\n *\n * @param ws The workspace to calculate.\n * @returns The current workspace coordinate.\n */\nexport const getTranslation = (\n  ws: Blockly.WorkspaceSvg,\n): Blockly.utils.Coordinate => {\n  // TODO(blockly/#7157): We should maybe make getBlockCanvas public?\n  const translation = ws.svgBlockCanvas_.getAttribute('transform');\n  if (!translation)\n    throw new Error(`svgBlockCanvas has no attribute 'transform'`);\n\n  // Translation has the format 'translate(x, y)'.\n  const splitted = translation.split(',');\n  const x = Number(splitted[0].split('(')[1]);\n  const y = Number(splitted[1].split(')')[0]);\n  return new Blockly.utils.Coordinate(x, y);\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {isCacheable} from './ScrollMetricsManager';\nimport {getTranslation} from './utils';\nimport {ScrollBlockDragger} from './ScrollBlockDragger';\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * AutoScroll is used to scroll/pan the workspace automatically. For example,\n * when a user drags a block near the edge of the workspace, it can begin\n * automatically scrolling in that direction.\n *\n * Call `updateProperties` with a vector containing scroll velocity in each\n * direction, in pixels per ms. AutoScroll will use animation frames to smoothly\n * scroll the workspace at a constant velocity. Call `stopAndDestroy` to cancel\n * the AutoScroll animation. You must ensure this is called eventually, or you\n * may get stuck in an infinite animation loop and crash the browser.\n */\nexport class AutoScroll {\n  /** Workspace to scroll. */\n  protected workspace_: Blockly.WorkspaceSvg;\n  protected dragger: ScrollBlockDragger;\n  /**\n   * Current active vector representing scroll velocity in pixels per\n   * millisecond in each direction.\n   */\n  protected activeScrollVector_ = new Blockly.utils.Coordinate(0, 0);\n  /** ID of active requestAnimationFrame callback key. */\n  protected animationFrameId_ = 0;\n  /** Time in ms last animation frame was run. */\n  protected lastTime_: number = Date.now();\n  /**\n   * Whether the scroll animation should continue. If this is false, the next\n   * animation frame will not be requested.\n   */\n  protected shouldAnimate_ = false;\n\n  /**\n   * Creates an AutoScroll instance for a specified workspace.\n   *\n   * @param workspace Workspace to scroll.\n   * @param dragger The dragger that's currently dragging.\n   * @constructor\n   */\n  constructor(workspace: Blockly.WorkspaceSvg, dragger: ScrollBlockDragger) {\n    this.workspace_ = workspace;\n    this.dragger = dragger;\n  }\n\n  /**\n   * Cancels the current autoscroll and resets properties.\n   */\n  stopAndDestroy() {\n    this.activeScrollVector_ = new Blockly.utils.Coordinate(0, 0);\n    this.shouldAnimate_ = false;\n    cancelAnimationFrame(this.animationFrameId_);\n    this.animationFrameId_ = 0;\n  }\n\n  /**\n   * Ticks scrolling behavior and triggers another\n   * frame request.\n   *\n   * @param now Current time in ms. This is usually passed\n   *     automatically by `requestAnimationFrame`.\n   */\n  protected nextAnimationStep_(now: number) {\n    if (this.shouldAnimate_) {\n      const delta = now - this.lastTime_;\n      this.lastTime_ = now;\n      // This method could be called multiple times per ms, and we only want to\n      // scroll if we should actually move.\n      if (delta > 0) {\n        this.scrollTick_(delta);\n      }\n\n      this.animationFrameId_ = requestAnimationFrame((time) =>\n        this.nextAnimationStep_(time),\n      );\n    }\n  }\n\n  /**\n   * Perform scroll given time passed.\n   *\n   * @param msPassed Number of ms since last scroll tick.\n   */\n  protected scrollTick_(msPassed: number) {\n    const scrollDx = this.activeScrollVector_.x * msPassed;\n    const scrollDy = this.activeScrollVector_.y * msPassed;\n    this.scrollWorkspaceWithBlock(scrollDx, scrollDy);\n  }\n\n  /**\n   * Scrolls the workspace the given amount during a block drag.\n   * Also updates the dragger based on the amount actually scrolled.\n   *\n   * @param scrollDx Amount to scroll in horizontal direction.\n   * @param scrollDy Amount to scroll in vertical direction.\n   */\n  scrollWorkspaceWithBlock(scrollDx: number, scrollDy: number) {\n    const oldLocation = getTranslation(this.workspace_);\n\n    // As we scroll, we shouldn't expand past the content area that existed\n    // before the block was picked up. Therefore, we use cached ContentMetrics\n    // so that the content area does not change as we scroll.\n    const metricsManager = this.workspace_.getMetricsManager();\n\n    if (!isCacheable(metricsManager)) {\n      console.warn(\n        'MetricsManager must be able to cache metrics in order to use AutoScroll',\n      );\n      return;\n    }\n    metricsManager.useCachedContentMetrics = true;\n    const newX = this.workspace_.scrollX + scrollDx;\n    const newY = this.workspace_.scrollY + scrollDy;\n    this.workspace_.scroll(newX, newY);\n    metricsManager.useCachedContentMetrics = false;\n\n    const newLocation = getTranslation(this.workspace_);\n\n    // How much we actually ended up scrolling.\n    const deltaX = newLocation.x - oldLocation.x;\n    const deltaY = newLocation.y - oldLocation.y;\n\n    // If we did scroll, we need to let the dragger know by how much.\n    // The dragger will update its values so that things like connection\n    // markers will stay consistent.\n    if (deltaX || deltaY) {\n      this.dragger.moveBlockWhileDragging(deltaX, deltaY);\n    }\n  }\n\n  /**\n   * Updates the scroll vector for the current autoscroll and begins the\n   * animation if needed.\n   *\n   * @param scrollVector New scroll velocity vector\n   *     in pixels per ms.\n   */\n  updateProperties(scrollVector: Blockly.utils.Coordinate) {\n    this.activeScrollVector_ = scrollVector;\n    this.shouldAnimate_ = true;\n\n    // Start new animation if there isn't one going.\n    if (this.animationFrameId_ == 0) {\n      this.lastTime_ = Date.now();\n      this.nextAnimationStep_(this.lastTime_);\n    }\n  }\n}\n", "/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/** A Draggable that can be autoscrolled. */\nexport interface AutoScrollable extends Blockly.IDraggable {\n  /**\n   * Returns the coordinates of a bounding box describing the dimensions of\n   * this draggable. This is necessary to detect when edge scrolling\n   * should activate.\n   */\n  getBoundingRectangle: () => Blockly.utils.Rect;\n}\n\n/**\n * Checks if the draggable implements the AutoScrollable interface.\n *\n * @param draggable\n * @returns true if draggable is also AutoScrollable\n */\nexport function isAutoScrollable(\n  draggable: Blockly.IDraggable,\n): draggable is AutoScrollable {\n  return (\n    typeof (draggable as AutoScrollable).getBoundingRectangle === 'function'\n  );\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {AutoScroll} from './AutoScroll';\nimport {isAutoScrollable} from './AutoScrollable';\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\ntype CandidateScrolls = Record<string, Blockly.utils.Coordinate[]>;\n\nexport interface EdgeScrollOptions {\n  /** Pixels per ms to scroll when the block is near the edge of the workspace. */\n  slowBlockSpeed: number;\n  /**\n   * Pixels per ms to scroll when the block is\n   * far past the edge of the workspace.\n   */\n  fastBlockSpeed: number;\n  /**\n   * Distance in workspace units that\n   * the edge of the block is from the edge of the viewport before the\n   * corresponding scroll speed will be used. Can be negative to start scrolling\n   * before the block extends over the edge.\n   */\n  slowBlockStartDistance: number;\n  /**\n   * Same as above, for fast speed.\n   * Must be larger than `slowBlockStartDistance`.\n   */\n  fastBlockStartDistance: number;\n  /**\n   * If a block takes up this\n   * percentage of the viewport or more, it will be considered oversized. Rather\n   * than using the block edge, we use the mouse cursor plus the given margin size\n   * to activate block-based scrolling.\n   */\n  oversizeBlockThreshold: number;\n  /**\n   * Cursor margin to use for oversized\n   * blocks. A bigger value will cause the workspace to scroll sooner, i.e., the\n   * mouse can be further inward from the edge when scrolling begins.\n   */\n  oversizeBlockMargin: number;\n  /**\n   * Pixels per ms to\n   * scroll when the mouse is near the edge of the workspace.\n   */\n  slowMouseSpeed: number;\n  /**\n   * Pixels per ms to\n   * scroll when the mouse is far past the edge of the workspace.\n   */\n  fastMouseSpeed: number;\n  /**\n   * Distance in workspace units that\n   * the mouse is from the edge of the viewport before the corresponding scroll\n   * speed will be used. Can be negative to start scrolling before the mouse\n   * extends over the edge.\n   */\n  slowMouseStartDistance: number;\n  /**\n   * Same as above, for fast speed.\n   * Must be larger than `slowMouseStartDistance`.\n   */\n  fastMouseStartDistance: number;\n}\n\nconst defaultOptions: EdgeScrollOptions = {\n  slowBlockSpeed: 0.28,\n  fastBlockSpeed: 1.4,\n  slowBlockStartDistance: 0,\n  fastBlockStartDistance: 50,\n  oversizeBlockThreshold: 0.85,\n  oversizeBlockMargin: 15,\n  slowMouseSpeed: 0.5,\n  fastMouseSpeed: 1.6,\n  slowMouseStartDistance: 0,\n  fastMouseStartDistance: 35,\n};\n\n/**\n * A block dragger that adds the functionality for a block to be moved while\n * someone is dragging it.\n */\nexport class ScrollBlockDragger extends Blockly.dragging.Dragger {\n  /** How much the block has been moved due to scrolling. */\n  protected scrollDelta_ = new Blockly.utils.Coordinate(0, 0);\n  /** How much the block has been moved due to dragging. */\n  protected dragDelta_ = new Blockly.utils.Coordinate(0, 0);\n\n  // TODO(maribethb): Use `isMoveable` etc. to get this list\n  /** Possible directions the workspace could be scrolled. */\n  protected scrollDirections_: ['top', 'bottom', 'left', 'right'] = [\n    'top',\n    'bottom',\n    'left',\n    'right',\n  ];\n\n  /**\n   * Unit vector for each direction that could be scrolled. This vector will\n   * be scaled to get the calculated velocity in each direction.\n   */\n  private SCROLL_DIRECTION_VECTORS_ = {\n    top: new Blockly.utils.Coordinate(0, 1),\n    bottom: new Blockly.utils.Coordinate(0, -1),\n    left: new Blockly.utils.Coordinate(1, 0),\n    right: new Blockly.utils.Coordinate(-1, 0),\n  };\n\n  activeAutoScroll_: AutoScroll | null = null;\n\n  /**\n   * Whether the behavior to scroll the workspace when a block is dragged near\n   * the edge is enabled.\n   */\n  static edgeScrollEnabled = true;\n  /** Configuration options for the scroll-options settings. */\n  static options: EdgeScrollOptions = defaultOptions;\n\n  /**\n   * Updates the location of the block that is being dragged.\n   *\n   * @param deltaX Horizontal offset in pixel units.\n   * @param deltaY Vertical offset in pixel units.\n   */\n  moveBlockWhileDragging(deltaX: number, deltaY: number): void {\n    // If this object can't be autoscrolled, give up\n    if (!isAutoScrollable(this.draggable)) return;\n\n    this.scrollDelta_.x -= deltaX;\n    this.scrollDelta_.y -= deltaY;\n\n    // The total amount the block has moved since being picked up.\n    const totalDelta = Blockly.utils.Coordinate.sum(\n      this.scrollDelta_,\n      this.dragDelta_,\n    );\n\n    const delta = this.pixelsToWorkspaceUnits(totalDelta);\n    const newLoc = Blockly.utils.Coordinate.sum(this.startLoc, delta);\n\n    // Make the block stay under the cursor.\n    this.draggable.drag(newLoc);\n  }\n\n  /**\n   * Passes the total amount the block has moved (both from dragging and from\n   * scrolling) since it was picked up.\n   *\n   * @override\n   */\n  onDrag(e: PointerEvent, dragDelta: Blockly.utils.Coordinate) {\n    const totalDelta = Blockly.utils.Coordinate.sum(\n      this.scrollDelta_,\n      dragDelta,\n    );\n    super.onDrag(e, totalDelta);\n    this.dragDelta_ = dragDelta;\n\n    if (ScrollBlockDragger.edgeScrollEnabled) {\n      this.scrollWorkspaceWhileDragging_(e);\n    }\n  }\n\n  /**\n   * @override\n   */\n  onDragEnd(e: PointerEvent) {\n    super.onDragEnd(e);\n    this.stopAutoScrolling();\n  }\n\n  /**\n   * May scroll the workspace as a block is dragged.\n   * If a block is dragged near the edge of the workspace, this method will\n   * cause the workspace to scroll in the direction the block is being\n   * dragged. The workspace will not resize as the block is dragged. The\n   * workspace should appear to move out from under the block, i.e., the block\n   * should stay under the user's mouse.\n   *\n   * @param e The mouse/touch event for the drag.\n   */\n  protected scrollWorkspaceWhileDragging_(e: PointerEvent) {\n    // If this object can't be autoscrolled, give up\n    if (!isAutoScrollable(this.draggable)) return;\n\n    const mouse = Blockly.utils.svgMath.screenToWsCoordinates(\n      this.workspace,\n      new Blockly.utils.Coordinate(e.clientX, e.clientY),\n    );\n\n    /**\n     * List of possible scrolls in each direction. This will be modified in\n     * place.\n     */\n    const candidateScrolls: CandidateScrolls = {\n      top: [],\n      bottom: [],\n      left: [],\n      right: [],\n    };\n\n    // Get ViewMetrics in workspace coordinates.\n    const viewMetrics = this.workspace.getMetricsManager().getViewMetrics(true);\n\n    // Get possible scroll velocities based on the location of both the block\n    // and the mouse.\n    this.computeBlockCandidateScrolls_(candidateScrolls, viewMetrics, mouse);\n    this.computeMouseCandidateScrolls_(candidateScrolls, viewMetrics, mouse);\n    // Calculate the final scroll vector we should actually use.\n    const overallScrollVector = this.getOverallScrollVector_(candidateScrolls);\n\n    // If the workspace should not be scrolled any longer, cancel the\n    // autoscroll.\n    if (\n      Blockly.utils.Coordinate.equals(\n        overallScrollVector,\n        new Blockly.utils.Coordinate(0, 0),\n      )\n    ) {\n      this.stopAutoScrolling();\n      return;\n    }\n\n    // Update the autoscroll or start a new one.\n    this.activeAutoScroll_ =\n      this.activeAutoScroll_ || new AutoScroll(this.workspace, this);\n    this.activeAutoScroll_.updateProperties(overallScrollVector);\n  }\n\n  /**\n   * There could be multiple candidate scrolls for each direction, such as one\n   * for block position and one for mouse position. We should first find the\n   * fastest scroll in each direction. Then, we sum those to find the overall\n   * scroll vector.\n   *\n   * For example, we may have a fast block scroll and a slow\n   * mouse scroll candidate in both the top and left directions. First, we\n   * reduce to only the fast block scroll. Then, we sum the vectors in each\n   * direction to get a resulting fast scroll in a diagonal direction to the\n   * top left.\n   *\n   * @param candidateScrolls Existing lists of candidate\n   *     scrolls. Will be modified in place.\n   * @returns Overall scroll vector.\n   */\n  protected getOverallScrollVector_(\n    candidateScrolls: CandidateScrolls,\n  ): Blockly.utils.Coordinate {\n    let overallScrollVector = new Blockly.utils.Coordinate(0, 0);\n    for (const direction of this.scrollDirections_) {\n      const fastestScroll = candidateScrolls[direction].reduce(\n        (fastest, current) => {\n          if (!fastest) {\n            return current;\n          }\n          return Blockly.utils.Coordinate.magnitude(fastest) >\n            Blockly.utils.Coordinate.magnitude(current)\n            ? fastest\n            : current;\n        },\n        new Blockly.utils.Coordinate(0, 0),\n      ); // Initial value\n      overallScrollVector = Blockly.utils.Coordinate.sum(\n        overallScrollVector,\n        fastestScroll,\n      );\n    }\n    return overallScrollVector;\n  }\n\n  /**\n   * Gets the candidate scrolls based on the position of the block on the\n   * workspace. If the block is near/over the edge, a candidate scroll will be\n   * added based on the options provided.\n   *\n   * This method can be overridden to further customize behavior, e.g. To add\n   * a third speed option.\n   *\n   * @param candidateScrolls Existing list of candidate\n   *     scrolls. Will be modified in place.\n   * @param viewMetrics View metrics for the workspace.\n   * @param mouse Mouse coordinates.\n   */\n  protected computeBlockCandidateScrolls_(\n    candidateScrolls: CandidateScrolls,\n    viewMetrics: Blockly.MetricsManager.ContainerRegion,\n    mouse: Blockly.utils.Coordinate,\n  ): void {\n    const blockOverflows = this.getBlockBoundsOverflows_(viewMetrics, mouse);\n    for (const direction of this.scrollDirections_) {\n      const overflow = blockOverflows[direction];\n      if (overflow > ScrollBlockDragger.options.slowBlockStartDistance) {\n        const speed =\n          overflow > ScrollBlockDragger.options.fastBlockStartDistance\n            ? ScrollBlockDragger.options.fastBlockSpeed\n            : ScrollBlockDragger.options.slowBlockSpeed;\n        const scrollVector = this.SCROLL_DIRECTION_VECTORS_[direction]\n          .clone()\n          .scale(speed);\n        candidateScrolls[direction].push(scrollVector);\n      }\n    }\n  }\n\n  /**\n   * Gets the candidate scrolls based on the position of the mouse cursor\n   * relative to the workspace. If the mouse is near/over the edge, a\n   * candidate scroll will be added based on the options provided.\n   *\n   * This method can be overridden to further customize behavior, e.g. To add\n   * a third speed option.\n   *\n   * @param candidateScrolls Existing list of candidate\n   *     scrolls. Will be modified in place.\n   * @param viewMetrics View metrics for the workspace.\n   * @param mouse Mouse coordinates.\n   */\n  protected computeMouseCandidateScrolls_(\n    candidateScrolls: CandidateScrolls,\n    viewMetrics: Blockly.MetricsManager.ContainerRegion,\n    mouse: Blockly.utils.Coordinate,\n  ) {\n    const mouseOverflows = this.getMouseOverflows_(viewMetrics, mouse);\n    for (const direction of this.scrollDirections_) {\n      const overflow = mouseOverflows[direction];\n      if (overflow > ScrollBlockDragger.options.slowMouseStartDistance) {\n        const speed =\n          overflow > ScrollBlockDragger.options.fastMouseStartDistance\n            ? ScrollBlockDragger.options.fastMouseSpeed\n            : ScrollBlockDragger.options.slowMouseSpeed;\n        const scrollVector = this.SCROLL_DIRECTION_VECTORS_[direction]\n          .clone()\n          .scale(speed);\n        candidateScrolls[direction].push(scrollVector);\n      }\n    }\n  }\n\n  /**\n   * Gets the amount of overflow of a box relative to the workspace viewport.\n   *\n   * The value for each direction will be how far the given block edge is from\n   * the given edge of the viewport. If the block edge is outside the\n   * viewport, the value will be positive. If the block edge is inside the\n   * viewport, the value will be negative.\n   *\n   * This method also checks for oversized blocks. If the block is very large\n   * relative to the viewport size, then we will actually use a small zone\n   * around the cursor, rather than the edge of the block, to calculate the\n   * overflow values. This calculation is done independently in both the\n   * horizontal and vertical directions. These values can be configured in the\n   * options for the plugin.\n   *\n   * @param viewMetrics View metrics for the workspace.\n   * @param mouse Mouse coordinates.\n   */\n  protected getBlockBoundsOverflows_(\n    viewMetrics: Blockly.MetricsManager.ContainerRegion,\n    mouse: Blockly.utils.Coordinate,\n  ): {[key: string]: number} {\n    // This function shouldn't be called in the first place if the object\n    // isn't autoscrollable, but return some sane data anyway\n    if (!isAutoScrollable(this.draggable)) {\n      return {\n        top: 0,\n        bottom: 0,\n        left: 0,\n        right: 0,\n      };\n    }\n    const blockBounds = this.draggable.getBoundingRectangle();\n\n    // Handle large blocks. If the block is nearly as tall as the viewport,\n    // use a margin around the cursor rather than the height of the block.\n    const blockHeight = blockBounds.bottom - blockBounds.top;\n    if (\n      blockHeight >\n      viewMetrics.height * ScrollBlockDragger.options.oversizeBlockThreshold\n    ) {\n      blockBounds.top = Math.max(\n        blockBounds.top,\n        mouse.y - ScrollBlockDragger.options.oversizeBlockMargin,\n      );\n      blockBounds.bottom = Math.min(\n        blockBounds.bottom,\n        mouse.y + ScrollBlockDragger.options.oversizeBlockMargin,\n      );\n    }\n\n    // Same logic, but for block width.\n    const blockWidth = blockBounds.right - blockBounds.left;\n    if (\n      blockWidth >\n      viewMetrics.width * ScrollBlockDragger.options.oversizeBlockThreshold\n    ) {\n      blockBounds.left = Math.max(\n        blockBounds.left,\n        mouse.x - ScrollBlockDragger.options.oversizeBlockMargin,\n      );\n      blockBounds.right = Math.min(\n        blockBounds.right,\n        mouse.x + ScrollBlockDragger.options.oversizeBlockMargin,\n      );\n    }\n\n    // The coordinate system is negative in the top and left directions, and\n    // positive in the bottom and right directions. Therefore, the direction\n    // of the comparison must be switched for bottom and right.\n    return {\n      top: viewMetrics.top - blockBounds.top,\n      bottom: -(viewMetrics.top + viewMetrics.height - blockBounds.bottom),\n      left: viewMetrics.left - blockBounds.left,\n      right: -(viewMetrics.left + viewMetrics.width - blockBounds.right),\n    };\n  }\n\n  /**\n   * Gets the amount of overflow of the mouse coordinates relative to the\n   * viewport.\n   *\n   * The value for each direction will be how far the pointer is from\n   * the given edge of the viewport. If the pointer is outside the viewport,\n   * the value will be positive. If the pointer is inside the viewport, the\n   * value will be negative.\n   *\n   * @param viewMetrics View metrics\n   *     for the workspace.\n   * @param mouse Mouse coordinates.\n   * @returns An object describing the amount of\n   *     overflow in each direction.\n   */\n  protected getMouseOverflows_(\n    viewMetrics: Blockly.MetricsManager.ContainerRegion,\n    mouse: Blockly.utils.Coordinate,\n  ): {[key: string]: number} {\n    // The coordinate system is negative in the top and left directions, and\n    // positive in the bottom and right directions. Therefore, the direction\n    // of the comparison must be switched for bottom and right.\n    return {\n      top: viewMetrics.top - mouse.y,\n      bottom: -(viewMetrics.top + viewMetrics.height - mouse.y),\n      left: viewMetrics.left - mouse.x,\n      right: -(viewMetrics.left + viewMetrics.width - mouse.x),\n    };\n  }\n\n  /**\n   * Cancel any AutoScroll. This must be called when there is no need to\n   * scroll further, e.g., when no longer dragging near the edge of the\n   * workspace, or when no longer dragging at all.\n   */\n  stopAutoScrolling() {\n    if (this.activeAutoScroll_) {\n      this.activeAutoScroll_.stopAndDestroy();\n    }\n    this.activeAutoScroll_ = null;\n  }\n\n  /**\n   * Update the scroll options. Only the properties actually included in the\n   * `options` parameter will be set. Any unspecified options will use the\n   * previously set value (where the initial value is from `defaultOptions`).\n   * Therefore, do not pass in any options with explicit `undefined` or `null`\n   * values. The plugin will break. Just leave them out of the object if you\n   * don't want to change the default value.\n   *\n   * This method is safe to call multiple times. Subsequent calls will add onto\n   * previous calls, not completely overwrite them. That is, if you call this\n   * with:\n   *\n   * `updateOptions({fastMouseSpeed: 5});\n   * updateOptions({slowMouseSpeed: 2});`.\n   *\n   * Then the final options used will include both `fastMouseSpeed: 5` and\n   * `slowMouseSpeed: 2` with all other options being the default values.\n   *\n   * @param options Object containing any or all of\n   *     the available options. Any properties not present will use the existing\n   *     value.\n   */\n  static updateOptions = function (options: Partial<EdgeScrollOptions>) {\n    ScrollBlockDragger.options = {...ScrollBlockDragger.options, ...options};\n  };\n\n  /**\n   * Resets the options object to the default options.\n   */\n  static resetOptions = function () {\n    ScrollBlockDragger.options = defaultOptions;\n  };\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.BLOCK_DRAGGER,\n  'ScrollBlockDragger',\n  ScrollBlockDragger,\n);\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {EdgeScrollOptions, ScrollBlockDragger} from './ScrollBlockDragger';\nimport {getTranslation} from './utils';\nimport {isCacheable} from './ScrollMetricsManager';\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * A Blockly plugin that adds additional features related to scrolling and\n * dragging on workspaces. This plugin adds the ability to: a) use the\n * mousewheel to scroll the workspace while a block is being dragged, and b)\n * scroll the workspace automatically when a block is dragged near the edge.\n *\n * All behavior is customizable. See the README for more information.\n */\nexport class ScrollOptions {\n  protected workspace_: Blockly.WorkspaceSvg;\n\n  /** Bound event listener for the scroll wheel event. */\n  protected wheelEvent_: Blockly.browserEvents.Data | null = null;\n\n  /**\n   * Constructor for ScrollOptions plugin.\n   *\n   * @param workspace The workspace that the plugin will\n   *     be added to.\n   */\n  constructor(workspace: Blockly.WorkspaceSvg) {\n    this.workspace_ = workspace;\n  }\n\n  /**\n   * Initialize plugin with optional options. If no options are provided, both\n   * plugin features are enabled with default settings. The plugin is configured\n   * here as a convenience. See the README for more information on configuring\n   * the plugin after initialization.\n   *\n   * @param root0\n   * @param root0.enableWheelScroll\n   * @param root0.enableEdgeScroll\n   * @param root0.edgeScrollOptions\n   *\n   *  options The\n   * configuration options for the plugin. `enableWheelScroll` and\n   * `enableEdgeScroll` are both true by default and control whether the\n   * behavior to scroll with the mouse wheel while dragging and scroll when a\n   * block is near the edge of the workspace are enabled, respectively.\n   * `edgeScrollOptions` is an optional configuration for the edge scrolling\n   * behavior. See `ScrollBlockDrager.updateOptions` for more details.\n   */\n  init(\n    {\n      enableWheelScroll = true,\n      enableEdgeScroll = true,\n      edgeScrollOptions = undefined,\n    }:\n      | {\n          enableWheelScroll?: boolean;\n          enableEdgeScroll?: boolean;\n          edgeScrollOptions?: Partial<EdgeScrollOptions>;\n        }\n      | undefined = {\n      enableWheelScroll: true,\n      enableEdgeScroll: true,\n      edgeScrollOptions: undefined,\n    },\n  ) {\n    if (enableWheelScroll) {\n      this.enableWheelScroll();\n    } else {\n      this.disableWheelScroll();\n    }\n\n    ScrollBlockDragger.edgeScrollEnabled = enableEdgeScroll;\n\n    if (edgeScrollOptions) {\n      ScrollBlockDragger.updateOptions(edgeScrollOptions);\n    }\n  }\n\n  /**\n   * Enables scrolling with mousewheel during block drag.\n   */\n  enableWheelScroll() {\n    if (this.wheelEvent_) {\n      // Already enabled.\n      return;\n    }\n\n    // We need to attach the event listener to the drag surface in order\n    // to hear the wheel event while a drag is in progress.\n    // TODO(google/blockly#8135): Use the layer manager if possible.\n    const dragLayer = this.workspace_\n      .getInjectionDiv()\n      .getElementsByClassName('blocklyBlockDragSurface')[0];\n    if (!dragLayer) {\n      throw new Error(\n        `Can't attach wheel listener to nonexistent drag surface`,\n      );\n    }\n\n    this.wheelEvent_ = Blockly.browserEvents.conditionalBind(\n      dragLayer,\n      'wheel',\n      this,\n      this.onMouseWheel_,\n    );\n  }\n\n  /**\n   * Disables scrolling with mousewheel during block drag.\n   */\n  disableWheelScroll() {\n    if (!this.wheelEvent_) {\n      // Already disabled.\n      return;\n    }\n    Blockly.browserEvents.unbind(this.wheelEvent_);\n    this.wheelEvent_ = null;\n  }\n\n  /**\n   * Enables scrolling when block is dragged near edge.\n   */\n  enableEdgeScroll() {\n    ScrollBlockDragger.edgeScrollEnabled = true;\n  }\n\n  /**\n   * Disables scrolling when block is dragged near edge.\n   */\n  disableEdgeScroll() {\n    ScrollBlockDragger.edgeScrollEnabled = false;\n  }\n\n  /**\n   * Updates edge scroll options. See ScrollBlockDragger for specific settings.\n   * Any values left unspecified will not be overwritten and will retain their\n   * previous values.\n   *\n   * @param options Edge scroll options.\n   */\n  updateEdgeScrollOptions(options: Partial<EdgeScrollOptions>) {\n    ScrollBlockDragger.updateOptions(options);\n  }\n\n  /**\n   * Scrolls the workspace with the mousewheel while a block is being dragged.\n   * Translates the currently dragged block as the user scrolls the workspace,\n   * so that the block does not appear to move.\n   *\n   * @param e Mouse wheel event.\n   */\n  onMouseWheel_(e: WheelEvent) {\n    const canWheelMove =\n      this.workspace_.options.moveOptions &&\n      this.workspace_.options.moveOptions.wheel;\n    // All we want to do is get the currentGesture from the workspace so\n    // that we can get the dragger from it.\n    // getGesture expects a PointerEvent, but we don't have one. As long\n    // as the event we give it isn't a 'pointerdown' event, we'll get the\n    // current gesture if there is one, or null if there isn't.\n    // TODO(google/blockly#8133): Remove the parameter when possible.\n    const currentGesture = this.workspace_.getGesture(\n      e as unknown as PointerEvent,\n    );\n\n    const metricsManager = this.workspace_.getMetricsManager();\n    if (!isCacheable(metricsManager)) {\n      console.warn(\n        'MetricsManager must be able to cache metrics in order to use AutoScroll',\n      );\n      return;\n    }\n\n    const dragger = currentGesture?.getCurrentDragger();\n\n    // Do not try to scroll if we are not dragging a block, or the workspace\n    // does not allow moving by wheel, or our dragger is not capable of this.\n    if (\n      !canWheelMove ||\n      !currentGesture ||\n      !(dragger instanceof ScrollBlockDragger)\n    ) {\n      return;\n    }\n\n    // Figure out the desired location to scroll to.\n    const scrollDelta = Blockly.browserEvents.getScrollDeltaPixels(e);\n    if (e.shiftKey) {\n      // Scroll horizontally (based on vertical scroll delta).\n      const temp = scrollDelta.x;\n      scrollDelta.x = scrollDelta.y;\n      scrollDelta.y = temp;\n    }\n    const x = this.workspace_.scrollX - scrollDelta.x;\n    const y = this.workspace_.scrollY - scrollDelta.y;\n\n    const oldLocation = getTranslation(this.workspace_);\n\n    // Try to scroll to the desired location.\n    metricsManager.useCachedContentMetrics = true;\n    this.workspace_.scroll(x, y);\n    metricsManager.useCachedContentMetrics = false;\n\n    const newLocation = getTranslation(this.workspace_);\n\n    // How much we actually ended up scrolling.\n    const deltaX = newLocation.x - oldLocation.x;\n    const deltaY = newLocation.y - oldLocation.y;\n\n    if (deltaX || deltaY) {\n      dragger.moveBlockWhileDragging(deltaX, deltaY);\n      e.preventDefault();\n    }\n  }\n}\n\nexport * from './ScrollBlockDragger';\nexport * from './ScrollMetricsManager';\nexport * from './AutoScrollable';\n"],
  "mappings": "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",
  "names": []
}
