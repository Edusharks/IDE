import {
  MetricsManager,
  browserEvents,
  dragging,
  registry,
  utils
} from "./chunk-YGIJMPNG.js";
import "./chunk-37NJYYKB.js";
import "./chunk-PLDDJCW6.js";

// node_modules/@blockly/plugin-scroll-options/src/ScrollMetricsManager.ts
var ScrollMetricsManager = class extends MetricsManager {
  /**
   * Whether to stop recalculating content metrics and used the cached value
   * instead. Note that if there are no cached metrics, they will be
   * recalculated even if this value is true.
   */
  useCachedContentMetrics = false;
  /**
   * Cached content metrics, if available.
   */
  contentMetrics = null;
  /** @override */
  getContentMetrics() {
    if (this.useCachedContentMetrics && this.contentMetrics) {
      return this.contentMetrics;
    }
    this.contentMetrics = super.getContentMetrics();
    return this.contentMetrics;
  }
};
function isCacheable(metricsManager) {
  return metricsManager.useCachedContentMetrics !== void 0;
}

// node_modules/@blockly/plugin-scroll-options/src/utils.ts
var getTranslation = (ws) => {
  const translation = ws.svgBlockCanvas_.getAttribute("transform");
  if (!translation)
    throw new Error(`svgBlockCanvas has no attribute 'transform'`);
  const splitted = translation.split(",");
  const x = Number(splitted[0].split("(")[1]);
  const y = Number(splitted[1].split(")")[0]);
  return new utils.Coordinate(x, y);
};

// node_modules/@blockly/plugin-scroll-options/src/AutoScroll.ts
var AutoScroll = class {
  /** Workspace to scroll. */
  workspace_;
  dragger;
  /**
   * Current active vector representing scroll velocity in pixels per
   * millisecond in each direction.
   */
  activeScrollVector_ = new utils.Coordinate(0, 0);
  /** ID of active requestAnimationFrame callback key. */
  animationFrameId_ = 0;
  /** Time in ms last animation frame was run. */
  lastTime_ = Date.now();
  /**
   * Whether the scroll animation should continue. If this is false, the next
   * animation frame will not be requested.
   */
  shouldAnimate_ = false;
  /**
   * Creates an AutoScroll instance for a specified workspace.
   *
   * @param workspace Workspace to scroll.
   * @param dragger The dragger that's currently dragging.
   * @constructor
   */
  constructor(workspace, dragger) {
    this.workspace_ = workspace;
    this.dragger = dragger;
  }
  /**
   * Cancels the current autoscroll and resets properties.
   */
  stopAndDestroy() {
    this.activeScrollVector_ = new utils.Coordinate(0, 0);
    this.shouldAnimate_ = false;
    cancelAnimationFrame(this.animationFrameId_);
    this.animationFrameId_ = 0;
  }
  /**
   * Ticks scrolling behavior and triggers another
   * frame request.
   *
   * @param now Current time in ms. This is usually passed
   *     automatically by `requestAnimationFrame`.
   */
  nextAnimationStep_(now) {
    if (this.shouldAnimate_) {
      const delta = now - this.lastTime_;
      this.lastTime_ = now;
      if (delta > 0) {
        this.scrollTick_(delta);
      }
      this.animationFrameId_ = requestAnimationFrame(
        (time) => this.nextAnimationStep_(time)
      );
    }
  }
  /**
   * Perform scroll given time passed.
   *
   * @param msPassed Number of ms since last scroll tick.
   */
  scrollTick_(msPassed) {
    const scrollDx = this.activeScrollVector_.x * msPassed;
    const scrollDy = this.activeScrollVector_.y * msPassed;
    this.scrollWorkspaceWithBlock(scrollDx, scrollDy);
  }
  /**
   * Scrolls the workspace the given amount during a block drag.
   * Also updates the dragger based on the amount actually scrolled.
   *
   * @param scrollDx Amount to scroll in horizontal direction.
   * @param scrollDy Amount to scroll in vertical direction.
   */
  scrollWorkspaceWithBlock(scrollDx, scrollDy) {
    const oldLocation = getTranslation(this.workspace_);
    const metricsManager = this.workspace_.getMetricsManager();
    if (!isCacheable(metricsManager)) {
      console.warn(
        "MetricsManager must be able to cache metrics in order to use AutoScroll"
      );
      return;
    }
    metricsManager.useCachedContentMetrics = true;
    const newX = this.workspace_.scrollX + scrollDx;
    const newY = this.workspace_.scrollY + scrollDy;
    this.workspace_.scroll(newX, newY);
    metricsManager.useCachedContentMetrics = false;
    const newLocation = getTranslation(this.workspace_);
    const deltaX = newLocation.x - oldLocation.x;
    const deltaY = newLocation.y - oldLocation.y;
    if (deltaX || deltaY) {
      this.dragger.moveBlockWhileDragging(deltaX, deltaY);
    }
  }
  /**
   * Updates the scroll vector for the current autoscroll and begins the
   * animation if needed.
   *
   * @param scrollVector New scroll velocity vector
   *     in pixels per ms.
   */
  updateProperties(scrollVector) {
    this.activeScrollVector_ = scrollVector;
    this.shouldAnimate_ = true;
    if (this.animationFrameId_ == 0) {
      this.lastTime_ = Date.now();
      this.nextAnimationStep_(this.lastTime_);
    }
  }
};

// node_modules/@blockly/plugin-scroll-options/src/AutoScrollable.ts
function isAutoScrollable(draggable) {
  return typeof draggable.getBoundingRectangle === "function";
}

// node_modules/@blockly/plugin-scroll-options/src/ScrollBlockDragger.ts
var defaultOptions = {
  slowBlockSpeed: 0.28,
  fastBlockSpeed: 1.4,
  slowBlockStartDistance: 0,
  fastBlockStartDistance: 50,
  oversizeBlockThreshold: 0.85,
  oversizeBlockMargin: 15,
  slowMouseSpeed: 0.5,
  fastMouseSpeed: 1.6,
  slowMouseStartDistance: 0,
  fastMouseStartDistance: 35
};
var ScrollBlockDragger = class _ScrollBlockDragger extends dragging.Dragger {
  /** How much the block has been moved due to scrolling. */
  scrollDelta_ = new utils.Coordinate(0, 0);
  /** How much the block has been moved due to dragging. */
  dragDelta_ = new utils.Coordinate(0, 0);
  // TODO(maribethb): Use `isMoveable` etc. to get this list
  /** Possible directions the workspace could be scrolled. */
  scrollDirections_ = [
    "top",
    "bottom",
    "left",
    "right"
  ];
  /**
   * Unit vector for each direction that could be scrolled. This vector will
   * be scaled to get the calculated velocity in each direction.
   */
  SCROLL_DIRECTION_VECTORS_ = {
    top: new utils.Coordinate(0, 1),
    bottom: new utils.Coordinate(0, -1),
    left: new utils.Coordinate(1, 0),
    right: new utils.Coordinate(-1, 0)
  };
  activeAutoScroll_ = null;
  /**
   * Whether the behavior to scroll the workspace when a block is dragged near
   * the edge is enabled.
   */
  static edgeScrollEnabled = true;
  /** Configuration options for the scroll-options settings. */
  static options = defaultOptions;
  /**
   * Updates the location of the block that is being dragged.
   *
   * @param deltaX Horizontal offset in pixel units.
   * @param deltaY Vertical offset in pixel units.
   */
  moveBlockWhileDragging(deltaX, deltaY) {
    if (!isAutoScrollable(this.draggable)) return;
    this.scrollDelta_.x -= deltaX;
    this.scrollDelta_.y -= deltaY;
    const totalDelta = utils.Coordinate.sum(
      this.scrollDelta_,
      this.dragDelta_
    );
    const delta = this.pixelsToWorkspaceUnits(totalDelta);
    const newLoc = utils.Coordinate.sum(this.startLoc, delta);
    this.draggable.drag(newLoc);
  }
  /**
   * Passes the total amount the block has moved (both from dragging and from
   * scrolling) since it was picked up.
   *
   * @override
   */
  onDrag(e, dragDelta) {
    const totalDelta = utils.Coordinate.sum(
      this.scrollDelta_,
      dragDelta
    );
    super.onDrag(e, totalDelta);
    this.dragDelta_ = dragDelta;
    if (_ScrollBlockDragger.edgeScrollEnabled) {
      this.scrollWorkspaceWhileDragging_(e);
    }
  }
  /**
   * @override
   */
  onDragEnd(e) {
    super.onDragEnd(e);
    this.stopAutoScrolling();
  }
  /**
   * May scroll the workspace as a block is dragged.
   * If a block is dragged near the edge of the workspace, this method will
   * cause the workspace to scroll in the direction the block is being
   * dragged. The workspace will not resize as the block is dragged. The
   * workspace should appear to move out from under the block, i.e., the block
   * should stay under the user's mouse.
   *
   * @param e The mouse/touch event for the drag.
   */
  scrollWorkspaceWhileDragging_(e) {
    if (!isAutoScrollable(this.draggable)) return;
    const mouse = utils.svgMath.screenToWsCoordinates(
      this.workspace,
      new utils.Coordinate(e.clientX, e.clientY)
    );
    const candidateScrolls = {
      top: [],
      bottom: [],
      left: [],
      right: []
    };
    const viewMetrics = this.workspace.getMetricsManager().getViewMetrics(true);
    this.computeBlockCandidateScrolls_(candidateScrolls, viewMetrics, mouse);
    this.computeMouseCandidateScrolls_(candidateScrolls, viewMetrics, mouse);
    const overallScrollVector = this.getOverallScrollVector_(candidateScrolls);
    if (utils.Coordinate.equals(
      overallScrollVector,
      new utils.Coordinate(0, 0)
    )) {
      this.stopAutoScrolling();
      return;
    }
    this.activeAutoScroll_ = this.activeAutoScroll_ || new AutoScroll(this.workspace, this);
    this.activeAutoScroll_.updateProperties(overallScrollVector);
  }
  /**
   * There could be multiple candidate scrolls for each direction, such as one
   * for block position and one for mouse position. We should first find the
   * fastest scroll in each direction. Then, we sum those to find the overall
   * scroll vector.
   *
   * For example, we may have a fast block scroll and a slow
   * mouse scroll candidate in both the top and left directions. First, we
   * reduce to only the fast block scroll. Then, we sum the vectors in each
   * direction to get a resulting fast scroll in a diagonal direction to the
   * top left.
   *
   * @param candidateScrolls Existing lists of candidate
   *     scrolls. Will be modified in place.
   * @returns Overall scroll vector.
   */
  getOverallScrollVector_(candidateScrolls) {
    let overallScrollVector = new utils.Coordinate(0, 0);
    for (const direction of this.scrollDirections_) {
      const fastestScroll = candidateScrolls[direction].reduce(
        (fastest, current) => {
          if (!fastest) {
            return current;
          }
          return utils.Coordinate.magnitude(fastest) > utils.Coordinate.magnitude(current) ? fastest : current;
        },
        new utils.Coordinate(0, 0)
      );
      overallScrollVector = utils.Coordinate.sum(
        overallScrollVector,
        fastestScroll
      );
    }
    return overallScrollVector;
  }
  /**
   * Gets the candidate scrolls based on the position of the block on the
   * workspace. If the block is near/over the edge, a candidate scroll will be
   * added based on the options provided.
   *
   * This method can be overridden to further customize behavior, e.g. To add
   * a third speed option.
   *
   * @param candidateScrolls Existing list of candidate
   *     scrolls. Will be modified in place.
   * @param viewMetrics View metrics for the workspace.
   * @param mouse Mouse coordinates.
   */
  computeBlockCandidateScrolls_(candidateScrolls, viewMetrics, mouse) {
    const blockOverflows = this.getBlockBoundsOverflows_(viewMetrics, mouse);
    for (const direction of this.scrollDirections_) {
      const overflow = blockOverflows[direction];
      if (overflow > _ScrollBlockDragger.options.slowBlockStartDistance) {
        const speed = overflow > _ScrollBlockDragger.options.fastBlockStartDistance ? _ScrollBlockDragger.options.fastBlockSpeed : _ScrollBlockDragger.options.slowBlockSpeed;
        const scrollVector = this.SCROLL_DIRECTION_VECTORS_[direction].clone().scale(speed);
        candidateScrolls[direction].push(scrollVector);
      }
    }
  }
  /**
   * Gets the candidate scrolls based on the position of the mouse cursor
   * relative to the workspace. If the mouse is near/over the edge, a
   * candidate scroll will be added based on the options provided.
   *
   * This method can be overridden to further customize behavior, e.g. To add
   * a third speed option.
   *
   * @param candidateScrolls Existing list of candidate
   *     scrolls. Will be modified in place.
   * @param viewMetrics View metrics for the workspace.
   * @param mouse Mouse coordinates.
   */
  computeMouseCandidateScrolls_(candidateScrolls, viewMetrics, mouse) {
    const mouseOverflows = this.getMouseOverflows_(viewMetrics, mouse);
    for (const direction of this.scrollDirections_) {
      const overflow = mouseOverflows[direction];
      if (overflow > _ScrollBlockDragger.options.slowMouseStartDistance) {
        const speed = overflow > _ScrollBlockDragger.options.fastMouseStartDistance ? _ScrollBlockDragger.options.fastMouseSpeed : _ScrollBlockDragger.options.slowMouseSpeed;
        const scrollVector = this.SCROLL_DIRECTION_VECTORS_[direction].clone().scale(speed);
        candidateScrolls[direction].push(scrollVector);
      }
    }
  }
  /**
   * Gets the amount of overflow of a box relative to the workspace viewport.
   *
   * The value for each direction will be how far the given block edge is from
   * the given edge of the viewport. If the block edge is outside the
   * viewport, the value will be positive. If the block edge is inside the
   * viewport, the value will be negative.
   *
   * This method also checks for oversized blocks. If the block is very large
   * relative to the viewport size, then we will actually use a small zone
   * around the cursor, rather than the edge of the block, to calculate the
   * overflow values. This calculation is done independently in both the
   * horizontal and vertical directions. These values can be configured in the
   * options for the plugin.
   *
   * @param viewMetrics View metrics for the workspace.
   * @param mouse Mouse coordinates.
   */
  getBlockBoundsOverflows_(viewMetrics, mouse) {
    if (!isAutoScrollable(this.draggable)) {
      return {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
    }
    const blockBounds = this.draggable.getBoundingRectangle();
    const blockHeight = blockBounds.bottom - blockBounds.top;
    if (blockHeight > viewMetrics.height * _ScrollBlockDragger.options.oversizeBlockThreshold) {
      blockBounds.top = Math.max(
        blockBounds.top,
        mouse.y - _ScrollBlockDragger.options.oversizeBlockMargin
      );
      blockBounds.bottom = Math.min(
        blockBounds.bottom,
        mouse.y + _ScrollBlockDragger.options.oversizeBlockMargin
      );
    }
    const blockWidth = blockBounds.right - blockBounds.left;
    if (blockWidth > viewMetrics.width * _ScrollBlockDragger.options.oversizeBlockThreshold) {
      blockBounds.left = Math.max(
        blockBounds.left,
        mouse.x - _ScrollBlockDragger.options.oversizeBlockMargin
      );
      blockBounds.right = Math.min(
        blockBounds.right,
        mouse.x + _ScrollBlockDragger.options.oversizeBlockMargin
      );
    }
    return {
      top: viewMetrics.top - blockBounds.top,
      bottom: -(viewMetrics.top + viewMetrics.height - blockBounds.bottom),
      left: viewMetrics.left - blockBounds.left,
      right: -(viewMetrics.left + viewMetrics.width - blockBounds.right)
    };
  }
  /**
   * Gets the amount of overflow of the mouse coordinates relative to the
   * viewport.
   *
   * The value for each direction will be how far the pointer is from
   * the given edge of the viewport. If the pointer is outside the viewport,
   * the value will be positive. If the pointer is inside the viewport, the
   * value will be negative.
   *
   * @param viewMetrics View metrics
   *     for the workspace.
   * @param mouse Mouse coordinates.
   * @returns An object describing the amount of
   *     overflow in each direction.
   */
  getMouseOverflows_(viewMetrics, mouse) {
    return {
      top: viewMetrics.top - mouse.y,
      bottom: -(viewMetrics.top + viewMetrics.height - mouse.y),
      left: viewMetrics.left - mouse.x,
      right: -(viewMetrics.left + viewMetrics.width - mouse.x)
    };
  }
  /**
   * Cancel any AutoScroll. This must be called when there is no need to
   * scroll further, e.g., when no longer dragging near the edge of the
   * workspace, or when no longer dragging at all.
   */
  stopAutoScrolling() {
    if (this.activeAutoScroll_) {
      this.activeAutoScroll_.stopAndDestroy();
    }
    this.activeAutoScroll_ = null;
  }
  /**
   * Update the scroll options. Only the properties actually included in the
   * `options` parameter will be set. Any unspecified options will use the
   * previously set value (where the initial value is from `defaultOptions`).
   * Therefore, do not pass in any options with explicit `undefined` or `null`
   * values. The plugin will break. Just leave them out of the object if you
   * don't want to change the default value.
   *
   * This method is safe to call multiple times. Subsequent calls will add onto
   * previous calls, not completely overwrite them. That is, if you call this
   * with:
   *
   * `updateOptions({fastMouseSpeed: 5});
   * updateOptions({slowMouseSpeed: 2});`.
   *
   * Then the final options used will include both `fastMouseSpeed: 5` and
   * `slowMouseSpeed: 2` with all other options being the default values.
   *
   * @param options Object containing any or all of
   *     the available options. Any properties not present will use the existing
   *     value.
   */
  static updateOptions = function(options) {
    _ScrollBlockDragger.options = { ..._ScrollBlockDragger.options, ...options };
  };
  /**
   * Resets the options object to the default options.
   */
  static resetOptions = function() {
    _ScrollBlockDragger.options = defaultOptions;
  };
};
registry.register(
  registry.Type.BLOCK_DRAGGER,
  "ScrollBlockDragger",
  ScrollBlockDragger
);

// node_modules/@blockly/plugin-scroll-options/src/index.ts
var ScrollOptions = class {
  workspace_;
  /** Bound event listener for the scroll wheel event. */
  wheelEvent_ = null;
  /**
   * Constructor for ScrollOptions plugin.
   *
   * @param workspace The workspace that the plugin will
   *     be added to.
   */
  constructor(workspace) {
    this.workspace_ = workspace;
  }
  /**
   * Initialize plugin with optional options. If no options are provided, both
   * plugin features are enabled with default settings. The plugin is configured
   * here as a convenience. See the README for more information on configuring
   * the plugin after initialization.
   *
   * @param root0
   * @param root0.enableWheelScroll
   * @param root0.enableEdgeScroll
   * @param root0.edgeScrollOptions
   *
   *  options The
   * configuration options for the plugin. `enableWheelScroll` and
   * `enableEdgeScroll` are both true by default and control whether the
   * behavior to scroll with the mouse wheel while dragging and scroll when a
   * block is near the edge of the workspace are enabled, respectively.
   * `edgeScrollOptions` is an optional configuration for the edge scrolling
   * behavior. See `ScrollBlockDrager.updateOptions` for more details.
   */
  init({
    enableWheelScroll = true,
    enableEdgeScroll = true,
    edgeScrollOptions = void 0
  } = {
    enableWheelScroll: true,
    enableEdgeScroll: true,
    edgeScrollOptions: void 0
  }) {
    if (enableWheelScroll) {
      this.enableWheelScroll();
    } else {
      this.disableWheelScroll();
    }
    ScrollBlockDragger.edgeScrollEnabled = enableEdgeScroll;
    if (edgeScrollOptions) {
      ScrollBlockDragger.updateOptions(edgeScrollOptions);
    }
  }
  /**
   * Enables scrolling with mousewheel during block drag.
   */
  enableWheelScroll() {
    if (this.wheelEvent_) {
      return;
    }
    const dragLayer = this.workspace_.getInjectionDiv().getElementsByClassName("blocklyBlockDragSurface")[0];
    if (!dragLayer) {
      throw new Error(
        `Can't attach wheel listener to nonexistent drag surface`
      );
    }
    this.wheelEvent_ = browserEvents.conditionalBind(
      dragLayer,
      "wheel",
      this,
      this.onMouseWheel_
    );
  }
  /**
   * Disables scrolling with mousewheel during block drag.
   */
  disableWheelScroll() {
    if (!this.wheelEvent_) {
      return;
    }
    browserEvents.unbind(this.wheelEvent_);
    this.wheelEvent_ = null;
  }
  /**
   * Enables scrolling when block is dragged near edge.
   */
  enableEdgeScroll() {
    ScrollBlockDragger.edgeScrollEnabled = true;
  }
  /**
   * Disables scrolling when block is dragged near edge.
   */
  disableEdgeScroll() {
    ScrollBlockDragger.edgeScrollEnabled = false;
  }
  /**
   * Updates edge scroll options. See ScrollBlockDragger for specific settings.
   * Any values left unspecified will not be overwritten and will retain their
   * previous values.
   *
   * @param options Edge scroll options.
   */
  updateEdgeScrollOptions(options) {
    ScrollBlockDragger.updateOptions(options);
  }
  /**
   * Scrolls the workspace with the mousewheel while a block is being dragged.
   * Translates the currently dragged block as the user scrolls the workspace,
   * so that the block does not appear to move.
   *
   * @param e Mouse wheel event.
   */
  onMouseWheel_(e) {
    const canWheelMove = this.workspace_.options.moveOptions && this.workspace_.options.moveOptions.wheel;
    const currentGesture = this.workspace_.getGesture(
      e
    );
    const metricsManager = this.workspace_.getMetricsManager();
    if (!isCacheable(metricsManager)) {
      console.warn(
        "MetricsManager must be able to cache metrics in order to use AutoScroll"
      );
      return;
    }
    const dragger = currentGesture?.getCurrentDragger();
    if (!canWheelMove || !currentGesture || !(dragger instanceof ScrollBlockDragger)) {
      return;
    }
    const scrollDelta = browserEvents.getScrollDeltaPixels(e);
    if (e.shiftKey) {
      const temp = scrollDelta.x;
      scrollDelta.x = scrollDelta.y;
      scrollDelta.y = temp;
    }
    const x = this.workspace_.scrollX - scrollDelta.x;
    const y = this.workspace_.scrollY - scrollDelta.y;
    const oldLocation = getTranslation(this.workspace_);
    metricsManager.useCachedContentMetrics = true;
    this.workspace_.scroll(x, y);
    metricsManager.useCachedContentMetrics = false;
    const newLocation = getTranslation(this.workspace_);
    const deltaX = newLocation.x - oldLocation.x;
    const deltaY = newLocation.y - oldLocation.y;
    if (deltaX || deltaY) {
      dragger.moveBlockWhileDragging(deltaX, deltaY);
      e.preventDefault();
    }
  }
};
export {
  ScrollBlockDragger,
  ScrollMetricsManager,
  ScrollOptions,
  isAutoScrollable,
  isCacheable
};
/*! Bundled license information:

@blockly/plugin-scroll-options/src/ScrollMetricsManager.ts:
@blockly/plugin-scroll-options/src/AutoScroll.ts:
@blockly/plugin-scroll-options/src/ScrollBlockDragger.ts:
@blockly/plugin-scroll-options/src/index.ts:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

@blockly/plugin-scroll-options/src/utils.ts:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

@blockly/plugin-scroll-options/src/AutoScrollable.ts:
  (**
   * @license
   * Copyright 2024 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=@blockly_plugin-scroll-options.js.map
