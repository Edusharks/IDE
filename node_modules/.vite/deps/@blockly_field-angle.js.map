{
  "version": 3,
  "sources": ["webpack://@blockly/field-angle/webpack/universalModuleDefinition", "webpack://@blockly/field-angle/external%20umd%20%7B%22root%22:%22Blockly%22,%22commonjs%22:%22blockly/core%22,%22commonjs2%22:%22blockly/core%22,%22amd%22:%22blockly/core%22%7D", "webpack://@blockly/field-angle/webpack/bootstrap", "webpack://@blockly/field-angle/webpack/runtime/define%20property%20getters", "webpack://@blockly/field-angle/webpack/runtime/hasOwnProperty%20shorthand", "webpack://@blockly/field-angle/webpack/runtime/make%20namespace%20object", "webpack://@blockly/field-angle/src/field_angle.ts"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__370__) => {\nreturn ", "module.exports = __WEBPACK_EXTERNAL_MODULE__370__;", "// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n", "// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};", "__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))", "// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Angle input field.\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Class for an editable angle field.\n */\nexport class FieldAngle extends Blockly.FieldNumber {\n  /** Half the width of protractor image. */\n  static readonly HALF = 100 / 2;\n\n  /**\n   * Radius of protractor circle.  Slightly smaller than protractor size since\n   * otherwise SVG crops off half the border at the edges.\n   */\n  static readonly RADIUS: number = FieldAngle.HALF - 1;\n\n  /* eslint-disable @typescript-eslint/naming-convention */\n  static readonly DEFAULT_PRECISION = 15;\n  static readonly DEFAULT_MIN = 0;\n  static readonly DEFAULT_MAX = 360;\n  /* eslint-enable @typescript-eslint/naming-convention */\n\n  /**\n   * Whether the angle should increase as the angle picker is moved clockwise\n   * (true) or counterclockwise (false).\n   */\n  private clockwise = false;\n\n  /**\n   * The angle (in degrees) at which displayMin is pointed.  Always in the\n   * counterclockwise direction, regardless of the field's clockwise property.\n   * Usually either 0 (0 = right) or 90 (0 = up).\n   */\n  private offset = 0;\n\n  /**\n   * Smallest value displayed on the gauge.  Usually 0 or -180.\n   */\n  private displayMin = 0;\n\n  /**\n   * Largest value displayed on the gauge.  Usually 360 or 180.\n   */\n  private displayMax = 360;\n\n  /**\n   * Distance between minor tick marks on dial.  Zero to disable.\n   * If displayMin/Max span 360, then majorTick would usually be 15.\n   * May not be negative.\n   */\n  private minorTick = 15;\n\n  /**\n   * Distance between major tick marks on dial.  Zero to disable.\n   * If displayMin/Max span 360, then majorTick would usually be 45.\n   * May not be negative.\n   */\n  private majorTick = 45;\n\n  /**\n   * Unit symbol to append to the number when not being edited.\n   */\n  private symbol = '°';\n\n  /**\n   * Array holding info needed to unbind events.\n   * Used for disposing.\n   * Ex: [[node, name, func], [node, name, func]].\n   */\n  private boundEvents: Blockly.browserEvents.Data[] = [];\n\n  /** Dynamic red line pointing at the value's angle. */\n  private line: SVGLineElement | null = null;\n\n  /** Dynamic pink area extending from 0 to the value's angle. */\n  private gauge: SVGPathElement | null = null;\n\n  /** The degree symbol for this field. */\n  protected symbolElement: SVGTSpanElement | null = null;\n\n  /**\n   * @param value The initial value of the field.  Should cast to a number.\n   *     Defaults to 0.  Also accepts Field.SKIP_SETUP if you wish to skip setup\n   *     (only used by subclasses that want to handle configuration and setting\n   *     the field value after their own constructors have run).\n   * @param validator A function that is called to validate changes to the\n   *     field's value.  Takes in a number & returns a validated number, or null\n   *     to abort the change.\n   * @param config A map of options used to configure the field.\n   *     See the [field creation documentation]{@link\n   * https://developers.google.com/blockly/guides/create-custom-blocks/fields/built-in-fields/angle#creation}\n   * for a list of properties this parameter supports.\n   */\n  constructor(\n    value?: string | number | typeof Blockly.Field.SKIP_SETUP,\n    validator?: FieldAngleValidator,\n    config?: FieldAngleConfig,\n  ) {\n    super(Blockly.Field.SKIP_SETUP);\n\n    if (value === Blockly.Field.SKIP_SETUP) return;\n    if (config) {\n      this.configure_(config);\n      if (config.min === undefined || config.min === null) {\n        this.setMin(FieldAngle.DEFAULT_MIN);\n      }\n      if (config.max === undefined || config.max === null) {\n        this.setMax(FieldAngle.DEFAULT_MAX);\n      }\n      if (config.precision === undefined || config.precision === null) {\n        this.setPrecision(FieldAngle.DEFAULT_PRECISION);\n      }\n    } else {\n      this.setMin(FieldAngle.DEFAULT_MIN);\n      this.setMax(FieldAngle.DEFAULT_MAX);\n      this.setPrecision(FieldAngle.DEFAULT_PRECISION);\n    }\n    this.setValue(value);\n    if (validator) {\n      this.setValidator(validator);\n    }\n  }\n\n  /**\n   * Configure the field based on the given map of options.\n   *\n   * @param config A map of options to configure the field based on.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  protected override configure_(config: FieldAngleConfig) {\n    super.configure_(config);\n    switch (config.mode) {\n      case Mode.COMPASS:\n        this.clockwise = true;\n        this.offset = 90;\n        break;\n      case Mode.PROTRACTOR:\n        // This is the default mode, so we could do nothing.  But just to\n        // future-proof, we'll set it anyway.\n        this.clockwise = false;\n        this.offset = 0;\n        break;\n    }\n\n    // Allow individual settings to override the mode setting.\n    if (config.clockwise !== undefined) this.clockwise = config.clockwise;\n    if (config.offset !== undefined) this.offset = config.offset;\n    if (config.displayMin !== undefined) this.displayMin = config.displayMin;\n    if (config.displayMax !== undefined) this.displayMax = config.displayMax;\n    if (config.minorTick !== undefined) this.minorTick = config.minorTick;\n    if (config.majorTick !== undefined) this.majorTick = config.majorTick;\n    if (config.symbol !== undefined) this.symbol = config.symbol;\n\n    // Sanity check the inputs.\n    if (this.displayMin >= this.displayMax) {\n      throw Error('Display min must be larger than display max');\n    }\n    if (this.minorTick < 0 || this.majorTick < 0) {\n      throw Error('Ticks cannot be negative');\n    }\n  }\n\n  /**\n   * Create the block UI for this field.\n   *\n   * @internal\n   */\n  override initView() {\n    super.initView();\n    if (this.symbol) {\n      // Add the degree symbol to the left of the number,\n      // even in RTL (https://github.com/google/blockly/issues/2380).\n      this.symbolElement = Blockly.utils.dom.createSvgElement(\n        Blockly.utils.Svg.TSPAN,\n        {},\n      );\n      this.symbolElement.appendChild(document.createTextNode(this.symbol));\n      this.getTextElement().appendChild(this.symbolElement);\n    }\n  }\n\n  /**\n   * Updates the angle when the field rerenders.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  protected override render_() {\n    super.render_();\n    this.updateGraph();\n  }\n\n  /**\n   * Create and show the angle field's editor.\n   *\n   * @param e Optional mouse event that triggered the field to open,\n   *     or undefined if triggered programmatically.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  protected override showEditor_(e?: Event) {\n    // Mobile browsers have issues with in-line textareas (focus & keyboards).\n    // Also, don't let the parent take ephemeral focus since the drop-down div\n    // below will handle it, instead.\n    const noFocus =\n      Blockly.utils.userAgent.MOBILE ||\n      Blockly.utils.userAgent.ANDROID ||\n      Blockly.utils.userAgent.IPAD;\n    super.showEditor_(e, noFocus, false);\n\n    const editor = this.dropdownCreate();\n    Blockly.DropDownDiv.getContentDiv().appendChild(editor);\n\n    const sourceBlock = this.getSourceBlock();\n    if (sourceBlock instanceof Blockly.BlockSvg) {\n      Blockly.DropDownDiv.setColour(\n        sourceBlock.style.colourPrimary,\n        sourceBlock.style.colourTertiary,\n      );\n    }\n\n    Blockly.DropDownDiv.showPositionedByField(\n      this,\n      this.dropdownDispose.bind(this),\n    );\n\n    this.updateGraph();\n  }\n\n  /**\n   * Creates the angle dropdown editor.\n   *\n   * @returns The newly created slider.\n   */\n  private dropdownCreate(): SVGSVGElement {\n    const svg = Blockly.utils.dom.createSvgElement(Blockly.utils.Svg.SVG, {\n      'xmlns': Blockly.utils.dom.SVG_NS,\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      'xmlns:html': Blockly.utils.dom.HTML_NS,\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      'xmlns:xlink': Blockly.utils.dom.XLINK_NS,\n      'version': '1.1',\n      'height': FieldAngle.HALF * 2 + 'px',\n      'width': FieldAngle.HALF * 2 + 'px',\n    });\n    svg.style.touchAction = 'none';\n    const circle = Blockly.utils.dom.createSvgElement(\n      Blockly.utils.Svg.CIRCLE,\n      {\n        cx: FieldAngle.HALF,\n        cy: FieldAngle.HALF,\n        r: FieldAngle.RADIUS,\n        class: 'blocklyAngleCircle',\n      },\n      svg,\n    );\n    this.gauge = Blockly.utils.dom.createSvgElement(\n      Blockly.utils.Svg.PATH,\n      {\n        class: 'blocklyAngleGauge',\n      },\n      svg,\n    );\n    this.line = Blockly.utils.dom.createSvgElement(\n      Blockly.utils.Svg.LINE,\n      {\n        x1: FieldAngle.HALF,\n        y1: FieldAngle.HALF,\n        class: 'blocklyAngleLine',\n      },\n      svg,\n    );\n\n    // Draw markers around the edge.\n    const minValueDegrees = Blockly.utils.math.toDegrees(\n      this.fieldAngleToRadians(this.min_),\n    );\n    const maxValueDegrees = Blockly.utils.math.toDegrees(\n      this.fieldAngleToRadians(this.max_),\n    );\n\n    /**\n     * Draw a set of ticks on the gauge.\n     *\n     * @param tickAngle Angle between each tick.\n     * @param length Length of the tick (minor=5, major=10).\n     */\n    const drawTicks = (tickAngle: number, length: number) => {\n      let min = Math.ceil(minValueDegrees / tickAngle) * tickAngle;\n      let max = Math.floor(maxValueDegrees / tickAngle) * tickAngle;\n\n      if (this.clockwise) {\n        if (min < max) {\n          min += 360;\n        }\n      } else {\n        if (min > max) {\n          max += 360;\n        }\n      }\n      if (max === min) {\n        // Technically this could actually be zero, but more likely it's whole.\n        max += 360;\n      }\n      if (min > max) {\n        [min, max] = [max, min];\n      }\n      for (let angle = min; angle <= max; angle += tickAngle) {\n        Blockly.utils.dom.createSvgElement(\n          Blockly.utils.Svg.LINE,\n          {\n            x1: FieldAngle.HALF + FieldAngle.RADIUS,\n            y1: FieldAngle.HALF,\n            x2: FieldAngle.HALF + FieldAngle.RADIUS - length,\n            y2: FieldAngle.HALF,\n            class: 'blocklyAngleMarks',\n            transform:\n              'rotate(' +\n              -angle +\n              ',' +\n              FieldAngle.HALF +\n              ',' +\n              FieldAngle.HALF +\n              ')',\n          },\n          svg,\n        );\n      }\n    };\n\n    const displayRange = this.displayMax - this.displayMin;\n    const minorTickAngle = (360 / displayRange) * this.minorTick;\n    if (minorTickAngle) {\n      drawTicks(minorTickAngle, 5);\n    }\n    const majorTickAngle = (360 / displayRange) * this.majorTick;\n    if (majorTickAngle) {\n      drawTicks(majorTickAngle, 10);\n    }\n\n    // The angle picker is different from other fields in that it updates on\n    // mousemove even if it's not in the middle of a drag.  In future we may\n    // change this behaviour.\n    this.boundEvents.push(\n      Blockly.browserEvents.conditionalBind(svg, 'click', this, this.hide),\n    );\n    // On touch devices, the picker's value is only updated with a drag.  Add\n    // a click handler on the drag surface to update the value if the surface\n    // is clicked.\n    this.boundEvents.push(\n      Blockly.browserEvents.conditionalBind(\n        circle,\n        'pointerdown',\n        this,\n        this.onMouseMove_,\n        true,\n      ),\n    );\n    this.boundEvents.push(\n      Blockly.browserEvents.conditionalBind(\n        circle,\n        'pointermove',\n        this,\n        this.onMouseMove_,\n        true,\n      ),\n    );\n    return svg;\n  }\n\n  /**\n   * Disposes of events belonging to the angle editor.\n   */\n  private dropdownDispose() {\n    for (const event of this.boundEvents) {\n      Blockly.browserEvents.unbind(event);\n    }\n    this.boundEvents.length = 0;\n    this.gauge = null;\n    this.line = null;\n  }\n\n  /** Hide the editor. */\n  private hide() {\n    Blockly.DropDownDiv.hideIfOwner(this);\n    Blockly.WidgetDiv.hide();\n  }\n\n  /**\n   * Set the angle to match the mouse's position.\n   *\n   * @param e Mouse move event.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  protected onMouseMove_(e: PointerEvent) {\n    // Calculate angle.\n    const bBox = this.gauge?.ownerSVGElement?.getBoundingClientRect();\n    if (!bBox) {\n      // This can't happen, but TypeScript thinks it can and lint forbids `!.`.\n      return;\n    }\n    const dx = e.clientX - bBox.left - FieldAngle.HALF;\n    const dy = e.clientY - bBox.top - FieldAngle.HALF;\n    let angle = Math.atan2(-dy, dx);\n    if (isNaN(angle)) {\n      // This shouldn't happen, but let's not let this error propagate further.\n      return;\n    }\n    angle = this.radiansToFieldAngle(angle);\n    this.displayMouseOrKeyboardValue(angle);\n  }\n\n  /**\n   * Convert an on-screen angle into a value for this field.\n   *\n   * @param angle Radians where 0: East, π/2: North, π or -π: West, -π/2: South.\n   * @returns Angle value for this field, scaled and offset as specified.\n   */\n  private radiansToFieldAngle(angle: number): number {\n    // Convert angle from radians (-π to π) to turns (-0.5 to 0.5).\n    angle /= 2 * Math.PI;\n    // Compensate for offset.\n    angle -= this.offset / 360;\n    // Flip if clockwise.\n    if (this.clockwise) {\n      angle *= -1;\n    }\n    // Normalize to positive.\n    angle %= 1;\n    if (angle < 0) {\n      angle += 1;\n    }\n    // Convert angle from turns (0.0 to 1.0) to the display min/max range.\n    angle *= this.displayMax - this.displayMin;\n    angle += this.displayMin;\n    return angle;\n  }\n\n  /**\n   * Convert a value for this field into an on-screen angle.\n   *\n   * @param angle Angle value for this field, scaled and offset as specified.\n   * @returns Radians where 0: East, π/2: North, π or -π: West, -π/2: South.\n   */\n  private fieldAngleToRadians(angle: number): number {\n    // Convert angle from the display min/max range to turns (0.0 to 1.0).\n    angle -= this.displayMin;\n    angle /= this.displayMax - this.displayMin;\n    // Flip if clockwise.\n    if (this.clockwise) {\n      angle *= -1;\n    }\n    // Compensate for offset.\n    angle += this.offset / 360;\n    // Normalize to span equally across zero (-0.5 to 0.5).\n    angle %= 1;\n    if (angle > 0.5) {\n      angle -= 1;\n    }\n    if (angle < -0.5) {\n      angle += 1;\n    }\n    // Convert angle from turns to radians.\n    angle *= 2 * Math.PI;\n    return angle;\n  }\n\n  /**\n   * Handles and displays values that are input via mouse or arrow key input.\n   * These values need to be rounded and wrapped before being displayed so\n   * that the text input's value is appropriate.\n   *\n   * @param angle New angle.\n   */\n  private displayMouseOrKeyboardValue(angle: number) {\n    const validAngle = this.doClassValidation_(angle);\n    if (validAngle !== null && validAngle !== this.value_) {\n      // Intermediate value changes from user input are not confirmed until the\n      // user closes the editor, and may be numerous. Inhibit reporting these as\n      // normal block change events, and instead report them as special\n      // intermediate changes that do not get recorded in undo history.\n      const oldValue = this.value_;\n      this.setEditorValue_(validAngle, false);\n      if (\n        this.sourceBlock_ &&\n        Blockly.Events.isEnabled() &&\n        this.value_ !== oldValue\n      ) {\n        Blockly.Events.fire(\n          new (Blockly.Events.get(\n            Blockly.Events.BLOCK_FIELD_INTERMEDIATE_CHANGE,\n          ))(this.sourceBlock_, this.name || null, oldValue, this.value_),\n        );\n      }\n    }\n  }\n\n  /** Redraw the graph with the current angle. */\n  private updateGraph() {\n    if (!this.gauge || !this.line) {\n      return;\n    }\n    let angle = Number(this.getText());\n    if (isNaN(angle)) {\n      // This shouldn't happen, but let's not let this error propagate further.\n      return;\n    }\n    angle = this.fieldAngleToRadians(angle);\n\n    let path = `M ${FieldAngle.HALF},${FieldAngle.HALF}`;\n    let x2 = FieldAngle.HALF;\n    let y2 = FieldAngle.HALF;\n    if (!isNaN(angle)) {\n      const angle1 = Blockly.utils.math.toRadians(this.offset);\n      const x1 = Math.cos(angle1) * FieldAngle.RADIUS;\n      const y1 = Math.sin(angle1) * -FieldAngle.RADIUS;\n      x2 += Math.cos(angle) * FieldAngle.RADIUS;\n      y2 -= Math.sin(angle) * FieldAngle.RADIUS;\n      // Don't ask how the flag calculations work.  They just do.\n      const clockwiseFlag = Number(this.clockwise);\n      let largeFlag = Math.abs(Math.floor((angle - angle1) / Math.PI) % 2);\n      if (clockwiseFlag) {\n        largeFlag = 1 - largeFlag;\n      }\n      path +=\n        ` l ${x1},${y1} A ${FieldAngle.RADIUS},${FieldAngle.RADIUS} 0 ` +\n        `${largeFlag} ${clockwiseFlag} ${x2},${y2} z`;\n    }\n    this.gauge.setAttribute('d', path);\n    this.line.setAttribute('x2', `${x2}`);\n    this.line.setAttribute('y2', `${y2}`);\n  }\n\n  /**\n   * Handle key down to the editor.\n   *\n   * @param e Keyboard event.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  protected override onHtmlInputKeyDown_(e: KeyboardEvent) {\n    super.onHtmlInputKeyDown_(e);\n    const block = this.getSourceBlock();\n    if (!block) {\n      throw new Error(\n        'The field has not yet been attached to its input. ' +\n          'Call appendField to attach it.',\n      );\n    }\n\n    let multiplier = 0;\n    switch (e.key) {\n      case 'ArrowLeft':\n        // decrement (increment in RTL)\n        multiplier = block.RTL ? 1 : -1;\n        break;\n      case 'ArrowRight':\n        // increment (decrement in RTL)\n        multiplier = block.RTL ? -1 : 1;\n        break;\n      case 'ArrowDown':\n        // decrement\n        multiplier = -1;\n        break;\n      case 'ArrowUp':\n        // increment\n        multiplier = 1;\n        break;\n    }\n    if (multiplier) {\n      const value = this.getValue() as number;\n      this.displayMouseOrKeyboardValue(value + multiplier * this.precision_);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }\n\n  /**\n   * Ensure that the input value is a valid angle.\n   *\n   * @param newValue The input value.\n   * @returns A valid angle, or null if invalid.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  protected override doClassValidation_(\n    newValue: number,\n  ): number | null | undefined;\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  protected override doClassValidation_(newValue?: number): number | null;\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  protected override doClassValidation_(\n    newValue?: number,\n  ): number | null | undefined {\n    // The obvious approach would be to call super.doClassValidation_ to handle\n    // min/max limitations.  However angle pickers out of range need to clamp\n    // to the closest min/max point, which may involve a wrap to the opposite\n    // end of the numeric scale.\n    // E.g. min/max is 0/180 on a 0/360 display, and value is 365.\n    // FieldNumber would clamp 365 to max (180), but 0 is closer on the dial.\n    if (newValue === null) {\n      return null;\n    }\n    let value = Number(newValue);\n    if (isNaN(value) || !isFinite(value)) {\n      return null;\n    }\n    // Get the value in range.\n    value = this.wrapValue(value);\n    // Round to nearest multiple of precision.\n    if (this.precision_) {\n      value = Math.round(value / this.precision_) * this.precision_;\n    }\n    // Deal with 6.6000000000000005 IEEE float errors.\n    // Clean up floating point errors.\n    value = Number(value.toFixed(10));\n    // Clamp the value between min and max, noting wrapping.\n    const displayRange = this.displayMax - this.displayMin;\n    const valueRange = this.max_ - this.min_;\n    if (value < this.min_) {\n      const undershoot = this.min_ - value;\n      const overshoot = displayRange - undershoot - valueRange;\n      value = undershoot < overshoot ? this.min_ : this.max_;\n    }\n    if (value > this.max_) {\n      const overshoot = value - this.max_;\n      const undershoot = displayRange - overshoot - valueRange;\n      value = undershoot < overshoot ? this.min_ : this.max_;\n    }\n    return value;\n  }\n\n  /**\n   * Wraps the value so that it is in the min/max display range (e.g. 0 to 360).\n   *\n   * @param value The value to wrap.\n   * @returns The wrapped value.\n   */\n  private wrapValue(value: number): number {\n    const displayRange = this.displayMax - this.displayMin;\n    value %= displayRange;\n    while (value < this.displayMin) {\n      value += displayRange;\n    }\n    while (value >= this.displayMax) {\n      value -= displayRange;\n    }\n    return value;\n  }\n\n  /**\n   * Construct a FieldAngle from a JSON arg object.\n   *\n   * @param options A JSON object with options\n   *     (value, mode, clockwise, offset, min, max, precision).\n   * @returns The new field instance.\n   * @nocollapse\n   * @internal\n   */\n  static fromJson(options: FieldAngleFromJsonConfig): FieldAngle {\n    // `this` might be a subclass of FieldAngle if that class doesn't override\n    // the static fromJson method.\n    return new this(options.value, undefined, options);\n  }\n}\n\n/** Register the field and any dependencies. */\nexport function registerFieldAngle() {\n  Blockly.fieldRegistry.register('field_angle', FieldAngle);\n}\n\nFieldAngle.prototype.DEFAULT_VALUE = 0;\n\n/**\n * CSS for angle field.\n */\nBlockly.Css.register(`\n.blocklyAngleCircle {\n  stroke: #444;\n  stroke-width: 1;\n  fill: #ddd;\n  fill-opacity: 0.8;\n}\n\n.blocklyAngleMarks {\n  stroke: #444;\n  stroke-width: 1;\n}\n\n.blocklyAngleGauge {\n  fill: #f88;\n  fill-opacity: 0.8;\n  pointer-events: none;\n}\n\n.blocklyAngleLine {\n  stroke: #f00;\n  stroke-width: 2;\n  stroke-linecap: round;\n  pointer-events: none;\n}\n`);\n\n/**\n * The two main modes of the angle field.\n * Compass specifies:\n *   - clockwise: true\n *   - offset: 90\n *   - min: 0\n *   - max: 360\n *   - precision: 15\n *   - displayMin: 0\n *   - displayMax: 360\n *   - minorTick: 15\n *   - majorTick: 45\n *   - symbol: '°'\n *\n * Protractor specifies:\n *   - clockwise: false\n *   - offset: 0\n *   - min: 0\n *   - max: 360\n *   - precision: 15\n *   - displayMin: 0\n *   - displayMax: 360\n *   - minorTick: 15\n *   - majorTick: 45\n *   - symbol: '°'\n */\nexport enum Mode {\n  COMPASS = 'compass',\n  PROTRACTOR = 'protractor',\n}\n\n/**\n * Extra configuration options for the angle field.\n */\nexport interface FieldAngleConfig extends Blockly.FieldNumberConfig {\n  mode?: Mode;\n  clockwise?: boolean;\n  offset?: number;\n  displayMin?: number;\n  displayMax?: number;\n  minorTick?: number;\n  majorTick?: number;\n  symbol?: string;\n}\n\n/**\n * fromJson configuration options for the angle field.\n */\nexport interface FieldAngleFromJsonConfig extends FieldAngleConfig {\n  value?: number;\n}\n\n/**\n * A function that is called to validate changes to the field's value before\n * they are set.\n *\n * @see {@link https://developers.google.com/blockly/guides/create-custom-blocks/fields/validators#return_values}\n * @param newValue The value to be validated.\n * @returns One of three instructions for setting the new value: `T`, `null`,\n * or `undefined`.\n *\n * - `T` to set this function's returned value instead of `newValue`.\n *\n * - `null` to invoke `doValueInvalid_` and not set a value.\n *\n * - `undefined` to set `newValue` as is.\n */\nexport type FieldAngleValidator = Blockly.FieldNumberValidator;\n"],
  "mappings": ";;;;;;;;;;MAAA,SAA2CA,GAAMC,GAAAA;AAChD,UAAsB,YAAA,OAAZC,WAA0C,YAAA,OAAXC,OACxCA,QAAOD,UAAUD,EAAQG,4BAAQ;eACR,cAAA,OAAXC,UAAyBA,OAAOC,IAC9CD,QAAO,CAAC,cAAA,GAAiBJ,CAAAA;WACrB;AACJ,YAAIM,IAAuB,YAAA,OAAZL,UAAuBD,EAAQG,4BAAQ,IAAmBH,EAAQD,EAAc,OAAA;AAC/F,iBAAQQ,KAAKD,EAAAA,EAAuB,YAAA,OAAZL,UAAuBA,UAAUF,GAAMQ,CAAAA,IAAKD,EAAEC,CAAAA;MACvE;IACA,GAAEC,SAAOC,QAAAA,MAAAA;AAAAA;AAAAA,UAAAA,IAAAA,EAAAA,KAAAA,CAAAA,OAAAA;ACTVP,QAAAA,GAAOD,UAAUQ;MAAAA,EAAAA,GCCbC,IAA2B,CAAC;AAGhC,eAASC,EAAoBC,IAAAA;AAE5B,YAAIC,KAAeH,EAAyBE,EAAAA;AAC5C,YAAA,WAAIC,GACH,QAAOA,GAAaZ;AAGrB,YAAIC,KAASQ,EAAyBE,EAAAA,IAAY,EAGjDX,SAAS,CAAC,EAAA;AAOX,eAHAa,EAAoBF,EAAAA,EAAUV,IAAQA,GAAOD,SAASU,CAAAA,GAG/CT,GAAOD;MACf;ACrBAU,QAAoBI,IAAI,CAACd,IAASe,OAAAA;AACjC,iBAAQC,MAAOD,GACXL,GAAoBO,EAAEF,IAAYC,EAAAA,KAAAA,CAASN,EAAoBO,EAAEjB,IAASgB,EAAAA,KAC5EE,OAAOC,eAAenB,IAASgB,IAAK,EAAEI,YAAAA,MAAkBC,KAAKN,GAAWC,EAAAA,EAAAA,CAAAA;MAAAA,GCJ3EN,EAAoBO,IAAI,CAACK,IAAKC,OAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,IAAKC,EAAAA,GCClFb,EAAoBiB,IAAK3B,CAAAA,OAAAA;AACH,uBAAA,OAAX4B,UAA0BA,OAAOC,eAC1CX,OAAOC,eAAenB,IAAS4B,OAAOC,aAAa,EAAEC,OAAO,SAAA,CAAA,GAE7DZ,OAAOC,eAAenB,IAAS,cAAc,EAAE8B,OAAAA,KAAO,CAAA;MAAA;AAAA,UAAA,IAAA,CAAA;AAAA,QAAA,EAAA,CAAA,GAAA,EAAA,EAAA,GAAA,EAAA,YAAA,MAAA,GAAA,MAAA,MAAA,GAAA,oBAAA,MAAA,EAAA,CAAA;AAAA,UCwtB3CC,GAAAA,IAAAA,EAAAA,GAAAA;MA9sBL,MAAMC,UAAmB,EAAA,YAAA;QAuF9B,YACEF,IACAG,IACAC,IAAAA;AAEAC,gBAAM,EAAA,MAAcC,UAAAA,GAxEd,KAAAC,YAAAA,OAOA,KAAAC,SAAS,GAKT,KAAAC,aAAa,GAKb,KAAAC,aAAa,KAOb,KAAAC,YAAY,IAOZ,KAAAC,YAAY,IAKZ,KAAAC,SAAS,KAOT,KAAAC,cAA4C,CAAA,GAG5C,KAAAC,OAA8B,MAG9B,KAAAC,QAA+B,MAG7B,KAAAC,gBAAwC,MAsB5CjB,OAAU,EAAA,MAAcM,eACxBF,MACF3B,KAAKyC,WAAWd,EAAAA,GAAAA,WACZA,GAAOe,OAAoC,SAAff,GAAOe,OACrC1C,KAAK2C,OAAOlB,EAAWmB,WAAAA,GAAAA,WAErBjB,GAAOkB,OAAoC,SAAflB,GAAOkB,OACrC7C,KAAK8C,OAAOrB,EAAWsB,WAAAA,GAAAA,WAErBpB,GAAOqB,aAAgD,SAArBrB,GAAOqB,aAC3ChD,KAAKiD,aAAaxB,EAAWyB,iBAAAA,MAG/BlD,KAAK2C,OAAOlB,EAAWmB,WAAAA,GACvB5C,KAAK8C,OAAOrB,EAAWsB,WAAAA,GACvB/C,KAAKiD,aAAaxB,EAAWyB,iBAAAA,IAE/BlD,KAAKmD,SAAS5B,EAAAA,GACVG,MACF1B,KAAKoD,aAAa1B,EAAAA;QAEtB;QAQmB,WAAWC,IAAAA;AAE5B,kBADAC,MAAMa,WAAWd,EAAAA,GACTA,GAAO0B,MAAAA;YACb,KAAK7B,EAAK8B;AACRtD,mBAAK8B,YAAAA,MACL9B,KAAK+B,SAAS;AACd;YACF,KAAKP,EAAK+B;AAGRvD,mBAAK8B,YAAAA,OACL9B,KAAK+B,SAAS;UAAA;AAclB,cAAA,WATIJ,GAAOG,cAAyB9B,KAAK8B,YAAYH,GAAOG,YAAAA,WACxDH,GAAOI,WAAsB/B,KAAK+B,SAASJ,GAAOI,SAAAA,WAClDJ,GAAOK,eAA0BhC,KAAKgC,aAAaL,GAAOK,aAAAA,WAC1DL,GAAOM,eAA0BjC,KAAKiC,aAAaN,GAAOM,aAAAA,WAC1DN,GAAOO,cAAyBlC,KAAKkC,YAAYP,GAAOO,YAAAA,WACxDP,GAAOQ,cAAyBnC,KAAKmC,YAAYR,GAAOQ,YAAAA,WACxDR,GAAOS,WAAsBpC,KAAKoC,SAAST,GAAOS,SAGlDpC,KAAKgC,cAAchC,KAAKiC,WAC1B,OAAMuB,MAAM,6CAAA;AAEd,cAAIxD,KAAKkC,YAAY,KAAKlC,KAAKmC,YAAY,EACzC,OAAMqB,MAAM,0BAAA;QAEhB;QAOS,WAAAC;AACP7B,gBAAM6B,SAAAA,GACFzD,KAAKoC,WAGPpC,KAAKwC,gBAAgB,EAAA,MAAckB,IAAIC,iBACrC,EAAA,MAAcC,IAAIC,OAClB,CAAC,CAAA,GAEH7D,KAAKwC,cAAcsB,YAAYC,SAASC,eAAehE,KAAKoC,MAAAA,CAAAA,GAC5DpC,KAAKiE,eAAAA,EAAiBH,YAAY9D,KAAKwC,aAAAA;QAE3C;QAMmB,UAAA0B;AACjBtC,gBAAMsC,QAAAA,GACNlE,KAAKmE,YAAAA;QACP;QASmB,YAAYC,IAAAA;AAI7B,gBAAMC,KACJ,EAAA,MAAcC,UAAUC,UACxB,EAAA,MAAcD,UAAUE,WACxB,EAAA,MAAcF,UAAUG;AAC1B7C,gBAAM8C,YAAYN,IAAGC,IAAAA,KAAS;AAE9B,gBAAMM,KAAS3E,KAAK4E,eAAAA;AACpB,YAAA,YAAoBC,cAAAA,EAAgBf,YAAYa,EAAAA;AAEhD,gBAAMG,KAAc9E,KAAK+E,eAAAA;AACrBD,UAAAA,cAAuB,EAAA,YACzB,EAAA,YAAoBE,UAClBF,GAAYG,MAAMC,eAClBJ,GAAYG,MAAME,cAAAA,GAItB,EAAA,YAAoBC,sBAClBpF,MACAA,KAAKqF,gBAAgBC,KAAKtF,IAAAA,CAAAA,GAG5BA,KAAKmE,YAAAA;QACP;QAOQ,iBAAAS;AACN,gBAAMW,KAAM,EAAA,MAAc7B,IAAIC,iBAAiB,EAAA,MAAcC,IAAI4B,KAAK,EACpE,OAAS,EAAA,MAAc9B,IAAI+B,QAE3B,cAAc,EAAA,MAAc/B,IAAIgC,SAEhC,eAAe,EAAA,MAAchC,IAAIiC,UACjC,SAAW,OACX,QAA4B,IAAlBlE,EAAWmE,OAAW,MAChC,OAA2B,IAAlBnE,EAAWmE,OAAW,KAAA,CAAA;AAEjCL,UAAAA,GAAIN,MAAMY,cAAc;AACxB,gBAAMC,KAAS,EAAA,MAAcpC,IAAIC,iBAC/B,EAAA,MAAcC,IAAImC,QAClB,EACEC,IAAIvE,EAAWmE,MACfK,IAAIxE,EAAWmE,MACfxE,GAAGK,EAAWyE,QACdC,OAAO,qBAAA,GAETZ,EAAAA;AAEFvF,eAAKuC,QAAQ,EAAA,MAAcmB,IAAIC,iBAC7B,EAAA,MAAcC,IAAIwC,MAClB,EACED,OAAO,oBAAA,GAETZ,EAAAA,GAEFvF,KAAKsC,OAAO,EAAA,MAAcoB,IAAIC,iBAC5B,EAAA,MAAcC,IAAIyC,MAClB,EACEC,IAAI7E,EAAWmE,MACfW,IAAI9E,EAAWmE,MACfO,OAAO,mBAAA,GAETZ,EAAAA;AAIF,gBAAMiB,KAAkB,EAAA,MAAcC,KAAKC,UACzC1G,KAAK2G,oBAAoB3G,KAAK4G,IAAAA,CAAAA,GAE1BC,KAAkB,EAAA,MAAcJ,KAAKC,UACzC1G,KAAK2G,oBAAoB3G,KAAK8G,IAAAA,CAAAA,GAS1BC,KAAY,CAACC,IAAmBC,OAAAA;AACpC,gBAAIvE,KAAMwE,KAAKC,KAAKX,KAAkBQ,EAAAA,IAAaA,IAC/CnE,KAAMqE,KAAKE,MAAMP,KAAkBG,EAAAA,IAAaA;AAEhDhH,iBAAK8B,YACHY,KAAMG,OACRH,MAAO,OAGLA,KAAMG,OACRA,MAAO,MAGPA,OAAQH,OAEVG,MAAO,MAELH,KAAMG,OAAAA,CACPH,IAAKG,EAAAA,IAAO,CAACA,IAAKH,EAAAA;AAErB,qBAAS2E,KAAQ3E,IAAK2E,MAASxE,IAAKwE,MAASL,GAC3C,GAAA,MAActD,IAAIC,iBAChB,EAAA,MAAcC,IAAIyC,MAClB,EACEC,IAAI7E,EAAWmE,OAAOnE,EAAWyE,QACjCK,IAAI9E,EAAWmE,MACf0B,IAAI7F,EAAWmE,OAAOnE,EAAWyE,SAASe,IAC1CM,IAAI9F,EAAWmE,MACfO,OAAO,qBACPqB,WACE,YAAA,CACCH,KACD,MACA5F,EAAWmE,OACX,MACAnE,EAAWmE,OACX,IAAA,GAEJL,EAAAA;UAAAA,GAKAkC,KAAezH,KAAKiC,aAAajC,KAAKgC,YACtC0F,KAAkB,MAAMD,KAAgBzH,KAAKkC;AAC/CwF,UAAAA,MACFX,GAAUW,IAAgB,CAAA;AAE5B,gBAAMC,IAAkB,MAAMF,KAAgBzH,KAAKmC;AAgCnD,iBA/BIwF,KACFZ,GAAUY,GAAgB,EAAA,GAM5B3H,KAAKqC,YAAYuF,KACf,EAAA,cAAsBC,gBAAgBtC,IAAK,SAASvF,MAAMA,KAAK8H,IAAAA,CAAAA,GAKjE9H,KAAKqC,YAAYuF,KACf,EAAA,cAAsBC,gBACpB/B,IACA,eACA9F,MACAA,KAAK+H,cAAAA,IACL,CAAA,GAGJ/H,KAAKqC,YAAYuF,KACf,EAAA,cAAsBC,gBACpB/B,IACA,eACA9F,MACAA,KAAK+H,cAAAA,IACL,CAAA,GAGGxC;QACT;QAKQ,kBAAAF;AACN,qBAAW2C,MAAShI,KAAKqC,YACvB,GAAA,cAAsB4F,OAAOD,EAAAA;AAE/BhI,eAAKqC,YAAY4E,SAAS,GAC1BjH,KAAKuC,QAAQ,MACbvC,KAAKsC,OAAO;QACd;QAGQ,OAAAwF;AACN,YAAA,YAAoBI,YAAYlI,IAAAA,GAChC,EAAA,UAAkB8H,KAAAA;QACpB;QAQU,aAAa1D,IAAAA;AAAAA,cAAAA,IAAAA;AAErB,gBAAM+D,KAAkC,UAA3B/D,KAAU,UAAVrE,KAAAC,KAAKuC,UAAAA,WAAKxC,KAAA,SAAAA,GAAEqI,oBAAAA,WAAehE,KAAA,SAAAA,GAAEiE,sBAAAA;AAC1C,cAAA,CAAKF,GAEH;AAEF,gBAAMG,KAAKlE,GAAEmE,UAAUJ,GAAKK,OAAO/G,EAAWmE,MACxC6C,KAAKrE,GAAEsE,UAAUP,GAAKQ,MAAMlH,EAAWmE;AAC7C,cAAIyB,KAAQH,KAAK0B,MAAAA,CAAOH,IAAIH,EAAAA;AACxBO,gBAAMxB,EAAAA,MAIVA,KAAQrH,KAAK8I,oBAAoBzB,EAAAA,GACjCrH,KAAK+I,4BAA4B1B,EAAAA;QACnC;QAQQ,oBAAoBA,IAAAA;AAiB1B,iBAfAA,MAAS,IAAIH,KAAK8B,IAElB3B,MAASrH,KAAK+B,SAAS,KAEnB/B,KAAK8B,cACPuF,MAAAA,MAGFA,MAAS,KACG,MACVA,MAAS,KAGXA,MAASrH,KAAKiC,aAAajC,KAAKgC,cACvBhC,KAAKgC;QAEhB;QAQQ,oBAAoBqF,IAAAA;AAoB1B,iBAlBAA,MAASrH,KAAKgC,YACdqF,MAASrH,KAAKiC,aAAajC,KAAKgC,YAE5BhC,KAAK8B,cACPuF,MAAAA,KAGFA,MAASrH,KAAK+B,SAAS,MAEvBsF,MAAS,KACG,QACVA,MAAS,IAEPA,KAAAA,SACFA,MAAS,IAGXA,MAAS,IAAIH,KAAK8B;QAEpB;QASQ,4BAA4B3B,IAAAA;AAClC,gBAAM4B,KAAajJ,KAAKkJ,mBAAmB7B,EAAAA;AAC3C,cAAmB,SAAf4B,MAAuBA,OAAejJ,KAAKmJ,QAAQ;AAKrD,kBAAMC,KAAWpJ,KAAKmJ;AACtBnJ,iBAAKqJ,gBAAgBJ,IAAAA,KAAY,GAE/BjJ,KAAKsJ,gBACL,EAAA,OAAeC,UAAAA,KACfvJ,KAAKmJ,WAAWC,MAEhB,EAAA,OAAeI,KACb,KAAK,EAAA,OAAe1I,IAClB,EAAA,OAAe2I,+BAAAA,GACdzJ,KAAKsJ,cAActJ,KAAK0J,QAAQ,MAAMN,IAAUpJ,KAAKmJ,MAAAA,CAAAA;UAG9D;QACF;QAGQ,cAAAhF;AACN,cAAA,CAAKnE,KAAKuC,SAAAA,CAAUvC,KAAKsC,KACvB;AAEF,cAAI+E,KAAQsC,OAAO3J,KAAK4J,QAAAA,CAAAA;AACxB,cAAIf,MAAMxB,EAAAA,EAER;AAEFA,UAAAA,KAAQrH,KAAK2G,oBAAoBU,EAAAA;AAEjC,cAAIwC,KAAO,KAAKpI,EAAWmE,IAAAA,IAAQnE,EAAWmE,IAAAA,IAC1C0B,KAAK7F,EAAWmE,MAChB2B,KAAK9F,EAAWmE;AACpB,cAAA,CAAKiD,MAAMxB,EAAAA,GAAQ;AACjB,kBAAMyC,KAAS,EAAA,MAAcrD,KAAKsD,UAAU/J,KAAK+B,MAAAA,GAC3CuE,KAAKY,KAAK8C,IAAIF,EAAAA,IAAUrI,EAAWyE,QACnCK,KAAKW,KAAK+C,IAAIH,EAAAA,IAAAA,CAAWrI,EAAWyE;AAC1CoB,YAAAA,MAAMJ,KAAK8C,IAAI3C,EAAAA,IAAS5F,EAAWyE,QACnCqB,MAAML,KAAK+C,IAAI5C,EAAAA,IAAS5F,EAAWyE;AAEnC,kBAAMgE,IAAgBP,OAAO3J,KAAK8B,SAAAA;AAClC,gBAAIqI,IAAYjD,KAAKkD,IAAIlD,KAAKE,OAAOC,KAAQyC,MAAU5C,KAAK8B,EAAAA,IAAM,CAAA;AAC9DkB,kBACFC,IAAY,IAAIA,IAElBN,MACE,MAAMvD,EAAAA,IAAMC,EAAAA,MAAQ9E,EAAWyE,MAAAA,IAAUzE,EAAWyE,MAAAA,MACjDiE,CAAAA,IAAaD,CAAAA,IAAiB5C,EAAAA,IAAMC,EAAAA;UAC3C;AACAvH,eAAKuC,MAAM8H,aAAa,KAAKR,EAAAA,GAC7B7J,KAAKsC,KAAK+H,aAAa,MAAM,GAAG/C,EAAAA,EAAAA,GAChCtH,KAAKsC,KAAK+H,aAAa,MAAM,GAAG9C,EAAAA,EAAAA;QAClC;QAQmB,oBAAoBnD,IAAAA;AACrCxC,gBAAM0I,oBAAoBlG,EAAAA;AAC1B,gBAAMmG,KAAQvK,KAAK+E,eAAAA;AACnB,cAAA,CAAKwF,GACH,OAAM,IAAI/G,MACR,kFAAA;AAKJ,cAAIgH,KAAa;AACjB,kBAAQpG,GAAE3D,KAAAA;YACR,KAAK;AAEH+J,cAAAA,KAAaD,GAAME,MAAM,IAAA;AACzB;YACF,KAAK;AAEHD,cAAAA,KAAaD,GAAME,MAAAA,KAAW;AAC9B;YACF,KAAK;AAEHD,cAAAA,KAAAA;AACA;YACF,KAAK;AAEHA,cAAAA,KAAa;UAAA;AAGjB,cAAIA,IAAY;AACd,kBAAMjJ,KAAQvB,KAAK0K,SAAAA;AACnB1K,iBAAK+I,4BAA4BxH,KAAQiJ,KAAaxK,KAAK2K,UAAAA,GAC3DvG,GAAEwG,eAAAA,GACFxG,GAAEyG,gBAAAA;UACJ;QACF;QAemB,mBACjBC,IAAAA;AAQA,cAAiB,SAAbA,GACF,QAAO;AAET,cAAIvJ,KAAQoI,OAAOmB,EAAAA;AACnB,cAAIjC,MAAMtH,EAAAA,KAAAA,CAAWwJ,SAASxJ,EAAAA,EAC5B,QAAO;AAGTA,UAAAA,KAAQvB,KAAKgL,UAAUzJ,EAAAA,GAEnBvB,KAAK2K,eACPpJ,KAAQ2F,KAAK+D,MAAM1J,KAAQvB,KAAK2K,UAAAA,IAAc3K,KAAK2K,aAIrDpJ,KAAQoI,OAAOpI,GAAM2J,QAAQ,EAAA,CAAA;AAE7B,gBAAMzD,KAAezH,KAAKiC,aAAajC,KAAKgC,YACtCmJ,KAAanL,KAAK8G,OAAO9G,KAAK4G;AACpC,cAAIrF,KAAQvB,KAAK4G,MAAM;AACrB,kBAAMwE,KAAapL,KAAK4G,OAAOrF;AAE/BA,YAAAA,KAAQ6J,KADU3D,KAAe2D,KAAaD,KACbnL,KAAK4G,OAAO5G,KAAK8G;UACpD;AACA,cAAIvF,KAAQvB,KAAK8G,MAAM;AACrB,kBAAMuE,KAAY9J,KAAQvB,KAAK8G;AAE/BvF,YAAAA,KADmBkG,KAAe4D,KAAYF,KACzBE,KAAYrL,KAAK4G,OAAO5G,KAAK8G;UACpD;AACA,iBAAOvF;QACT;QAQQ,UAAUA,IAAAA;AAChB,gBAAMkG,KAAezH,KAAKiC,aAAajC,KAAKgC;AAE5C,eADAT,MAASkG,IACFlG,KAAQvB,KAAKgC,aAClBT,CAAAA,MAASkG;AAEX,iBAAOlG,MAASvB,KAAKiC,aACnBV,CAAAA,MAASkG;AAEX,iBAAOlG;QACT;QAWA,OAAA,SAAgB+J,IAAAA;AAGd,iBAAO,IAAItL,KAAKsL,GAAQ/J,OAAAA,QAAkB+J,EAAAA;QAC5C;MAAA;AAIK,eAASC,IAAAA;AACd,UAAA,cAAsBC,SAAS,eAAe/J,CAAAA;MAChD;AAAA,aAhpBkB,EAAAmE,OAAO,IAMP,EAAAM,SAAiBzE,EAAWmE,OAAO,GAGnC,EAAA1C,oBAAoB,IACpB,EAAAN,cAAc,GACd,EAAAG,cAAc,KAuoBhCtB,EAAWR,UAAUwK,gBAAgB,GAKrC,EAAA,IAAYD,SAAS,mXAAA,IAqDrB,SAAYhK,IAAAA;AACV,QAAAkK,GAAA,UAAA,WACAA,GAAA,aAAA;MACD,GAHWlK,MAAAA,IAAI,CAAA,EAAA,GAAA;IAAA,GAAA,CAAA;;;",
  "names": ["root", "factory", "exports", "module", "require", "define", "amd", "a", "i", "this", "__WEBPACK_EXTERNAL_MODULE__370__", "__webpack_module_cache__", "__webpack_require__", "moduleId", "cachedModule", "__webpack_modules__", "d", "definition", "key", "o", "Object", "defineProperty", "enumerable", "get", "obj", "prop", "prototype", "hasOwnProperty", "call", "r", "Symbol", "toStringTag", "value", "Mode", "FieldAngle", "validator", "config", "super", "SKIP_SETUP", "clockwise", "offset", "displayMin", "displayMax", "minorTick", "majorTick", "symbol", "boundEvents", "line", "gauge", "symbolElement", "configure_", "min", "setMin", "DEFAULT_MIN", "max", "setMax", "DEFAULT_MAX", "precision", "setPrecision", "DEFAULT_PRECISION", "setValue", "setValidator", "mode", "COMPASS", "PROTRACTOR", "Error", "initView", "dom", "createSvgElement", "Svg", "TSPAN", "appendChild", "document", "createTextNode", "getTextElement", "render_", "updateGraph", "e", "noFocus", "userAgent", "MOBILE", "ANDROID", "IPAD", "showEditor_", "editor", "dropdownCreate", "getContentDiv", "sourceBlock", "getSourceBlock", "setColour", "style", "colourPrimary", "colourTertiary", "showPositionedByField", "dropdownDispose", "bind", "svg", "SVG", "SVG_NS", "HTML_NS", "XLINK_NS", "HALF", "touchAction", "circle", "CIRCLE", "cx", "cy", "RADIUS", "class", "PATH", "LINE", "x1", "y1", "minValueDegrees", "math", "toDegrees", "fieldAngleToRadians", "min_", "maxValueDegrees", "max_", "drawTicks", "tickAngle", "length", "Math", "ceil", "floor", "angle", "x2", "y2", "transform", "displayRange", "minorTickAngle", "majorTickAngle", "push", "conditionalBind", "hide", "onMouseMove_", "event", "unbind", "hideIfOwner", "bBox", "ownerSVGElement", "getBoundingClientRect", "dx", "clientX", "left", "dy", "clientY", "top", "atan2", "isNaN", "radiansToFieldAngle", "displayMouseOrKeyboardValue", "PI", "validAngle", "doClassValidation_", "value_", "oldValue", "setEditorValue_", "sourceBlock_", "isEnabled", "fire", "BLOCK_FIELD_INTERMEDIATE_CHANGE", "name", "Number", "getText", "path", "angle1", "toRadians", "cos", "sin", "clockwiseFlag", "largeFlag", "abs", "setAttribute", "onHtmlInputKeyDown_", "block", "multiplier", "RTL", "getValue", "precision_", "preventDefault", "stopPropagation", "newValue", "isFinite", "wrapValue", "round", "toFixed", "valueRange", "undershoot", "overshoot", "options", "registerFieldAngle", "register", "DEFAULT_VALUE", "t"]
}
