import {
  Css,
  DropDownDiv,
  Events,
  Field,
  Msg,
  browserEvents,
  fieldRegistry,
  utils
} from "./chunk-YGIJMPNG.js";
import "./chunk-37NJYYKB.js";
import "./chunk-PLDDJCW6.js";

// node_modules/@blockly/field-bitmap/src/field-bitmap.ts
Msg["BUTTON_LABEL_RANDOMIZE"] = "Randomize";
Msg["BUTTON_LABEL_CLEAR"] = "Clear";
var DEFAULT_HEIGHT = 5;
var DEFAULT_WIDTH = 5;
var DEFAULT_PIXEL_SIZE = 15;
var DEFAULT_PIXEL_COLOURS = {
  empty: "#fff",
  filled: "#363d80"
};
var DEFAULT_BUTTONS = {
  randomize: true,
  clear: true
};
var FieldBitmap = class extends Field {
  initialValue = null;
  imgHeight;
  imgWidth;
  /**
   * Array holding info needed to unbind events.
   * Used for disposing.
   */
  boundEvents = [];
  /** References to UI elements */
  editorPixels = null;
  blockDisplayPixels = null;
  /** Stateful variables */
  pointerIsDown = false;
  valToPaintWith;
  buttonOptions;
  pixelSize;
  pixelColours;
  fieldHeight;
  /**
   * Constructor for the bitmap field.
   *
   * @param value 2D rectangular array of 1s and 0s.
   * @param validator A function that is called to validate.
   * @param config Config A map of options used to configure the field.
   */
  constructor(value, validator, config) {
    super(value, validator, config);
    this.SERIALIZABLE = true;
    this.buttonOptions = { ...DEFAULT_BUTTONS, ...config?.buttons };
    this.pixelColours = { ...DEFAULT_PIXEL_COLOURS, ...config?.colours };
    const currentValue = this.getValue();
    if (currentValue !== null) {
      this.imgHeight = currentValue.length;
      this.imgWidth = currentValue[0].length || 0;
    } else {
      this.imgHeight = config?.height ?? DEFAULT_HEIGHT;
      this.imgWidth = config?.width ?? DEFAULT_WIDTH;
      this.setValue(this.getEmptyArray());
    }
    this.fieldHeight = config?.fieldHeight;
    if (this.fieldHeight) {
      this.pixelSize = this.fieldHeight / this.imgHeight;
    } else {
      this.pixelSize = DEFAULT_PIXEL_SIZE;
    }
  }
  /**
   * Constructs a FieldBitmap from a JSON arg object.
   *
   * @param options A JSON object with options.
   * @returns The new field instance.
   */
  static fromJson(options) {
    return new this(
      options.value ?? Field.SKIP_SETUP,
      void 0,
      options
    );
  }
  /**
   * Returns the width of the image in pixels.
   *
   * @returns The width in pixels.
   */
  getImageWidth() {
    return this.imgWidth;
  }
  /**
   * Returns the height of the image in pixels.
   *
   * @returns The height in pixels.
   */
  getImageHeight() {
    return this.imgHeight;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  doClassValidation_(newValue) {
    if (!newValue) {
      return null;
    }
    if (!Array.isArray(newValue)) {
      return null;
    }
    const newHeight = newValue.length;
    if (newHeight == 0) {
      return null;
    }
    const newWidth = newValue[0].length;
    for (const row of newValue) {
      if (!Array.isArray(row)) {
        return null;
      }
      if (row.length !== newWidth) {
        return null;
      }
    }
    for (const row of newValue) {
      for (const cell of row) {
        if (cell !== 0 && cell !== 1) {
          return null;
        }
      }
    }
    return newValue;
  }
  /**
   * Called when a new value has been validated and is about to be set.
   *
   * @param newValue The value that's about to be set.
   */
  // eslint-disable-next-line
  doValueUpdate_(newValue) {
    super.doValueUpdate_(newValue);
    if (newValue) {
      this.imgHeight = newValue.length;
      this.imgWidth = newValue[0] ? newValue[0].length : 0;
      if (this.fieldHeight) {
        this.pixelSize = this.fieldHeight / this.imgHeight;
      } else {
        this.pixelSize = DEFAULT_PIXEL_SIZE;
      }
    }
  }
  /**
   * Show the bitmap editor dialog.
   *
   * @param e Optional mouse event that triggered the field to open, or
   *    undefined if triggered programmatically.
   */
  // eslint-disable-next-line
  showEditor_(e) {
    const editor = this.dropdownCreate();
    DropDownDiv.getContentDiv().appendChild(editor);
    DropDownDiv.showPositionedByField(
      this,
      this.dropdownDispose.bind(this)
    );
  }
  /**
   * Updates the block display and editor dropdown when the field re-renders.
   */
  // eslint-disable-next-line
  render_() {
    super.render_();
    if (!this.getValue()) {
      return;
    }
    if (this.blockDisplayPixels) {
      this.forAllCells((r, c) => {
        const pixel = this.getPixel(r, c);
        if (this.blockDisplayPixels) {
          this.blockDisplayPixels[r][c].style.fill = pixel ? this.pixelColours.filled : this.pixelColours.empty;
        }
        if (this.editorPixels) {
          this.editorPixels[r][c].style.background = pixel ? this.pixelColours.filled : this.pixelColours.empty;
        }
      });
    }
  }
  /**
   * Determines whether the field is editable.
   *
   * @returns True since it is always editable.
   */
  updateEditable() {
    const editable = super.updateEditable();
    const svgRoot = this.getSvgRoot();
    if (svgRoot) {
      utils.dom.removeClass(svgRoot, "blocklyNonEditableField");
      utils.dom.removeClass(svgRoot, "blocklyEditableField");
    }
    return editable;
  }
  /**
   * Gets the rectangle built out of dimensions matching SVG's <g> element.
   *
   * @returns The newly created rectangle of same size as the SVG element.
   */
  getScaledBBox() {
    const boundingBox = this.getSvgRoot()?.getBoundingClientRect();
    if (!boundingBox) {
      throw new Error("Tried to retrieve a bounding box without a rect");
    }
    return new utils.Rect(
      boundingBox.top,
      boundingBox.bottom,
      boundingBox.left,
      boundingBox.right
    );
  }
  /**
   * Creates the bitmap editor and add event listeners.
   *
   * @returns The newly created dropdown menu.
   */
  dropdownCreate() {
    const dropdownEditor = this.createElementWithClassname(
      "div",
      "dropdownEditor"
    );
    if (this.buttonOptions.randomize || this.buttonOptions.clear) {
      dropdownEditor.classList.add("has-buttons");
    }
    const pixelContainer = this.createElementWithClassname(
      "div",
      "pixelContainer"
    );
    dropdownEditor.appendChild(pixelContainer);
    DropDownDiv.getContentDiv().classList.add("contains-bitmap-editor");
    this.bindEvent(dropdownEditor, "pointermove", this.onPointerMove);
    this.bindEvent(dropdownEditor, "pointerup", this.onPointerEnd);
    this.bindEvent(dropdownEditor, "pointerleave", this.onPointerEnd);
    this.bindEvent(dropdownEditor, "pointerdown", this.onPointerStart);
    this.bindEvent(dropdownEditor, "pointercancel", this.onPointerEnd);
    this.bindEvent(dropdownEditor, "touchmove", (e) => {
      e.preventDefault();
    });
    this.editorPixels = [];
    for (let r = 0; r < this.imgHeight; r++) {
      this.editorPixels.push([]);
      const rowDiv = this.createElementWithClassname("div", "pixelRow");
      for (let c = 0; c < this.imgWidth; c++) {
        const button = this.createElementWithClassname("div", "pixelButton");
        this.editorPixels[r].push(button);
        rowDiv.appendChild(button);
        const isOn = this.getPixel(r, c);
        button.style.background = isOn ? this.pixelColours.filled : this.pixelColours.empty;
        button.setAttribute("data-row", r.toString());
        button.setAttribute("data-col", c.toString());
      }
      pixelContainer.appendChild(rowDiv);
    }
    if (this.buttonOptions.randomize) {
      this.addControlButton(
        dropdownEditor,
        Msg["BUTTON_LABEL_RANDOMIZE"],
        this.randomizePixels
      );
    }
    if (this.buttonOptions.clear) {
      this.addControlButton(
        dropdownEditor,
        Msg["BUTTON_LABEL_CLEAR"],
        this.clearPixels
      );
    }
    if (this.blockDisplayPixels) {
      this.forAllCells((r, c) => {
        const pixel = this.getPixel(r, c);
        if (this.editorPixels) {
          this.editorPixels[r][c].style.background = pixel ? this.pixelColours.filled : this.pixelColours.empty;
        }
      });
    }
    this.initialValue = this.getValue();
    return dropdownEditor;
  }
  /**
   * Initializes the on-block display.
   */
  initView() {
    this.blockDisplayPixels = [];
    for (let r = 0; r < this.imgHeight; r++) {
      const row = [];
      for (let c = 0; c < this.imgWidth; c++) {
        const square = utils.dom.createSvgElement(
          "rect",
          {
            x: c * this.pixelSize,
            y: r * this.pixelSize,
            width: this.pixelSize,
            height: this.pixelSize,
            fill: this.pixelColours.empty,
            fill_opacity: 1
            // eslint-disable-line
          },
          this.getSvgRoot()
        );
        row.push(square);
      }
      this.blockDisplayPixels.push(row);
    }
  }
  /**
   * Updates the size of the block based on the size of the underlying image.
   */
  // eslint-disable-next-line
  updateSize_() {
    {
      const newWidth = this.pixelSize * this.imgWidth;
      const newHeight = this.pixelSize * this.imgHeight;
      if (this.borderRect_) {
        this.borderRect_.setAttribute("width", String(newWidth));
        this.borderRect_.setAttribute("height", String(newHeight));
      }
      this.size_.width = newWidth;
      this.size_.height = newHeight;
    }
  }
  /**
   * Create control button.
   *
   * @param parent Parent HTML element to which control button will be added.
   * @param buttonText Text of the control button.
   * @param onClick Callback that will be attached to the control button.
   */
  addControlButton(parent, buttonText, onClick) {
    const button = this.createElementWithClassname("button", "controlButton");
    button.innerText = buttonText;
    parent.appendChild(button);
    this.bindEvent(button, "click", onClick);
  }
  /**
   * Disposes of events belonging to the bitmap editor.
   */
  dropdownDispose() {
    if (this.getSourceBlock() && this.initialValue !== null && this.initialValue !== this.getValue()) {
      Events.fire(
        new (Events.get(Events.BLOCK_CHANGE))(
          this.sourceBlock_,
          "field",
          this.name || null,
          this.initialValue,
          this.getValue()
        )
      );
    }
    for (const event of this.boundEvents) {
      browserEvents.unbind(event);
    }
    this.boundEvents.length = 0;
    this.editorPixels = null;
    this.initialValue = null;
    DropDownDiv.getContentDiv().classList.remove(
      "contains-bitmap-editor"
    );
  }
  /**
   * Constructs an array of zeros with the specified width and height.
   *
   * @returns The new value.
   */
  getEmptyArray() {
    const newVal = [];
    for (let r = 0; r < this.imgHeight; r++) {
      newVal.push([]);
      for (let c = 0; c < this.imgWidth; c++) {
        newVal[r].push(0);
      }
    }
    return newVal;
  }
  /**
   * Checks if a down event is on a pixel in this editor and if it is starts an
   * edit gesture.
   *
   * @param e The down event.
   */
  onPointerStart(e) {
    const currentElement = document.elementFromPoint(e.clientX, e.clientY);
    const rowIndex = currentElement?.getAttribute("data-row");
    const colIndex = currentElement?.getAttribute("data-col");
    if (rowIndex && colIndex) {
      this.onPointerDownInPixel(parseInt(rowIndex), parseInt(colIndex));
      this.pointerIsDown = true;
      e.preventDefault();
    }
  }
  /**
   * Updates the editor if we're in an edit gesture and the pointer is over a
   * pixel.
   *
   * @param e The move event.
   */
  onPointerMove(e) {
    if (!this.pointerIsDown) {
      return;
    }
    const currentElement = document.elementFromPoint(e.clientX, e.clientY);
    const rowIndex = currentElement?.getAttribute("data-row");
    const colIndex = currentElement?.getAttribute("data-col");
    if (rowIndex && colIndex) {
      this.updatePixelValue(parseInt(rowIndex), parseInt(colIndex));
    }
    e.preventDefault();
  }
  /**
   * Starts an interaction with the bitmap dropdown when there's a pointerdown
   * within one of the pixels in the editor.
   *
   * @param r Row number of grid.
   * @param c Column number of grid.
   */
  onPointerDownInPixel(r, c) {
    const newPixelValue = 1 - this.getPixel(r, c);
    this.setPixel(r, c, newPixelValue);
    this.pointerIsDown = true;
    this.valToPaintWith = newPixelValue;
  }
  /**
   * Sets the specified pixel in the editor to the current value being painted.
   *
   * @param r Row number of grid.
   * @param c Column number of grid.
   */
  updatePixelValue(r, c) {
    if (this.valToPaintWith !== void 0 && this.getPixel(r, c) !== this.valToPaintWith) {
      this.setPixel(r, c, this.valToPaintWith);
    }
  }
  /**
   * Resets pointer state (e.g. After either a pointerup event or if the
   * gesture is canceled).
   */
  onPointerEnd() {
    this.pointerIsDown = false;
    this.valToPaintWith = void 0;
  }
  /**
   * Sets all the pixels in the image to a random value.
   */
  randomizePixels() {
    const getRandBinary = () => Math.floor(Math.random() * 2);
    this.forAllCells((r, c) => {
      this.setPixel(r, c, getRandBinary());
    });
  }
  /**
   * Sets all the pixels to 0.
   */
  clearPixels() {
    const cleared = this.getEmptyArray();
    this.fireIntermediateChangeEvent(cleared);
    this.setValue(cleared, false);
  }
  /**
   * Sets the value of a particular pixel.
   *
   * @param r Row number of grid.
   * @param c Column number of grid.
   * @param newValue Value of the pixel.
   */
  setPixel(r, c, newValue) {
    const newGrid = JSON.parse(JSON.stringify(this.getValue()));
    newGrid[r][c] = newValue;
    this.fireIntermediateChangeEvent(newGrid);
    this.setValue(newGrid, false);
  }
  getPixel(row, column) {
    const value = this.getValue();
    if (!value) {
      throw new Error(
        "Attempted to retrieve a pixel value when no value is set"
      );
    }
    return value[row][column];
  }
  /**
   * Calls a given function for all cells in the image, with the cell
   * coordinates as the arguments.
   *
   * @param func A function to be applied.
   */
  forAllCells(func) {
    for (let r = 0; r < this.imgHeight; r++) {
      for (let c = 0; c < this.imgWidth; c++) {
        func(r, c);
      }
    }
  }
  /**
   * Creates a new element with the specified type and class.
   *
   * @param elementType Type of html element.
   * @param className ClassName of html element.
   * @returns The created element.
   */
  createElementWithClassname(elementType, className) {
    const newElt = document.createElement(elementType);
    newElt.className = className;
    return newElt;
  }
  /**
   * Binds an event listener to the specified element.
   *
   * @param element Specified element.
   * @param eventName Name of the event to bind.
   * @param callback Function to be called on specified event.
   */
  bindEvent(element, eventName, callback) {
    this.boundEvents.push(
      browserEvents.bind(element, eventName, this, callback)
    );
  }
  fireIntermediateChangeEvent(newValue) {
    if (this.getSourceBlock()) {
      Events.fire(
        new (Events.get(
          Events.BLOCK_FIELD_INTERMEDIATE_CHANGE
        ))(this.getSourceBlock(), this.name || null, this.getValue(), newValue)
      );
    }
  }
};
fieldRegistry.register("field_bitmap", FieldBitmap);
Css.register(`
.dropdownEditor {
  align-items: center;
  flex-direction: column;
  display: flex;
  justify-content: center;
}
.dropdownEditor.has-buttons {
  margin-bottom: 20px;
}
.pixelContainer {
  margin: 20px;
}
.pixelRow {
  display: flex;
  flex-direction: row;
  padding: 0;
  margin: 0;
  height: ${DEFAULT_PIXEL_SIZE}
}
.pixelButton {
  width: ${DEFAULT_PIXEL_SIZE}px;
  height: ${DEFAULT_PIXEL_SIZE}px;
  border: 1px solid #000;
}
.pixelDisplay {
  white-space:pre-wrap;
}
.controlButton {
  margin: 5px 0;
}
.blocklyDropDownContent.contains-bitmap-editor {
  max-height: none;
}
`);
export {
  DEFAULT_HEIGHT,
  DEFAULT_WIDTH,
  FieldBitmap
};
/*! Bundled license information:

@blockly/field-bitmap/src/field-bitmap.ts:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

@blockly/field-bitmap/src/index.ts:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=@blockly_field-bitmap.js.map
